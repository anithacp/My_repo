/******************************************************************************

                              Copyright (c) 2009
                            Lantiq Deutschland GmbH
                     Am Campeon 3; 85579 Neubiberg, Germany

  For licensing information, see the file 'LICENSE' in the root folder of
  this software module.

*******************************************************************************/

/** \file
   AVINAX specific implementation of DSL control thread
*/

#define DSL_INTERN

#include "lib_dsl_api.h"

#if defined(INCLUDE_DSL_API_GEMINAX_R3) || defined(INCLUDE_DSL_API_VINAX_R3)

#include "ifxos_std_defs.h" /* errno */
#include "drv_mei3_interface.h"

#include "lib_dsl_pm.h"
#include "lib_dsl_pm_core.h"
#include "lib_dsl_pm_line_ep.h"
#include "lib_dsl_pm_channel_ep.h"
#include "lib_dsl_pm_data_path_ep.h"
#include "lib_dsl_pm_retrans_ep.h"
#include "lib_dsl_pm_dev.h"

#include "lib_dsl_os.h"
#include "lib_dsl_avinax.h"
#include "lib_dsl_avinax_ct.h"
#include "lib_dsl_db.h"
#include "lib_dsl_vinax_psd.h"

#include "lib_dsl_avinax_msg.h"

#include "lib_dsl_avinax_msg_cnth.h"
#include "lib_dsl_avinax_msg_hmh.h"
#include "lib_dsl_avinax_msg_mth.h"
#include "lib_dsl_avinax_msg_mtk.h"
#include "lib_dsl_avinax_msg_oph.h"
#include "lib_dsl_avinax_msg_omh.h"
#include "lib_dsl_avinax_msg_xsm.h"
#include "lib_dsl_avinax_msg_selt.h"
#include "lib_dsl_avinax_msg_tsm.h"
#include "lib_dsl_avinax_msg_ssm.h"
#include "lib_dsl_avinax_msg_vsm.h"
#include "lib_dsl_avinax_msg_hsm.h"
#include "lib_dsl_avinax_msg_dsmd.h"

#ifdef INCLUDE_DSL_API_AVINAX_MELT
#include "lib_melt_avinax.h"
#include "lib_dsl_melt_avinax.h"
#endif

#ifdef INCLUDE_DSL_BND
#include "lib_dsl_avinax_bnd.h"
#endif

#include "lib_dsl_g997_dpbo.h"

#if defined(INCLUDE_DSL_DSM) && (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
#include "lib_dsl_dsm.h"
#endif /* defined(INCLUDE_DSL_DSM) */

_DSLAPI_USE
_DSLAPI_BEGIN

#undef DSL_DBG_BLOCK
#define DSL_DBG_BLOCK DSL_DBG_CONTROL_THREAD

/* for debugging: */
#ifdef DSL_LOCAL
#undef DSL_LOCAL
#endif
#if 0
#define DSL_LOCAL
#else
#define DSL_LOCAL static
#endif

#define DSL_OHC_TESTPARAM_ID_NONE   0
/** Test Parameter ID for OHC requests for
   HLog
   according Table 9-30/G.992.3 */
#define DSL_OHC_TESTPARAM_ID_HLOG   1
/** Test Parameter ID for OHC requests for
   QLN
   according Table 9-30/G.992.3 */
#define DSL_OHC_TESTPARAM_ID_QLN    3
/** Test Parameter ID for OHC requests for
   SNR
   according Table 9-30/G.992.3 */
#define DSL_OHC_TESTPARAM_ID_SNR    4
#define DSL_OHC_TESTPARAM_ID_LAST   5

#define DSL_OHC_SINGLE_REQUEST 0x00010000


/** swap high and low byte of an unsigned 16bit */
#define DSL_UINT16_SWAP(val) (((val)<<8) | ((val)>>8))

/** print and set the current line status in the data base */
#define AVX_STATE_SET(AVX_Status, G997_Status, bResetValues, nPMStatus, text) \
   case AVX_Status:\
   {\
      errorCode = DSL_AVX_LineStateChange(pContext, nLine, \
                  G997_Status, bResetValues, (DSL_int32_t)nPMStatus, text, \
                  (DSL_uint32_t*)&nActLineState, &bEventCallback); \
   } break;

/** print the actual exception code explanation */
#define AVX_EXCEPTION_SET(AVX_Exception, nLinit, text) \
   case AVX_Exception:\
   {\
      pStatusString = text; \
      nStatus = nLinit; \
   } break;

/** Processes a given bit value of a firmware and maps it into the bit field
    value (and bit field mask) if the state of the bit has been changed since
    last occurence of the macro call.
    \param MSGBIT        Name of bit in "RSP_Line_Failures" message, [I]
    \param nPreBitField  Previous value of line failure bit mask from data
                         base, [I]
    \param nBitMask      Definition of line failure bit as defined in enum type
                         of DSL library, [I]
    \param nActBitField  Actual value of line failure bit mask from GMX-D
                         (mapped from MSGBIT).
                         This value will be generated by the macro, [O]
    \param nBitFieldMask Returns a bit mask that indicates which failure bits
                         has been toggled from previous to actual line failure
                         status. This value will be generated by the macro, [O]
*/
#define DSL_FAILUREBIT_SET(MSGVAR, MSGBIT, nPreBitField, nBitMask, nActBitField, nBitFieldMask) \
   if ((pAck->MSGVAR & MSGBIT##_MASK) >> MSGBIT##_POS) \
   { \
      nActBitField |= nBitMask; \
   } \
   if ( (nActBitField & nBitMask) != (nPreBitField & nBitMask) ) \
   { \
      nBitFieldMask |= nBitMask; \
   }


/**
   Maximum number of items to be retrieved by one
   CMD_TestParamsFE_Request command.
   FIXME: Blocksize 10 caused last two values to be wrong. */
#define AVX_MAX_TESTPARAMS_BLOCK       32

/**
   AVINAX Mailbox error codes */
#define AVX_FW_MSG_UNKNOWN             0xFFFF
#define AVX_FW_GLOBAL_REQ_PENDING      0xFF7F
#define AVX_FW_SYSIF_REQ_PENDING       0xFF7E
#define AVX_FW_CH_REQ_PENDING          0xFF7D
#define AVX_FW_CH_NON_IDLE             0xFF7C
#define AVX_FW_SEMAPHORE_BUSY          0xFF7B
#define AVX_FW_LINE_BUSY               0xFFF4

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/** The number of parameters in a preselection entry to weight */
#define DSL_EAPS2_PRESELECT_MAX_WEIGHT 3
/** EAPS2 Preselection Table Entry.
   Contains some configuration parameters of one VDSL2 profile */
typedef struct
{
   /** VDSL2 profile this entry belongs to  */
   AVX_VdslProfileSel_t vdslProfile;
   /** Usage of US0 band possible */
   DSL_uint16_t US0Usage;
   /** MaxNomATP in downstream */
   DSL_uint16_t MaxnomatpDs;
   /** Maximum usable tone in downstream */
   DSL_uint16_t MaxFrequency;
} DSL_AVX_APS_PreselectData_t;

static const DSL_AVX_APS_PreselectData_t DSL_AVX_APS_PreselectDataTable[AVX_VDSL_PROFILE_30A] = {
   { AVX_VDSL_PROFILE_8A,     1,    175,     2040 },
   { AVX_VDSL_PROFILE_8B,     1,    205,     2040 },
   { AVX_VDSL_PROFILE_8C,     1,    115,     2040 },
   { AVX_VDSL_PROFILE_8D,     1,    145,     2040 },
   { AVX_VDSL_PROFILE_12A,    1,    145,     2782 },
   { AVX_VDSL_PROFILE_12B,    0,    145,     2782 },
   { AVX_VDSL_PROFILE_17A,    1,    145,     4096 },
   { AVX_VDSL_PROFILE_30A,    0,    145,     6956 }
} ;

typedef struct
{
   DSL_AVX_APS_PreselectData_t Entry[AVX_VDSL_PROFILE_30A];
} DSL_AVX_APS_PreselectDataTable_t;
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#define DSL_LINE_STATE_GET(nLine) (_DSLAPI DSL_DB_uint32Get( pContext, DSL_DBS_ACT_LINESTATE, nLine, 0 ))
#define DSL_CHECK_LINE_SHOWTIME(nLine) ((DSL_LINE_STATE_GET(nLine) == DSL_LINESTATUS_SHOWTIME_TC_SYNC) || \
            (DSL_LINE_STATE_GET(nLine) == DSL_LINESTATUS_SHOWTIME_NO_SYNC) || \
            (DSL_LINE_STATE_GET(nLine) == DSL_LINESTATUS_MELT_PARK))

#ifdef DSL_OHC_QUEUE
#define DSL_AVX_OHC_TIMEOUT            8000

#define DSL_AVX_OHC_QUEUE_SEM_TIMEOUT 100

/* Attention: don't issue the OHC callback with  QueueSemaphore busy */
#define AVX_OHC_MSG_MAKE_CALL(pContext, nLine, pMsg, status) do {                \
   if (pMsg->CallbackFunction != DSL_NULL)                                       \
   {                                                                             \
      AVX_EvtOhcStatusGet_t sEvt = { status };                                   \
      pMsg->CallbackFunction(pContext, nLine, &sEvt, pMsg->CallbackData);        \
   }                                                                             \
} while (0)

typedef struct {
   uint16 status;
   AVX_OhcMsg_t ohcReceive;
} AVX_CallbackData_t;
#endif /* DSL_OHC_QUEUE */

#if (DSL_FAILURE_PRIORITIZATION > 0)

#define DSL_FAILURE_TIMEOUT 1000

typedef DSL_uint32_t DSL_FailureMask_t;

#if 0
typedef enum {
   DSL_FAILURE_PRIO_FE_LPR,
   DSL_FAILURE_PRIO_NE_LOS,
   DSL_FAILURE_PRIO_NE_LOF,
   DSL_FAILURE_PRIO_NE_ESE,
   DSL_FAILURE_PRIO_NE_LCD,
   DSL_FAILURE_PRIO_NE_NCD = DSL_FAILURE_PRIO_NE_LCD,
   DSL_FAILURE_PRIO_NE_LPD = DSL_FAILURE_PRIO_NE_LCD,
   DSL_FAILURE_PRIO_NE_NPD = DSL_FAILURE_PRIO_NE_LCD,
   DSL_FAILURE_PRIO_NE_LOM,
   DSL_FAILURE_PRIO_FE_LOS,
   DSL_FAILURE_PRIO_FE_LOF,
   DSL_FAILURE_PRIO_FE_ESE,
   DSL_FAILURE_PRIO_FE_LCD,
   DSL_FAILURE_PRIO_FE_NCD = DSL_FAILURE_PRIO_FE_LCD,
   DSL_FAILURE_PRIO_FE_LPD = DSL_FAILURE_PRIO_FE_LCD,
   DSL_FAILURE_PRIO_FE_NPD = DSL_FAILURE_PRIO_FE_LCD,
   DSL_FAILURE_PRIO_FE_LOM
} DSL_FailurePrio_t;
#endif

typedef enum {
   DSL_FAILURE_FE_LPR,
   DSL_FAILURE_NE_LOS,
   DSL_FAILURE_NE_LOF,
   DSL_FAILURE_NE_ESE,
   DSL_FAILURE_NE_LCD,
   DSL_FAILURE_NE_NCD,
   DSL_FAILURE_NE_LPD,
   DSL_FAILURE_NE_NPD,
   DSL_FAILURE_NE_LOM,
   DSL_FAILURE_FE_LOS,
   DSL_FAILURE_FE_LOF,
   DSL_FAILURE_FE_ESE,
   DSL_FAILURE_FE_LCD,
   DSL_FAILURE_FE_NCD,
   DSL_FAILURE_FE_LPD,
   DSL_FAILURE_FE_NPD,
   DSL_FAILURE_FE_LOM
} DSL_Failure_t;

#define DSL_FAILURE_BIT(name) (1 << DSL_FAILURE_##name)

#define DSL_FAILURE_MASK_BIT_SET(mask, name, val) do { \
   if (val == 0)                                   \
      mask &= ~ DSL_FAILURE_BIT(name);             \
   else                                            \
      mask |= DSL_FAILURE_BIT(name);               \
} while (0)

typedef enum {
   DSL_FAILURE_TYPE_LINE,
   DSL_FAILURE_TYPE_DATA_PATH
} DSL_FailureType_t;

typedef struct {
   DSL_Failure_t nFailure;
   DSL_ATUDir_t nDir;
   DSL_FailureType_t nFailureType;
#if 0
   DSL_FailurePrio_t nFailurePrio;
#endif
   DSL_uint32_t g997mask;
} DSL_FailureInfo_t;

#if 0
#define DSL_FAILURE_INFO(name, near, mask, type) \
   { DSL_FAILURE_##name, near, DSL_FAILURE_TYPE_##type, DSL_FAILURE_PRIO_##name, mask }
#endif

#define DSL_FAILURE_INFO(name, near, mask, type) \
   { (DSL_Failure_t)(DSL_FAILURE_##name), (DSL_ATUDir_t)(near), (DSL_FailureType_t)(DSL_FAILURE_TYPE_##type), (DSL_uint32_t)(mask) }

static DSL_FailureInfo_t DSL_FailureInfo_Table[] = {
   DSL_FAILURE_INFO(FE_LPR, DSL_FAR_END,  DSL_G997_LINEFAILURE_LPR,     LINE),
   DSL_FAILURE_INFO(NE_LOS, DSL_NEAR_END, DSL_G997_LINEFAILURE_LOS,     LINE),
   DSL_FAILURE_INFO(NE_LOF, DSL_NEAR_END, DSL_G997_LINEFAILURE_LOF,     LINE),
   DSL_FAILURE_INFO(NE_ESE, DSL_NEAR_END, DSL_G997_LINEFAILURE_ESE,     LINE),
   DSL_FAILURE_INFO(NE_LCD, DSL_NEAR_END, DSL_G997_DATAPATHFAILURE_LCD, DATA_PATH),
   DSL_FAILURE_INFO(NE_NCD, DSL_NEAR_END, DSL_G997_DATAPATHFAILURE_NCD, DATA_PATH),
   DSL_FAILURE_INFO(NE_LPD, DSL_NEAR_END, DSL_G997_DATAPATHFAILURE_LPD, DATA_PATH),
   DSL_FAILURE_INFO(NE_NPD, DSL_NEAR_END, DSL_G997_DATAPATHFAILURE_NPD, DATA_PATH),
   DSL_FAILURE_INFO(NE_LOM, DSL_NEAR_END, DSL_G997_LINEFAILURE_LOM,     LINE),
   DSL_FAILURE_INFO(FE_LOS, DSL_FAR_END,  DSL_G997_LINEFAILURE_LOS,     LINE),
   DSL_FAILURE_INFO(FE_LOF, DSL_FAR_END,  DSL_G997_LINEFAILURE_LOF,     LINE),
   DSL_FAILURE_INFO(FE_ESE, DSL_FAR_END,  DSL_G997_LINEFAILURE_ESE,     LINE),
   DSL_FAILURE_INFO(FE_LCD, DSL_FAR_END,  DSL_G997_DATAPATHFAILURE_LCD, DATA_PATH),
   DSL_FAILURE_INFO(FE_NCD, DSL_FAR_END,  DSL_G997_DATAPATHFAILURE_NCD, DATA_PATH),
   DSL_FAILURE_INFO(FE_LPD, DSL_FAR_END,  DSL_G997_DATAPATHFAILURE_LPD, DATA_PATH),
   DSL_FAILURE_INFO(FE_NPD, DSL_FAR_END,  DSL_G997_DATAPATHFAILURE_NPD, DATA_PATH),
   DSL_FAILURE_INFO(FE_LOM, DSL_FAR_END,  DSL_G997_LINEFAILURE_LOM,     LINE),
};

#endif

#define DSL_RECOVERY_RETRY_COUNT_MAX 5

typedef enum
{
   DSL_DELT_FE_HLOG,
   DSL_DELT_FE_SNR,
   DSL_DELT_FE_QLN,
   DSL_DELT_FE_LAST
} DSL_DeltFeTypes_t;

/* prototypes */

#ifdef INCLUDE_DSL_API_AVINAX_MELT
extern DSL_void_t MELT_LTC_ResetStates (DSL_Context_t *pContext, const DSL_uint16_t nLine);
#endif

/* handle messages received from AVINAX */
DSL_LOCAL DSL_Error_t DSL_AVX_HandleMessage
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

#if (defined(ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_) && (ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_ == 1))

#if defined(ADRV_MEI3_IF_HAVE_PARALLEL_FW_DL) && (ADRV_MEI3_IF_HAVE_PARALLEL_FW_DL==1)
#if defined(INCLUDE_DSL_API_CO_ONLY)
DSL_LOCAL DSL_Error_t DSL_AVX_OnDrvRmtFileWriteEvt
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVINAX_DRV_MSG_all_t *pDrvMsg
);
#endif
#endif

#if (DSL_AVX_SUPPORT_DEVICE_SUPERVISION == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_OnDrvSupervisionDeviceEvt(
   DSL_Context_t        *pContext,
   const DSL_uint16_t   nLine,
   AVINAX_DRV_MSG_all_t  *pDrvMsg);
#endif

#endif   /* #if (defined(ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_) && (ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_ == 1)) */

DSL_LOCAL DSL_Error_t DSL_AVX_OnLineFailureNeGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtLineFailureNeGet_t const *pAck
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnLineFailureFeGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtLineFailureFeGet_t const *pAck
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnDataPathFailuresNeGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtDataPathFailureNeGet_t const *pAck
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnDataPathFailuresFeGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtDataPathFailureFeGet_t const *pAck
);

#ifdef DSL_PM_FW_THRESHOLD_CHECKING
DSL_LOCAL DSL_Error_t DSL_AVX_OnTr1LineCountThreshHit
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtTr1LineCountThreshHit_t const *pAck
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnTr1TcCountThreshHit
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtTr1TcCountThreshHit_t const *pAck
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnTr1ChCountThreshHit
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_AckTr1ChannelCountThreshHit_t const *pAck
);
#endif

DSL_LOCAL DSL_Error_t DSL_AVX_OnPerformanceCounters(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   const DSL_uint16_t *pMsg);

#if 0 /* using only in EVT_PMD_TESTPARAMSGET which is commented now */
DSL_LOCAL DSL_Error_t DSL_AVX_WaitingMessageCopyData
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t const *pMsg,
   const DSL_uint16_t nSize
);
#endif

DSL_LOCAL DSL_Error_t DSL_AVX_dbSetPMMode
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_G997_PowerManagementState_t nPMMode
);

DSL_LOCAL DSL_Error_t DSL_AVX_AllStatusGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_AllSraStatusGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection
);

DSL_LOCAL DSL_Error_t DSL_AVX_AllBitswapStatusGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection
);

DSL_LOCAL DSL_Error_t DSL_AVX_AllStatusFeGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_AllDeltStatusGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnTimeoutEvent
(
   DSL_Context_t *pContext,
   DSL_uint16_t nDevice,
   DSL_uint16_t nLine,
   DSL_int_t nEventType,
   DSL_ulong_t nTimeoutID
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnTimeoutEvent_ApiInit
(
   DSL_Context_t *pContext
);

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_OnTimeoutEvent_OpDataGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_OpDataType_t nOpDataType
);
#endif /* #defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

DSL_LOCAL DSL_Error_t DSL_AVX_OnTimeoutEvent_DsBCStatus
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);


DSL_LOCAL DSL_Error_t DSL_AVX_RecoveryCheck
(
   DSL_Context_t *pContext,
   DSL_uint16_t nDevice
);

DSL_LOCAL DSL_Error_t DSL_AVX_SoftRecoveryCheck
(
   DSL_Context_t *pContext,
   DSL_uint16_t nDevice
);

DSL_LOCAL DSL_Error_t DSL_AVX_MsgTransmit
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_ATUDir_t   nDirection,
   IOCTL_MEI3_LINE_messageSend_t *pMsg
);

DSL_LOCAL DSL_Error_t DSL_AVX_DeltArrayParamsQuery
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint16_t nStartIndex,
   const DSL_uint16_t nStopIndex
);

#ifndef DSL_DEBUG_DISABLE
DSL_LOCAL DSL_Error_t DSL_AVX_SeltDataPrintStatistics
(
   DSL_Context_t *pContext
);
#endif /* DSL_DEBUG_DISABLE */

DSL_LOCAL DSL_Error_t DSL_AVX_DeltFeUpdate
(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   const AVX_EvtOhcStatusGet_t *pMsg
);

DSL_LOCAL DSL_Error_t DSL_AVX_DeltVdslFeUpdate(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   const AVX_EvtOhcStatusGet_t *pMsg,
   const DSL_deltLineData_t *pLineData,
   DSL_deltDirectionData_t *pDirData
);

DSL_LOCAL DSL_Error_t DSL_AVX_DeltAdslFeUpdate(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   const AVX_EvtOhcStatusGet_t *pMsg,
   DSL_deltLineData_t *pLineData,
   DSL_deltDirectionData_t *pDirData
);

DSL_LOCAL DSL_Error_t DSL_AVX_DeltFeRepeat
(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_FeTestParamCopy
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_DeltFeTypes_t nType,
   const DSL_uint16_t nNumItems,
   const DSL_uint16_t *pMsg,
   DSL_uint16_t *pValues
);

DSL_LOCAL DSL_Error_t DSL_AVX_ApplicabilityCheck
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint32_t nMsgId
);

DSL_LOCAL DSL_Error_t DSL_AVX_InitReadyCheck
(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_SeltCpeDetect
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_SeltFDRUpdate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_SeltFDRVarUpdate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_SeltICNUpdate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_ApsDecision
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_ApsTableLookup
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if 0
DSL_LOCAL DSL_Error_t DSL_AVX_MaxUsedToneGet
(
   DSL_Context_t * pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint16_t   * pData
);
#endif

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_ApsAutoModeProcess
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if  (DSL_ENABLE_EAPS == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_EapsFailDecision
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_EapsShowtimeDecision
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_EapsBatSlopeCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_int32_t *nSlope
);
#endif /* (DSL_ENABLE_EAPS == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_ApsP1FailDecision
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_boolean_t bFeTimerActive,
   DSL_boolean_t *bRetrain
);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

DSL_LOCAL DSL_Error_t DSL_AVX_ShowtimeReached
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bEventCallback
);

DSL_LOCAL DSL_Error_t DSL_AVX_AllFailStatusGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_LineStateChange(
   DSL_Context_t        *pContext,
   const DSL_uint16_t   nLine,
   const DSL_uint32_t   G997_Status,
   const DSL_boolean_t  bResetValues,
   const DSL_int32_t   nPMStatus,
   const DSL_char_t     *sText,
   DSL_uint32_t         *nActLineState,
   DSL_boolean_t        *bEventCallback
);

DSL_LOCAL DSL_Error_t DSL_AVX_HsTonesDefaultsSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnOlrEvtGet(
   DSL_Context_t        *pContext,
   const DSL_uint16_t   nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t const    *pStateGet
);

DSL_LOCAL DSL_Error_t DSL_AVX_RtxNdrCalculate(
   DSL_Context_t        *pContext,
   const DSL_uint16_t   nLine,
   const DSL_AccessDir_t nDirection
);

DSL_LOCAL DSL_Error_t DSL_AVX_RtxInpDsCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection
);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_RtxActEtruCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection
);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

DSL_LOCAL DSL_Error_t DSL_AVX_RtxAggAchNdrCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection
);
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_RtxETRCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection
);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

DSL_LOCAL DSL_Error_t DSL_AVX_BearerChannelStatusGet (
   DSL_Context_t * pContext,
   const DSL_uint16_t nLine,
   const DSL_uint8_t nChannel,
   const DSL_AccessDir_t nDirection
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnDead(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_OnApsLineStatusInitGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtApsLineStatusInitGet_t * const pAck
);
#endif

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_OnPsdWarningGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtPsdWarningGet_t * const pAck
);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2ProfilePhysMemCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_uint32_t *pPhysMem
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2ActMemCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t *pActMem
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2AttNdrNextProfileCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_uint32_t *pAttNdr
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MinMemRateConfigCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t *pMinMemRate
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MinMemConfigCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t *pMinMem
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MinMemCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t nActMem,
   DSL_uint32_t *pMinMem
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MaxMemConfigCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t *pMaxMem
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MaxMemCurrentProfileCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t nActMem,
   DSL_uint32_t *pMaxMem
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MaxMemNextProfileCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t nActMem,
   DSL_uint32_t *pMaxMem
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DeltaLineRateCappedCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_int_t nLineRate,
   DSL_uint32_t *pLineRateCapped
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2FixedItlvPartConfigAdslCheck
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_G997_NSCData8_t *pBat,
   DSL_boolean_t bRtxUsed,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2FixedItlvPartConfigVdslCheck
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_boolean_t bRtxUsed,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DynamicItlvPartConfigCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsedDs,
   DSL_boolean_t bRtxUsedUs,
   DSL_uint32_t *pMemPortion
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DynamicItlvPartCurrentProfileCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsedDs,
   DSL_boolean_t bRtxUsedUs,
   DSL_boolean_t *bRetrain,
   DSL_uint32_t *pMemPortion
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_boolean_t bRtxUsedDs,
   DSL_boolean_t bRtxUsedUs,
   DSL_uint32_t *pMemPortion,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2CalculateDsMemPortions
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_uint32_t *nDsMemPortionIfec,
   DSL_uint32_t *nDsMemPortionRtx,
   DSL_uint32_t *nDsMemPortionRtxDsUs
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2CalculateNextProfileDsMemPortion
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3HighestAdslCommonModeGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_DEV_PsdDslMode_t *pCommonDevMode
);

DSL_LOCAL DSL_Error_t DSL_AVX_SendMsgApsPreselectDataSet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2ShowtimeDecision(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D2CheckSend(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t cdCheck
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2PreselectionTableGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_AVX_APS_PreselectDataTable_t *pPreselectTable
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2OnFail(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2Retrain(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2NextLowerProfileSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t bCPECapsCheck
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2NextHigherProfileSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3Check
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D4Check
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_MemSplitRetrainCheck
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DefaultPsdMaskGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_G997_DEV_PsdMaskConfig_t *pPsdMaskConfig
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DeltaLineRateCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nCurrentProfile,
   DSL_uint8_t nNextProfile,
   DSL_int_t *pDeltaLineRate
);

DSL_LOCAL DSL_Profile_t DSL_AVX_ProfileMaskToIndex
(
   DSL_uint8_t nProfile
);

DSL_LOCAL const char * DSL_AVX_ProfileName
(
   DSL_uint8_t nProfile
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3AdslCheck
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_G997_NSCData8_t *pBat,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DeltaLineRatePlusCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pNextBat,
   DSL_uint8_t nCurrentProfile,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_int_t *pDeltaLineRatePlus
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2BatApproximate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_uint8_t nNextProfile,
   DSL_G997_NSCData8_t *pBat,
   DSL_G997_NSCData8_t *pDestBat
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3SwitchTo8Check
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3_17_30
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3_12_30
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3_12_17
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain
);

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3_8_XX
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nTargetProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain
);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

DSL_LOCAL DSL_void_t DSL_AVX_OnDeltInventoryAvailable
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_void_t DSL_AVX_OnFeStatusAvailable
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

#ifdef DSL_OHC_QUEUE
DSL_LOCAL DSL_Error_t DSL_AVX_OnOhcStatusEvtGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtOhcStatusGet_t *pStatus
);

DSL_LOCAL DSL_Error_t DSL_AVX_OhcTransmitMessage
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint16_t nLength,
   AVX_CmdOhcTransmit_t *pCmd
);

DSL_LOCAL DSL_Error_t DSL_AVX_OhcContextGetMessage
(
   DSL_AVX_OhcContextInternal_t *pOhcContext,
   const DSL_uint16_t nLine,
   DSL_AVX_OhcMessage_t *pMsg,
   DSL_boolean_t removeMsg
);

DSL_LOCAL DSL_Error_t DSL_AVX_OhcTrySend
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_AVX_OhcMessage_t *pMsg
);

DSL_LOCAL DSL_Error_t DSL_AVX_OhcContextPushMessage
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint16_t nLength,
   const AVX_CmdOhcTransmit_t *pCmd,
   DSL_AVX_OhcCallback_t callback,
   DSL_void_t *data
);
#endif /* DSL_OHC_QUEUE */

#define DSL_AVX_SNR_WOVN_DATA_CLEAR(line) do { \
   memset(DSL_AVX_SNR_WOVN_REQUEST_DATA_GET(line), 0, sizeof(DSL_AVX_SnrWoVnUsRequest_t)); \
} while (0)

DSL_LOCAL DSL_Error_t DSL_AVX_SnrWoVnUsQueryRestartTimer
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_SnrWoVnUsQuery
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_SnrWoVnUsQueryNext
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnSnrWoVnUsStatusGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtSnrWoVnUsStatusGet_t *pEvt
);

#ifdef DSL_DELAYED_CALLBACK_ENABLED
DSL_LOCAL DSL_Error_t DSL_AVX_OnDelayedCallbackEvent
(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   DSL_ulong_t nTimeoutID
);
#endif

#if (DSL_FAILURE_PRIORITIZATION > 0)
DSL_LOCAL DSL_void_t DSL_AVX_FailureEventRaiseCallback
(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   DSL_FailureMask_t nFailureMask
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnFailureEvent
(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   DSL_ulong_t nTimeoutID
);

DSL_LOCAL DSL_Error_t DSL_AVX_FailureEventReset
(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   DSL_FailureMask_t nFailureMask
);
#endif

DSL_LOCAL DSL_Error_t DSL_AVX_PowerSavingTimerStart
(
   DSL_Context_t *pContext,
   DSL_uint16_t nTriggerLine,
   DSL_boolean_t bEnable
);

DSL_LOCAL DSL_Error_t DSL_AVX_XtseStatusGet
(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnSoftRecoveryTrigger
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_FailReason_t const *pFailReason
);

DSL_LOCAL DSL_Error_t DSL_AVX_HandleDefferedAction
(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine);
   
DSL_LOCAL DSL_Error_t DSL_AVX_OnMemoryWatchdogEvent
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtMemoryWatchdog_t const *pAck
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnIdle
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnRtxOMsg1RMsg2
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtRtxOmsg1Rmsg2InfoGet_t *pEvt
);

DSL_LOCAL DSL_Error_t DSL_AVX_OnOpmsInfoGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtOpmsInfoGet_t *pEvt
);

DSL_LOCAL DSL_Error_t DSL_AVX_HandleSoftRecoveryEvent
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AVX_SoftRecoveryParams_t *pData,
   const DSL_boolean_t bNonIntrusive);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_VdslBackup
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_VdslDisable
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

DSL_LOCAL DSL_Error_t DSL_AVX_VdslRestore
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
);

//Ani
typedef enum {
  DSL_PPTP_ETH_UNI_UNKNOWN
  DSL_PPTP_ETH_UNI_DOWN,
  DSL_PPTP_ETH_UNI_UP 
} DSL_PPTP_ETH_UNI_State_t;

DSL_LOCAL DSL_Error_t DSL_AVX_HandleChangeEthPptpUni
(
   const DSL_uint16_t nLine, 
   const DSL_PPTP_ETH_UNI_State_t nState
);
//Ani
#endif /* #if (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
   
/***************************************************************
 *                Function Definition                          *
 ***************************************************************/
 
/**
   The AVINAX Control thread will receive all answers and
   autonomous messages. After decoding this information
   will be dispatched to the
   - status data base
   - user application
   - performance managment entity

   \param arg1 pointer to DSL libarary context
   \param arg2 lower 16 bit equals to the start line number, higher 16 bit
               equals to the end line number
   \return
   - DSL_Success Thread shutdown in normal way
   - DSL_Error Thread aborted because of error
*/
DSL_int_t DSL_AVX_ControlThread(
   DSL_Thread_Params_t *pThrParams)
{
   DSL_fd_set_t act_fds, rd_fds;  /* File descr. sets for use with select()*/
   DSL_int_t sretval, num_open_fds = 0, fd;
   DSL_uint16_t max_line =
      DSL_MIN((DSL_uint16_t)((pThrParams->nArg2 >> 16) & 0xFFFF), DSL_MAX_LINE_NUMBER);
   DSL_uint16_t start_line =
      DSL_MIN((DSL_uint16_t)(pThrParams->nArg2 & 0xFFFF), DSL_MAX_LINE_NUMBER);
   DSL_uint16_t nLine, nDevice = 0;
   DSL_Context_t *pContext = (DSL_Context_t *)pThrParams->nArg1;
   DSL_int_t nEventType = 0;
   DSL_ulong_t nTimeoutID = 0;

   DSL_boolean_t        bSupvEnabled         = DSL_TRUE;
   DSL_boolean_t        bSupvPhyDevPluggedIn = DSL_TRUE;
#ifdef DSL_OHC_QUEUE
   DSL_AVX_OhcContextInternal_t *pOhcContext = DSL_AVX_OHC_CONTEXT(pContext);
   DSL_AVX_OhcMessageQueue_t *pMsgQueue;
   DSL_AVX_OhcMessage_t *pMsg;
#endif /* DSL_OHC_QUEUE */
   DSL_long_t nTimeDif = 0;
   static const DSL_uint8_t nChannel = 0;
   
   DSL_CHECK_CTX_POINTER(pContext);
   DSL_GET_DEVICE_NUMBER(start_line, nDevice);

#if DSL_DEV_DELAY_START_OF_CONTROL_THREAD > 0
   /* delay the start of control threads */
   DSL_Sleep(nDevice);
#endif

   DSL_DEBUG_NOLINE(DSL_DBG_MSG, (pContext, "DSL: AVINAX control thread started" DSL_CRLF ));
   DSL_DEBUG_NOLINE(DSL_DBG_MSG, (pContext, "DSL: supervision of lines %d to %d" DSL_CRLF , start_line, max_line-1));

   memset(&act_fds, 0, sizeof(act_fds)); /* Reset the set of file descr. */

   /* start for each device one control thread */
   THREAD_ALIVE_MASK_SET(DSL_THREAD_CT_FIRST + nDevice);
   /* set the heartbeat flag for this thread */
   THREAD_ALIVE_SET(DSL_THREAD_CT_FIRST + nDevice);

   /* register the device descriptors */
   for (nLine = start_line; nLine < max_line; nLine++)
   {
      fd = pContext->DeviceContext.fd_nfc[nLine];
      if (fd < 0)
      {
         continue;
      }

      if(fd > num_open_fds)
      {
         num_open_fds = fd;
      }
      DSL_FD_SET(fd, &act_fds);
   }

   num_open_fds++;

   /*
    * Set line-failure supervision configuration for each line;
    */

   DSL_DEBUG_NOLINE(DSL_DBG_MSG, (pContext, "DSL: starting supervision" DSL_CRLF ));

   for (nLine = start_line; nLine < max_line; nLine++)
   {
      if (pContext->DeviceContext.LineFlags[nLine].bCallOnModemReady == DSL_TRUE)
      {
         DSL_AVX_OnModemReady(pContext, nLine);
         pContext->DeviceContext.LineFlags[nLine].bCallOnModemReady = DSL_FALSE;
      }
   }

   for(;;)
   {
      if ( (pContext->bRun == DSL_FALSE) ||
           (pThrParams->bShutDown == DSL_TRUE) )
      {
         break;
      }

      /* set the heartbeat flag for this thread */
      THREAD_ALIVE_SET(DSL_THREAD_CT_FIRST + nDevice);

      sretval = DSL_DeviceSelect(num_open_fds, &act_fds, &rd_fds, DSL_DEV_TIMEOUT_SELECT);
      if (sretval<0)
         DSL_DEBUG_NOLINE(DSL_DBG_ERR,(pContext, "DSL[%d..%d]: Error in select %s " DSL_CRLF,
                 start_line, max_line-1, strerror(errno)));

      /* Check the memory dump trigger before a recovery procedure */
      for (nLine = start_line; nLine < max_line; nLine++)
      {
         DSL_AVX_DBG_AutoMemoryDump(pContext, nLine);
      }

      if (bSupvEnabled == DSL_TRUE)
      {
         if (bSupvPhyDevPluggedIn == DSL_TRUE)
         {
            DSL_AVX_SoftRecoveryCheck(pContext, nDevice);
            DSL_AVX_RecoveryCheck(pContext, nDevice);
         }
      }
      else
      {
         DSL_AVX_SoftRecoveryCheck(pContext, nDevice);
         DSL_AVX_RecoveryCheck(pContext, nDevice);
      }

      nTimeDif =  DSL_MGetTime(0) - pContext->DeviceContext.nLastTimerEventProcessed[nDevice];
      /* events should be hanled with higher prio: process timers if select returned no events
         or at least  1 sec has expired from the last processing */
      if ((sretval == 0) || (nTimeDif >= 1000) || (nTimeDif < 0))
      {
         /* store new timestamp*/
         pContext->DeviceContext.nLastTimerEventProcessed[nDevice] = DSL_MGetTime(0);
         
         while(DSL_Timeout_GetNextActiveEvent( pContext,
                                               nDevice,
                                               &nLine,
                                               &nEventType,
                                               &nTimeoutID ) >= DSL_SUCCESS)
         {
            /* first clear the DB entry and handle the timer, then remove it.
               This is to avoid a new timer getting the same ID like a 
               currently processed one, which may then be removed again unintentionally */
            DSL_AVX_OnTimeoutEvent(pContext, nDevice, nLine, nEventType,
               nTimeoutID);
            DSL_Timeout_RemoveEvent(pContext, nDevice, nTimeoutID);
            /* DSL_Timeout_Debug_PrintTimeoutList(pContext, nDevice); */
         }

#ifdef DSL_OHC_QUEUE
         if (pOhcContext != DSL_NULL)
         {
            for (nLine = start_line; nLine < max_line; nLine++)
            {
               pMsgQueue = &pOhcContext->MsgQueue[nLine];

               /* check if the last sent message is waiting for OHS response too long */
               if (pMsgQueue->sended != DSL_NULL)
               {
                  DSL_time_t timeout;

                  /* check for timeout */
                  pMsg = pMsgQueue->sended;
                  timeout = DSL_MGetTime(pMsg->beginTime);

                  if (timeout > DSL_AVX_OHC_TIMEOUT)
                  {
                     AVX_OHC_MSG_MAKE_CALL(pContext, nLine, pMsg, AVX_OHC_TIMEOUT);
                     DSL_AVX_OhcContextGetMessage(pOhcContext, nLine, DSL_NULL, DSL_TRUE);
                  }
               }

               while (pMsgQueue->sended == DSL_NULL)
               {
                  pMsg = DSL_NULL;

                  if (DSL_SemaphoreGet(&(pOhcContext->QueueSemaphore[nLine]), DSL_AVX_OHC_QUEUE_SEM_TIMEOUT) == DSL_SUCCESS)
                  {
                     if (pMsgQueue->total && pMsgQueue->sended == DSL_NULL)
                     {
                        pMsg = &pMsgQueue->Queue[pMsgQueue->head];
                     }
                     pMsgQueue->sended = pMsg; /* mark message as already sent to avoid sending
                                               of new OHC message from other threads;
                                               the flag will be reset inside  DSL_AVX_OhcContextGetMessage
                                               if the sending  fails*/
                     DSL_SemaphoreSet(&(pOhcContext->QueueSemaphore[nLine]));
                  }

                  if (pMsg == DSL_NULL)
                  {
                     break;
                  }

                  if (! DSL_CHECK_LINE_SHOWTIME(nLine))
                  {
                     AVX_OHC_MSG_MAKE_CALL(pContext, nLine, pMsg, AVX_OHC_FAIL);
                     DSL_AVX_OhcContextGetMessage(pOhcContext, nLine, DSL_NULL, DSL_TRUE);
                  }
                  else if (DSL_AVX_OhcTrySend(pContext, nLine, pMsg) != DSL_SUCCESS)
                  {
                     DSL_AVX_OhcContextGetMessage(pOhcContext, nLine, DSL_NULL, DSL_TRUE);
                  }
               }
            }
         }
#endif /* DSL_OHC_QUEUE */
         /* FIXME: as long as ADSL FW does not indicate all states by event,
            do a state polling here */
         for (nLine = start_line; nLine < max_line; nLine++)
         {
            if (pContext->DeviceContext.LineFlags[nLine].bStatePolling
                && (DSL_LineStatusGet(pContext, nLine) == DSL_DEVSTATE_NORMAL_OPERATION))
            {
               DSL_AVX_CurrentStateGet(pContext, nLine);
            }
         }
      }

      for (nLine = start_line; nLine < max_line; nLine++)
      {
         if (pContext->DeviceContext.LineFlags[nLine].bCallOnModemReady == DSL_TRUE)
         {
            DSL_AVX_OnModemReady(pContext, nLine);
            pContext->DeviceContext.LineFlags[nLine].bCallOnModemReady = DSL_FALSE;
         }

         /* check for NFCs */
         fd = pContext->DeviceContext.fd_nfc[nLine];

         if (fd > 0)
         {
            if (DSL_LineEnabledGet(pContext, nLine) == DSL_FALSE)
            {
               /* skip disabled lines, but only if this was not wakeup */
               if (sretval==0)
                  continue;
            }
            /* to support polling mode check all lines */
            /* this descriptor got wakeup or timeout */
            if (DSL_FD_ISSET(fd, &rd_fds) || (sretval==0))
            {
               DSL_AVX_HandleMessage(pContext, nLine);
            }
         }
      } /* for(each nLine) */

      for (nLine = start_line; nLine < max_line; nLine++)
      {
         if ((pContext->DeviceContext.LineFlags[nLine].bDbgStreamComplete == DSL_TRUE) &&
             (pContext->pEventCallback != DSL_NULL))
         {
            DSL_boolean_t bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_DBG_STREAM_DUMP_COMPLETE));

            pContext->DeviceContext.LineFlags[nLine].bDbgStreamComplete = DSL_FALSE;
            if (bSemMask == DSL_FALSE)
            {
               (void)(pContext->pEventCallback)( pContext,
                                              nLine,
                                              DSL_CHANNEL_NA,
                                              DSL_ACCESSDIR_NA,
                                              DSL_ATUDIR_NA,
                                              DSL_CBS_DBG_STREAM_DUMP_COMPLETE,
                                              DSL_NULL );
            }

         }
      }
   } /* while */
#ifdef DSL_OHC_QUEUE
   if (pOhcContext != DSL_NULL)
   {
      for (nLine = start_line; nLine < max_line; nLine++)
      {
         pMsgQueue = &pOhcContext->MsgQueue[nLine];

         if (pMsgQueue->sended != DSL_NULL)
         {
            pMsg = pMsgQueue->sended;

            if (pMsg->CallbackFunction != DSL_NULL)
            {
               AVX_EvtOhcStatusGet_t sEvt = { AVX_OHC_FAIL };

               pMsg->CallbackFunction(pContext, nLine, &sEvt, pMsg->CallbackData);
            }
         }
      }
   }
#endif /* DSL_OHC_QUEUE */

#ifdef DSL_DELAYED_CALLBACK_ENABLED
   if (DSL_SemaphoreGet(&pContext->DelayedCallbackSemaphore, 0xFFFFFFFF) == DSL_SUCCESS)
   {
      DSL_AVX_DelayedCallback_t *pDelayedCallbackPrev;
      DSL_AVX_DelayedCallback_t *pDelayedCallback;

      pDelayedCallback = pContext->pDelayedCallback;
      pDelayedCallbackPrev = DSL_NULL;

      while (pDelayedCallback != DSL_NULL)
      {
         DSL_AVX_DelayedCallback_t *pDelayedCallbackNext = pDelayedCallback->pNextCallback;

         nLine = pDelayedCallback->nLine;
         if (start_line <= nLine && nLine < max_line)
         {
            if (pDelayedCallbackPrev == DSL_NULL)
            {
               pContext->pDelayedCallback = pDelayedCallback->pNextCallback;
            }
            else
            {
               pDelayedCallbackPrev->pNextCallback = pDelayedCallback->pNextCallback;
            }

            DSL_Timeout_RemoveEvent(pContext, nDevice, pDelayedCallback->nTimeoutID);
            DSL_Free(pDelayedCallback);
         }
         else
         {
            pDelayedCallbackPrev = pDelayedCallback;
         }

         pDelayedCallback = pDelayedCallbackNext;
      }

      DSL_SemaphoreSet(&pContext->DelayedCallbackSemaphore);
   }
#endif

   DSL_DEBUG_NOLINE(DSL_DBG_MSG,(pContext, "DSL: AVINAX control thread finished" DSL_CRLF ));

   return DSL_SUCCESS;
}


/**
   This routine handles the messages received by the
   AVINAX control thread.

   \param pContext DSL library context
   \param line index of selected line

   \return
   - DSL_Success Message could be handled.
   - DSL_Error No message handling were done.
*/
DSL_LOCAL DSL_Error_t DSL_AVX_HandleMessage(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   union
   {
      DSL_uint8_t p8[512];
      DSL_uint16_t p16[256];
   } buf;
   IOCTL_MEI3_LINE_message_t sMsg;
   IOCTL_MEI3_LINE_message_t *pMsg = &sMsg;
   IOCTL_MEI3_exchange_t   sEx;
   DSL_Error_t  ret = DSL_SUCCESS;
   DSL_Error_t  errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;
   DSL_uint32_t nEvtIgnoreMask;
   DSL_FctWaiting_t *pFctWait = DSL_NULL;
   DSL_FctWaitingGet(pContext, nLine, &pFctWait);

   sMsg.paylSize_byte = sizeof(buf);

   sMsg.pPayload = &buf.p16[0];
   sEx.pData = &sMsg;
   sEx.nLength = sizeof(sMsg);

   /* check for received NFCs */
   ret = DSL_AVX_ChReadMessage(pContext, nLine, &sEx);

   /* return if nothing received */
   if (ret == DSL_ERROR)
      return errorCode;

   DSL_AVX_DumpMessage(pContext, "nfc", nLine, pMsg->msgId, &buf.p8[0],
      (DSL_uint16_t)pMsg->paylSize_byte, pMsg->offset );

#if (defined(ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_) && (ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_ == 1))
   /* the current driver version supports driver autonomious messages */
   if (pMsg->msgCtrl != AVINAX_MSG_CTRL_MODEM_MSG)
   {
      /* driver message received */
      DSL_AVX_HandleDriverMessage(pContext, nLine, pMsg);
      return DSL_SUCCESS;
   }
#endif

   DSL_UINT32_INC(DSL_DBS_STATISTICS_FW_MESSAGE_RX);

   nEvtIgnoreMask = DSL_UINT32_GET(DSL_DBL_MFS_DBG_IGNORE_EVENT_MASK);
   if (nEvtIgnoreMask == (DSL_uint32_t)DSL_DBG_EVTMASK_ALL)
   {
      DSL_DEBUG( DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_HandleMessage - Msg 0x%X ignored " DSL_CRLF ,
         nLine, pMsg->msgId));
      return DSL_SUCCESS;
   }
   
   /* now decoding the messages within the buffer ... */
   switch(pMsg->msgId)
   {
      /*
      Handle autonomous messages from here on.
      EVT and ALM arise completely autonomous,
      NFCs follow an earlier CMD/ACK sequence.
      For the latter a blocking function call
      might have to be released.
      */

   case AVX_EVT_MODEM_FSM_STATE_GET:
      DSL_UINT8_SET(DSL_DBL_MODEM_FSM_STATE_GET, DSL_TRUE);
      errorCode = DSL_AVX_OnModemFsmStateGet(pContext, nLine, (AVX_AckModemFsmStateGet_t*)&buf.p16[0]);
      DSL_UINT8_SET(DSL_DBL_MODEM_FSM_STATE_GET, DSL_FALSE);
      DSL_UINT8_SET(DSL_DBL_LD_REQUESTED, DSL_FALSE);
      break;

   case AVX_EVT_OLR_US_EVENT_GET:
      errorCode = DSL_AVX_OnOlrEvtGet(pContext, nLine, DSL_UPSTREAM, &buf.p8[0]);
      break;

   case AVX_EVT_OLR_DS_EVENT_GET:
      errorCode = DSL_AVX_OnOlrEvtGet(pContext, nLine, DSL_DOWNSTREAM, &buf.p8[0]);
      break;

   /* check for ALM_ModemFSM_FailReasonGet and
      case EVT_ModemFSM_FailReasonGet:
      both have the same ID */
   case AVX_EVT_MODEM_FSM_FAIL_REASON_GET:
      errorCode = DSL_AVX_OnFailReasonGet(pContext, nLine,
                     (AVX_AckModemFsmFailReasonGet_t *)&buf.p8[0]);
      break;

   case AVX_EVT_LINE_FAILURE_NE_GET:
      errorCode = DSL_AVX_OnLineFailureNeGet(pContext, nLine,
                     (AVX_EvtLineFailureNeGet_t *)&buf.p8[0]);
      break;

   case AVX_EVT_LINE_FAILURE_FE_GET:
      errorCode = DSL_AVX_OnLineFailureFeGet(pContext, nLine,
                     (AVX_EvtLineFailureFeGet_t *)&buf.p8[0]);
      break;

   case AVX_EVT_DATA_PATH_FAILURE_NE_GET:
      errorCode = DSL_AVX_OnDataPathFailuresNeGet(pContext, nLine,
                     (AVX_EvtDataPathFailureNeGet_t *) &buf.p8[0]);
      break;

   case AVX_EVT_DATA_PATH_FAILURE_FE_GET:
      errorCode = DSL_AVX_OnDataPathFailuresFeGet(pContext, nLine,
                     (AVX_EvtDataPathFailureFeGet_t *) &buf.p8[0]);
      break;

#ifdef DSL_PM_FW_THRESHOLD_CHECKING
   case AVX_EVT_TR1_LINE_COUNT_THRESH_HIT:
      errorCode = DSL_AVX_OnTr1LineCountThreshHit(pContext, nLine,
                     (AVX_EvtTr1LineCountThreshHit_t *) &buf.p8[0]);
      break;
   case AVX_EVT_TR1_TC_COUNT_THRESH_HIT:
      errorCode = DSL_AVX_OnTr1TcCountThreshHit(pContext, nLine,
                     (AVX_EvtTr1TcCountThreshHit_t *) &buf.p8[0]);
      break;
   case AVX_EVT_TR1_CHANNEL_COUNT_THRESH_HIT:
      errorCode = DSL_AVX_OnTr1ChCountThreshHit(pContext, nLine,
                     (AVX_AckTr1ChannelCountThreshHit_t *) &buf.p8[0]);
      break;
#endif

   case AVX_EVT_TR1_EXPIRY:
      errorCode = DSL_AVX_OnPerformanceCounters(  pContext, nLine, &buf.p16[0]);
      break;

   case AVX_EVT_OHC_STATUS_GET:
#ifdef DSL_OHC_QUEUE
      errorCode = DSL_AVX_OnOhcStatusEvtGet(pContext, nLine,
                     (AVX_EvtOhcStatusGet_t*)&buf.p8[0]);
#else
      /* FIXME: also other OHC responses need to be handled here */
      errorCode = DSL_AVX_DeltFeUpdate(pContext, nLine,
                     (AVX_EvtOhcStatusGet_t*)&buf.p8[0]);
#endif
      break;

#ifdef INCLUDE_DSL_API_AVINAX_MELT
   case AVX_EVT_MELT_STATUS_GET:
      MELT_EventHandle(pContext->pMELT_Ctx, nLine, pMsg->msgId,
         (DSL_uint16_t)pMsg->paylSize_byte, &buf.p8[0]);
      break;
#endif

   case AVX_EVT_MODEM_READY:
      if (pMsg->paylSize_byte/*length*/ >= 2)
      {
         if (buf.p16[0] /* error code */ == 0)
         {
            errorCode = DSL_AVX_OnModemReady(pContext, nLine);
         }
         else
         {
            /* modem ready reports error, check if trigger for recovery is on */
            if (DSL_UINT32_GET(DSL_DBI_AUTORECOVER_TRIGGERMASK) & DSL_AUTORECOVER_TRIGGER_MODEM_READY_ERROR)
            {
               DSL_uint16_t nDev;

               DSL_DEBUG( DSL_DBG_ERR, (pContext,
                  "DSL[%02d]: AVX_EVT_MODEM_READY - recovery because of FW error code 0x%04X " DSL_CRLF ,
                  nLine, buf.p16[0]));

               DSL_GET_DEVICE_NUMBER(nLine, nDev);

               DSL_DeviceStatusSet(pContext, nDev, DSL_DEVSTATE_RECOVERY_REQUIRED);
               DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_REQUIRED);
               DSL_DBG_ExceptionHistoryAddTrigger(pContext, nLine, DSL_AUTORECOVER_TRIGGER_MODEM_READY_ERROR);
               DSL_UINT8_SET(DSL_DBDS_FAIL_RECOVERY_REQUIRED, DSL_TRUE);
            }
            else
            {
               DSL_DEBUG( DSL_DBG_ERR, (pContext,
                  "DSL[%02d]: AVX_EVT_MODEM_READY - FW error code 0x%04X, but trigger not enabled" DSL_CRLF ,
                  nLine, buf.p16[0]));
            }
         }
      }
      break;

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   case AVX_EVT_APS_LINE_STATUS_INIT_GET:
      errorCode = DSL_AVX_OnApsLineStatusInitGet(pContext, nLine,
                     (AVX_EvtApsLineStatusInitGet_t *) &buf.p8[0]);
      break;
#endif

   case AVX_EVT_TEST_SRAM_TEST:
#if defined(INCLUDE_DSL_BOARD_PRODUCTION_TEST)
      {
         AVX_EvtTestSramTest_t *pAck;
         DSL_uint16_t nDev = 0;

         DSL_GET_DEVICE_NUMBER(nLine, nDev);

         pAck = (AVX_EvtTestSramTest_t*)&buf.p8[0];

         if (pAck->Result == AVX_VNX_FAIL)
         {
            DSL_UINT32_SET(DSL_DBS_BPT_DFE_MEMORY_TEST_RESULT, DSL_AVX_PARA32_GET(pAck->NumError));
            DSL_UINT32_SET(DSL_DBS_BPT_DFE_MEMORY_TEST_FAIL_ADDR, DSL_AVX_PARA32_GET(pAck->FailAddr));
         }

         pContext->DeviceContext.bMemoryTestPending[nDev] = DSL_FALSE;

         if (DSL_PM_CONTEXT(pContext) != DSL_NULL)
         {
            DSL_PM_CONTEXT(pContext)->bPaused = DSL_FALSE;
         }

         /* Notify test completion */
         if (pContext->pEventCallback != DSL_NULL)
         {
            DSL_CB_DATA_DfeMemoryTest_t dfeMemoryTest;
            DSL_boolean_t bSemMask = DSL_FALSE;

            bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_BPT_MEM_TST));

            if (bSemMask == DSL_FALSE)
            {
               dfeMemoryTest.nNumberOfErrors = DSL_AVX_PARA32_GET(pAck->NumError);
               dfeMemoryTest.nAddress = DSL_AVX_PARA32_GET(pAck->FailAddr);
               dfeMemoryTest.errorCode = pAck->Result;

               DSL_DEBUG_NOLINE( DSL_DBG_MSG, (pContext, 
                  "DSL_AVX_BPT_DfeMemoryTestStart(): Notify test %d completion" DSL_CRLF, 
                  DSL_BPT_DFE_MEMORY_TEST ) );

               (void)(pContext->pEventCallback)( pContext,
                                           nLine,
                                           DSL_CHANNEL_NA,                    
                                           DSL_ACCESSDIR_NA,
                                           DSL_ATUDIR_NA,
                                           DSL_CBS_BPT_MEMORY_TEST_COMPLETE,
                                           (DSL_CB_DATA_Union_t *)&dfeMemoryTest );
            }
         }
      }
#endif /* defined(INCLUDE_DSL_BOARD_PRODUCTION_TEST) */
      break;

   case AVX_EVT_PSD_WARNING_GET:
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      errorCode = DSL_AVX_OnPsdWarningGet(pContext, nLine, (AVX_EvtPsdWarningGet_t *) &buf.p8[0]);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
      break;
   case AVX_EVT_PMSF_REQ_STATUS_GET:
      errorCode = DSL_AVX_OnPmsfReqStatusGet(pContext, nLine, (AVX_EvtPmsfReqStatusGet_t *) &buf.p8[0]);
      break;

   case AVX_EVT_SNR_WOVN_US_STATUS_GET:
      errorCode = DSL_AVX_OnSnrWoVnUsStatusGet(pContext, nLine, (AVX_EvtSnrWoVnUsStatusGet_t *) buf.p8);
      break;

   case AVX_EVT_DSM_STATUS_GET:
#if defined(INCLUDE_DSL_DSM) && (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      if (nEvtIgnoreMask & (DSL_uint32_t)DSL_DBG_EVTMASK_DSM_STATUS) 
      {
         DSL_DEBUG( DSL_DBG_WRN, (pContext,
            "DSL[%02d]: DSL_AVX_HandleMessage - Msg AVX_EVT_DSM_STATUS_GET 0x%X ignored " DSL_CRLF ,
            nLine, pMsg->msgId));
         break;
      }
      errorCode = DSL_AVX_OnDsmStatusGet(pContext, nLine, (AVX_EvtDsmStatusGet_t *) &buf.p8[0]);
#endif /* defined(INCLUDE_DSL_DSM) */
      break;

#if defined(INCLUDE_DSL_BOARD_PRODUCTION_TEST)
   case AVX_EVT_TEST_RX_CONTROL_SET:
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: EVT_TEST_RX_CONTROL_SET: %s" DSL_CRLF,
            nLine, ((AVX_EvtTestRxControlSet_t *) buf.p8)->Result ? "fail" : "ok"));

      if (pContext->DeviceContext.BptDataBuf[nLine].bWaiting)
      {                                     
         pContext->DeviceContext.BptDataBuf[nLine].bWaiting = DSL_FALSE;

         if (((AVX_EvtTestRxControlSet_t *) buf.p8)->Result == 0)
            pContext->DeviceContext.BptDataBuf[nLine].bResult = DSL_TRUE;
         else
            pContext->DeviceContext.BptDataBuf[nLine].bResult = DSL_FALSE;

         DSL_SemaphoreSet(&pContext->DeviceContext.BptDataBuf[nLine].ProtectBufSem);
      }
#if defined(INCLUDE_DSL_API_VINAX_R3)
      if ((DSL_SEMAPHORE_INIT_VALID(&pContext->DeviceContext.BptStateChangeSem[nLine])) && pContext->DeviceContext.bBptEvtWaiting[nLine])
      {
         DSL_SemaphoreSet(&pContext->DeviceContext.BptStateChangeSem[nLine]);
      }
#endif
      break;
#endif /* defined(INCLUDE_DSL_BOARD_PRODUCTION_TEST) */

   case AVX_EVT_MEMORY_WATCHDOG:
   case 0x33B4: /* watchdog ID of non FS5 FW */
      DSL_DBG_ExceptionHistoryAddTrigger(pContext, nLine, DSL_AUTORECOVER_TRIGGER_SOFT_RECOVERY);
      errorCode = DSL_AVX_OnMemoryWatchdogEvent(pContext, nLine, (AVX_EvtMemoryWatchdog_t *) &buf.p8[0]);
      break;

   case AVX_EVT_RTX_OMSG1RMSG2_INFO_GET:
      errorCode = DSL_AVX_OnRtxOMsg1RMsg2(pContext, nLine, (AVX_EvtRtxOmsg1Rmsg2InfoGet_t *) &buf.p8[0]);
      break;
   case AVX_EVT_OPMS_INFO_GET:
      errorCode = DSL_AVX_OnOpmsInfoGet(pContext, nLine, (AVX_EvtOpmsInfoGet_t *) &buf.p8[0]);
      break;
   case 0xDEAD:
      errorCode = DSL_AVX_OnDead(pContext, nLine);
      break;

   default:
      DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: MsgID %x" DSL_CRLF , nLine,
         pMsg->msgId));
      break;
   }

   return DSL_SUCCESS;
}
#ifdef DSL_OHC_QUEUE
DSL_void_t DSL_AVX_OhcContextInit(DSL_Context_t *pContext)
{
   DSL_AVX_OhcContextInternal_t *pOhcContext = DSL_AVX_OHC_CONTEXT(pContext);
   DSL_AVX_OhcMessageQueue_t *pMsgQueue;
   DSL_uint16_t nLine;

   for (nLine = 0; nLine < DSL_MAX_LINE_NUMBER; nLine++)
   {
      /* Initialize the semaphore to wait for direct answer from the device */
      if (!DSL_SEMAPHORE_INIT_VALID(&(pOhcContext->QueueSemaphore[nLine])))
      {
         if ( DSL_SemaphoreCreate(&(pOhcContext->QueueSemaphore[nLine]), "OhcMessageQueue", -1) != DSL_SUCCESS )
         {
            return;
         }
      }

      pMsgQueue = &(pOhcContext->MsgQueue[nLine]);

      pMsgQueue->head = 0;
      pMsgQueue->total = 0;
      pMsgQueue->sended = DSL_NULL;
   }
}

DSL_void_t DSL_AVX_OhcContextDestroy(DSL_Context_t *pContext)
{
   DSL_AVX_OhcContextInternal_t *pOhcContext = DSL_AVX_OHC_CONTEXT(pContext);
   DSL_AVX_OhcMessageQueue_t *pMsgQueue;
   DSL_uint16_t nLine;

   if( pOhcContext == DSL_NULL)
   {
      return;
   }

   for (nLine = 0; nLine < DSL_MAX_LINE_NUMBER; nLine++)
   {
      DSL_SemaphoreDelete(&(pOhcContext->QueueSemaphore[nLine]));

      pMsgQueue = &(pOhcContext->MsgQueue[nLine]);

      if (DSL_SEMAPHORE_INIT_VALID(&pMsgQueue->SyncSemaphore))
      {
         DSL_SemaphoreDelete(&pMsgQueue->SyncSemaphore);
      }
   }
}

DSL_LOCAL DSL_Error_t DSL_AVX_OhcContextGetMessage(
   DSL_AVX_OhcContextInternal_t *pOhcContext,
   const DSL_uint16_t nLine,
   DSL_AVX_OhcMessage_t *pMsg,
   DSL_boolean_t removeMsg)
{
   DSL_AVX_OhcMessageQueue_t *pMsgQueue;

   pMsgQueue = &pOhcContext->MsgQueue[nLine];

   if (DSL_SemaphoreGet(&(pOhcContext->QueueSemaphore[nLine]), DSL_AVX_OHC_QUEUE_SEM_TIMEOUT) != DSL_SUCCESS)
   {
      return DSL_ERROR;
   }

   if (pMsgQueue->total == 0)
   {
      DSL_SemaphoreSet(&(pOhcContext->QueueSemaphore[nLine]));
      return DSL_ERROR;
   }

   if (pMsg != DSL_NULL)
   {
      *pMsg = pMsgQueue->Queue[pMsgQueue->head];
   }

   if (removeMsg == DSL_TRUE)
   {
      pMsgQueue->head++;

      if (pMsgQueue->head >= DSL_AVX_OHC_MESSAGE_QUEUE_SIZE)
      {
         pMsgQueue->head = 0;
      }

      pMsgQueue->total--;
      pMsgQueue->sended = DSL_NULL;
   }

   DSL_SemaphoreSet(&(pOhcContext->QueueSemaphore[nLine]));

   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OhcTrySend(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_AVX_OhcMessage_t *pMsg)
{
   DSL_Error_t errorCode;

   errorCode = DSL_AVX_OhcTransmitMessage(pContext,
                  nLine, pMsg->nLength,
                  &pMsg->OhcCmd);

   if (errorCode == DSL_SUCCESS)
   {
      pMsg->beginTime = DSL_MGetTime(0);
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OhcContextPushMessage(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint16_t nLength,
   const AVX_CmdOhcTransmit_t *pCmd,
   DSL_AVX_OhcCallback_t callback,
   DSL_void_t *data)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_AVX_OhcContextInternal_t *pOhcContext = DSL_AVX_OHC_CONTEXT(pContext);
   DSL_AVX_OhcMessageQueue_t *pMsgQueue;
   DSL_AVX_OhcMessage_t *pMsg;
   DSL_uint_t n;
   DSL_boolean_t bSendNow = DSL_FALSE;

   pMsgQueue = &pOhcContext->MsgQueue[nLine];

   if (DSL_SemaphoreGet(&(pOhcContext->QueueSemaphore[nLine]), DSL_AVX_OHC_QUEUE_SEM_TIMEOUT) != DSL_SUCCESS)
   {
      return DSL_ERROR;
   }

   if (pMsgQueue->total >= DSL_AVX_OHC_MESSAGE_QUEUE_SIZE)
   {
      DSL_SemaphoreSet(&(pOhcContext->QueueSemaphore[nLine]));
      return DSL_ERROR;
   }

   n = (pMsgQueue->head + pMsgQueue->total) % DSL_AVX_OHC_MESSAGE_QUEUE_SIZE;

   pMsg = &pMsgQueue->Queue[n];
   pMsgQueue->total++;

   pMsg->nLength = nLength;
   pMsg->OhcCmd = *pCmd;
   pMsg->CallbackFunction = callback;
   pMsg->CallbackData = data;
   pMsg->beginTime = DSL_MGetTime(0);

   if (pMsgQueue->total == 1) /* this is the first msg in the queue, no others  pending*/
   {
      pMsgQueue->sended = pMsg; /* mark message as already sent to avoid sending
                                of new OHC message from other threads;
                                reset the flag if the sending  fails*/
      bSendNow = DSL_TRUE;
   }

   DSL_SemaphoreSet(&(pOhcContext->QueueSemaphore[nLine]));

   if (bSendNow)
   {
      if ((errorCode = DSL_AVX_OhcTrySend(pContext, nLine, pMsg)) != DSL_SUCCESS)
      {
         if (DSL_SemaphoreGet(&(pOhcContext->QueueSemaphore[nLine]), DSL_AVX_OHC_QUEUE_SEM_TIMEOUT) == DSL_SUCCESS)
         {
            pMsgQueue->sended = DSL_NULL;
            pMsgQueue->total--;

            DSL_SemaphoreSet(&(pOhcContext->QueueSemaphore[nLine]));
         }
      }
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OnOhcStatusEvtGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtOhcStatusGet_t *pEvt)
{
   DSL_AVX_OhcContextInternal_t *pOhcContext = DSL_AVX_OHC_CONTEXT(pContext);
   DSL_AVX_OhcMessageQueue_t *pMsgQueue;
   DSL_AVX_OhcCallback_t callback;
   DSL_AVX_OhcMessage_t sMsg;

   pMsgQueue = &pOhcContext->MsgQueue[nLine];

   DSL_DEBUG( DSL_DBG_LOCAL, (pContext,
      "DSL[%02d]: DSL_AVX_OnOhcStatusEvtGet" DSL_CRLF ,
      nLine));

   if (pMsgQueue->sended == DSL_NULL)
   {
      DSL_DEBUG( DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OnOhcStatusEvtGet: received event, "
         "but no message was sent" DSL_CRLF , nLine));
      return DSL_ERROR;
   }

   if (DSL_AVX_OhcContextGetMessage(pOhcContext, nLine, &sMsg, DSL_TRUE) != DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OhcContextGetMessage failed" DSL_CRLF ,
         nLine));

      return DSL_ERROR;
   }

   callback = sMsg.CallbackFunction;
   if (callback != DSL_NULL)
   {
      /* Attention: don't issue the OHC callback with  QueueSemaphore busy */
      callback(pContext, nLine, pEvt, sMsg.CallbackData);
   }

   if (DSL_SemaphoreGet(&(pOhcContext->QueueSemaphore[nLine]), DSL_AVX_OHC_QUEUE_SEM_TIMEOUT) == DSL_SUCCESS)
   {
      DSL_AVX_OhcMessage_t *pMsg = DSL_NULL;

      if (pMsgQueue->total && pMsgQueue->sended == DSL_NULL)
      {
         pMsg = &pMsgQueue->Queue[pMsgQueue->head];
         pMsgQueue->sended = pMsg; /* mark message as already sent to avoid sending
                                   new OHC message from other threads;
                                   the flag will be reset inside  DSL_AVX_OhcContextGetMessage
                                   if the sending  fails*/
      }

      DSL_SemaphoreSet(&(pOhcContext->QueueSemaphore[nLine]));

      if (pMsg != DSL_NULL)
      {
         if (DSL_AVX_OhcTrySend(pContext, nLine, pMsg) != DSL_SUCCESS)
         {
            DSL_AVX_OhcContextGetMessage(pOhcContext, nLine, DSL_NULL, DSL_TRUE);
         }
      }
   }

   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OhcTransmitMessage(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint16_t nLength,
   AVX_CmdOhcTransmit_t *pCmd)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   const DSL_uint8_t nChannel = 0;

   if (DSL_INT8_GET(DSL_DBL_MFS_OHC_ENABLE) != 0)
   {
      DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
         "DSL[%02d]: DSL_AVX_OhcTransmitMessage" DSL_CRLF, nLine));

      nRet = DSL_AVX_SendMessage(pContext,
                  nLine, MSGID_EXT(AVX_CMD_OHC_TRANSMIT),
                  nLength, (DSL_uint8_t *) pCmd,
                  0, DSL_NULL);
   }
   else
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_OhcTransmitMessage skipped" DSL_CRLF, nLine));
   }

   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   return errorCode;
}

DSL_Error_t DSL_AVX_OhcRecvMessage(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint16_t nLength,
   AVX_OhcMsg_t *pAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   AVX_CmdOhcReceive_t sCmd;

   DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
      "DSL[%02d]: DSL_AVX_OhcRecvMessage" DSL_CRLF, nLine));

   memset(&sCmd, 0, sizeof(sCmd));
   sCmd.NumRead = nLength > 0 ? nLength : sizeof(*pAck);

   nRet = DSL_AVX_SendMessage(pContext,
                  nLine, AVX_CMD_OHC_RECEIVE,
                  sizeof(sCmd), (DSL_uint8_t *) &sCmd,
                  sizeof(*pAck), (DSL_uint8_t *) pAck);

   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   return errorCode;
}

DSL_Error_t DSL_AVX_OhcSendAsyncMessage(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint16_t nLength,
   const AVX_CmdOhcTransmit_t *pMsg,
   DSL_AVX_OhcCallback_t callback,
   DSL_void_t *callbackData)
{
   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
      "DSL[%02d]: DSL_AVX_OhcSendAsyncMessage" DSL_CRLF, nLine));

   if (DSL_AVX_OHC_CONTEXT(pContext) == DSL_NULL)
   {
      DSL_DEBUG( DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OhcSendAsyncMessage: OhcContext is null" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   if (! DSL_CHECK_LINE_SHOWTIME(nLine))
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: Function is only available if line is in showtime."
         DSL_CRLF, nLine));

      return DSL_ERROR;
   }

   errorCode = DSL_AVX_OhcContextPushMessage(
                  pContext,
                  nLine, nLength,
                  pMsg, callback, callbackData);

   return errorCode;
}

DSL_LOCAL void DSL_AVX_OhcSendMessageCallback(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtOhcStatusGet_t *pEvt,
   AVX_CallbackData_t *pCbData)
{
   DSL_Error_t errorCode;

   pCbData->status = pEvt->Status;

   if (pEvt->Status == AVX_OHC_SUCCEED)
   {
      errorCode = DSL_AVX_OhcRecvMessage(pContext, nLine, sizeof(pCbData->ohcReceive), &pCbData->ohcReceive);

      if (errorCode != DSL_SUCCESS)
      {
         pCbData->status = AVX_OHC_FAIL;
      }
   }

   DSL_SemaphoreSet(&DSL_AVX_OHC_CONTEXT(pContext)->MsgQueue[nLine].SyncSemaphore);
}

DSL_Error_t DSL_AVX_OhcSendMessage(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint16_t nLength,
   const AVX_CmdOhcTransmit_t *pMsg,
   AVX_OhcMsg_t *pAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   AVX_CallbackData_t data;
   DSL_AVX_OhcContextInternal_t *pOhcContext = DSL_AVX_OHC_CONTEXT(pContext);
   DSL_AVX_OhcMessageQueue_t *pMsgQueue;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_OhcSendMessage" DSL_CRLF, nLine));

   if (pOhcContext == DSL_NULL)
   {
      DSL_DEBUG( DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OhcSendMessage: OhcContext is null" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   pMsgQueue = &pOhcContext->MsgQueue[nLine];

   if (! DSL_SEMAPHORE_INIT_VALID(&pMsgQueue->SyncSemaphore))
   {
      if (DSL_SemaphoreCreate(&pMsgQueue->SyncSemaphore, "OhcSync", -1) != DSL_SUCCESS)
      {
         DSL_DEBUG( DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_OhcSendMessage: failed to create OhcSync semaphore" DSL_CRLF, nLine));
         return DSL_ERROR;
      }
   }

   if (DSL_SemaphoreGet(&pMsgQueue->SyncSemaphore, 0xFFFFFFFF) != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OhcSendMessage: failed to get SyncSemaphore" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   data.status = AVX_OHC_FAIL;
   errorCode = DSL_AVX_OhcSendAsyncMessage(pContext,
                  nLine, nLength, pMsg,
                  (DSL_AVX_OhcCallback_t) DSL_AVX_OhcSendMessageCallback,
                  (DSL_void_t *) &data);

   if (errorCode != DSL_SUCCESS)
   {
      DSL_SemaphoreSet(&pMsgQueue->SyncSemaphore);
      return errorCode;
   }

   if (DSL_SemaphoreGet(&pMsgQueue->SyncSemaphore, 0xFFFFFFFF) != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OhcSendMessage: failed to get SyncSemaphore" DSL_CRLF, nLine));
      errorCode = DSL_ERROR;
   }
   else
   {
      if (data.status != AVX_OHC_SUCCEED)
      {
         errorCode = DSL_ERROR;
      }
      else
      {
         DSL_uint8_t sendCmd = pMsg->DesReqType & 0xff;
         DSL_uint8_t recvCmd = data.ohcReceive.OhcData[0] & 0xff;

         if (sendCmd == recvCmd)
         {
            memcpy(pAck, &data.ohcReceive, sizeof(data.ohcReceive));
         }
         else
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_OhcSendMessage: sent %x, received %x"
               DSL_CRLF, nLine, sendCmd, recvCmd));

            errorCode = DSL_ERROR;
         }
      }
   }

   DSL_SemaphoreSet(&pMsgQueue->SyncSemaphore);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_OhcSendMessage" DSL_CRLF, nLine));

   return errorCode;
}
#endif /* DSL_OHC_QUEUE */

DSL_LOCAL DSL_Error_t DSL_AVX_SnrWoVnUsQueryRestartTimer(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS;

   errorCode = DSL_TimerDB_Restart(pContext, nLine,
                                   DSL_DBS_NE_SNR_WOVN_UPDATE_TIMEOUT_ID,
                                   DSL_TIMEOUTEVENT_NE_SNR_WOVN_UPDATE,
                                   10 * DSL_TIMEOUT_FACTOR);

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_SnrWoVnUsQuery(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static DSL_uint8_t nChannel = 0;

   DSL_AVX_SnrWoVnUsRequest_t *pRequest = DSL_AVX_SNR_WOVN_REQUEST_DATA_GET(nLine);
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_AVX_FwMode_t nDslMode = FWMODE_ADSL;
   DSL_uint16_t nToneDivisor = 1;

   DSL_DEBUG(DSL_DBG_LOCAL, (pContext, "DSL[%02d]: DSL_AVX_SnrWoVnUsQuery" DSL_CRLF, nLine));

   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      nDslMode = FWMODE_VDSL;

      if (DSL_UINT8_GET(DSL_DBS_PROFILES) == DSL_G997_PROFILES_30A)
      {
         /* for 30A the tones are defined in 4kHz steps,
            but here we need the numbers in the 8kHz spacing! */
         nToneDivisor = 2;
      }
   }

   pRequest->nCurrentBand = 0;
   pRequest->nCurrentTone = 0;
   pRequest->nTonesRequested = 0;

   pRequest->nSnrTemp.nNumData = 0;
   memset(pRequest->nSnrTemp.nNSCData, 0xFF, sizeof(pRequest->nSnrTemp.nNSCData));

   errorCode = DSL_AVX_CurrentBandListGet(pContext, nLine, DSL_UPSTREAM, &pRequest->nBandList);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_CurrentBandListGet failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (nDslMode == FWMODE_ADSL)
   {
      pRequest->nSnrTemp.nNumData = pRequest->nBandList.nBand[0].nLastToneIndex + 1;
   }
   else
   {
      pRequest->nSnrTemp.nNumData = DSL_MAX_NSC;
   }

   pRequest->nCurrentTone = pRequest->nBandList.nBand[pRequest->nCurrentBand].nFirstToneIndex / nToneDivisor;

   errorCode = DSL_AVX_SnrWoVnUsQueryNext(pContext, nLine);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_SnrWoVnUsQueryNext failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_SnrWoVnUsQueryNext(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static DSL_uint8_t nChannel = 0;

   DSL_AVX_SnrWoVnUsRequest_t *pRequest = DSL_AVX_SNR_WOVN_REQUEST_DATA_GET(nLine);
   AVX_CmdRxSnrWoVnUsRequest_t sCmd;

   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint16_t nToneDivisor = 1;
   DSL_uint16_t nFirstTone = 0, nLastTone = 0;
   DSL_uint16_t nTonesLeft = 0;
   DSL_uint16_t nTonesMax = 0;
   DSL_uint16_t nTonesCurrent = 0;

   DSL_DEBUG(DSL_DBG_LOCAL, (pContext, "DSL[%02d]: DSL_AVX_SnrWoVnUsQueryNext" DSL_CRLF, nLine));

   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      if (DSL_UINT8_GET(DSL_DBS_PROFILES) == DSL_G997_PROFILES_30A)
      {
         /* for 30A the tones are defined in 4kHz steps,
            but here we need the numbers in the 8kHz spacing! */
         nToneDivisor = 2;
      }
   }

   nFirstTone = pRequest->nCurrentTone;
   nLastTone = (pRequest->nBandList.nBand[pRequest->nCurrentBand].nLastToneIndex + nToneDivisor - 1) / nToneDivisor;

   if (nFirstTone > nLastTone)
   {
      pRequest->nCurrentBand++;
      if (pRequest->nCurrentBand >= pRequest->nBandList.nNumData)
      {
         DSL_DEBUG(DSL_DBG_LOCAL, (pContext, "DSL[%02d]: DSL_AVX_SnrWoVnUsQueryNext complete" DSL_CRLF, nLine));

         memcpy(&pRequest->nSnrNSCData, &pRequest->nSnrTemp, sizeof(DSL_G997_NSCData8_t));

         return DSL_SUCCESS;
      }

      pRequest->nCurrentTone = pRequest->nBandList.nBand[pRequest->nCurrentBand].nFirstToneIndex / nToneDivisor;

      nFirstTone = pRequest->nCurrentTone;
      nLastTone = (pRequest->nBandList.nBand[pRequest->nCurrentBand].nLastToneIndex + nToneDivisor - 1) / nToneDivisor;
   }

   nTonesLeft = (nLastTone - nFirstTone) + 1;
   nTonesMax = DSL_ARRAY_LENGTH(((AVX_AckSnrWoVnUsReceive_t *) 0)->SnrWoVn);

   if (nTonesLeft > nTonesMax)
      nTonesCurrent = nTonesMax;
   else
      nTonesCurrent = nTonesLeft;

   DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
      "DSL[%02d]: DSL_AVX_SnrWoVnUsQueryNext: start = %d, count = %d" DSL_CRLF, nLine, nFirstTone, nTonesCurrent));

   sCmd.NumRead = nTonesCurrent * 2;
   sCmd.StartIndex = nFirstTone;
   errorCode = DSL_AVX_SendMessage(pContext,
                  nLine, MSGID_EXT(AVX_CMD_SNR_WOVN_US_REQUEST),
                  sizeof(sCmd), (DSL_uint8_t *) &sCmd,
                  0, DSL_NULL);

   if (errorCode != DSL_SUCCESS)
   {
      /* request may fail if showtime was left, don't escalate */
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_SnrWoVnUsQueryNext: CMD_SNR_WOVN_US_REQUEST failed: %d" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   pRequest->nTonesRequested = nTonesCurrent;

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OnSnrWoVnUsStatusGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtSnrWoVnUsStatusGet_t *pEvt)
{
   DSL_AVX_SnrWoVnUsRequest_t *pRequest = DSL_AVX_SNR_WOVN_REQUEST_DATA_GET(nLine);
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint16_t nTone = 0;

   AVX_CmdSnrWoVnUsReceive_t sCmd;
   AVX_AckSnrWoVnUsReceive_t sAck;

   DSL_DEBUG(DSL_DBG_LOCAL, (pContext, "DSL[%02d]: DSL_AVX_OnSnrWoVnUsStatusGet" DSL_CRLF, nLine));

   if (pEvt->Status == AVX_VNX_IN_PROGRESS)
   {
      DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
         "DSL[%02d]: DSL_AVX_OnSnrWoVnUsStatusGet: CMD_SNR_WOVN_US_REQUEST in progress" DSL_CRLF, nLine));
      return DSL_SUCCESS;
   }
   else if (pEvt->Status != AVX_VNX_OK)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OnSnrWoVnUsStatusGet: CMD_SNR_WOVN_US_REQUEST failed" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   if (pRequest->nTonesRequested == 0)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OnSnrWoVnUsStatusGet: nTonesRequested = 0" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   sCmd.NumRead = pRequest->nTonesRequested * 2;
   errorCode = DSL_AVX_SendMessage(pContext,
                  nLine, MSGID_EXT(AVX_CMD_SNR_WOVN_US_RECEIVE),
                  sizeof(sCmd), (DSL_uint8_t *) &sCmd,
                  sizeof(sAck), (DSL_uint8_t *) &sAck);

   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OnFineGainStatusGet: CMD_SNR_WOVN_US_RECEIVE failed" DSL_CRLF, nLine));
      return errorCode;
   }

   for (nTone = 0; nTone < pRequest->nTonesRequested; nTone++)
   {
      DSL_uint16_t val = sAck.SnrWoVn[nTone];
      DSL_uint8_t snr = 255;

      if (val != 0x8000 && val != 0xF800)
      {
         snr = (DSL_uint8_t)((DSL_AVX_GetDbFromQ88(val, 1) + 32) * 2 + 0.5);
      }

      pRequest->nSnrTemp.nNSCData[pRequest->nCurrentTone + nTone] = snr;
   }

   pRequest->nCurrentTone += pRequest->nTonesRequested;

   DSL_AVX_SnrWoVnUsQueryNext(pContext, nLine);

   return errorCode;
}

/**
   This function handles the AVINAX firmware message
   0xDEAD indicating a FW stuck.

   \param pContext  Pointer to dsl library context structure, [I]
   \param nLine     Specifies on which line the message was received, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnDead(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   const DSL_uint8_t nChannel = 0;
   DSL_uint32_t nTriggerMask;

   nTriggerMask = DSL_UINT32_GET(DSL_DBI_AUTORECOVER_TRIGGERMASK);

   DSL_DEBUG( DSL_DBG_ERR, (pContext,
      "DSL[%02d]: DSL_AVX_OnDead - Recovery requested by FW" DSL_CRLF ,
      nLine));

   if (nTriggerMask & DSL_AUTORECOVER_TRIGGER_FW_REQUEST)
   {
#if 0 /* Counter restore is not supported yet */
      /* remember the current counters to restore them after recovery */
      DSL_AVX_CountersBackup(pContext, nLine);
#endif
      DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_REQUIRED);
      DSL_DBG_ExceptionHistoryAddTrigger(pContext, nLine, DSL_AUTORECOVER_TRIGGER_FW_REQUEST);
   }

   return (errorCode);
}

/**
   This function handles the AVINAX firmware message
   \ref EVT_OLR_StateGet
   and processes the current status of the modem state-machine.

   \param pContext  Pointer to dsl library context structure, [I]
   \param nLine     Specifies on which line the message was received, [I]
   \param nDirection Upstream or Downstream, [I]
   \param pStateGet Pointer to received AVINAX firmware message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnOlrEvtGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t const *pMsg)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   AVX_EvtOlrDsEventGet_t *pEvt;
   DSL_uint32_t nBitMask = 0;
   DSL_pmDeviceType_t nDeviceType;
   DSL_boolean_t bSraOccured = DSL_FALSE, bBitSwapOccured = DSL_FALSE;

   pEvt = (AVX_EvtOlrDsEventGet_t*)pMsg;

   if (nDirection == DSL_UPSTREAM)
   {
      nDeviceType = DSL_PM_LTU;
   }
   else if (nDirection == DSL_DOWNSTREAM)
   {
      nDeviceType = DSL_PM_NTU;
   }
   else
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: invalid nDirection %d" DSL_CRLF, nLine, nDirection));
      return (DSL_ERROR);
   }

   /* in UPSTREAM RAU/RAD counters could be updated already here; for DOWNSTREAM we could decide only when new bitrate is known  */
   if (nDirection == DSL_UPSTREAM)
   {
      if (pEvt->OlrDsEvent & AVX_0703_SRA_DOWN_COND_HIT_MASK)
      {
         nBitMask |= DSL_G997_DATAPATHFAILURE_RAD;
      }

      if (pEvt->OlrDsEvent & AVX_0703_SRA_UP_COND_HIT_MASK)
      {
         nBitMask |= DSL_G997_DATAPATHFAILURE_RAU;
      }

      if (nBitMask)
      {
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, nDeviceType, nBitMask, DSL_TRUE);
      }
   }
   /* Check for OLR SRA events */
   if ((((pEvt->OlrDsEvent & AVX_0703_SRA_DOWN_COND_HIT_MASK) >> AVX_0703_SRA_DOWN_COND_HIT_POS) && (nDirection == DSL_UPSTREAM)) ||
       (((pEvt->OlrDsEvent & AVX_0703_SRA_UP_COND_HIT_MASK) >> AVX_0703_SRA_UP_COND_HIT_POS) && (nDirection == DSL_UPSTREAM))     ||
       (((pEvt->OlrDsEvent & AVX_0703_SRA_OK_MASK) >> AVX_0703_SRA_OK_POS) && (nDirection == DSL_UPSTREAM))                       ||
       (((pEvt->OlrDsEvent & AVX_0704_SRA_OK_MASK) >> AVX_0704_SRA_OK_POS) && (nDirection == DSL_DOWNSTREAM)))
   {
      bSraOccured = DSL_TRUE;
   }

   /* Check for OLR Bitswap events */
   if ((((pEvt->OlrDsEvent & AVX_0703_BS_OK_MASK) >> AVX_0703_BS_OK_POS) && (nDirection == DSL_UPSTREAM))  ||
       (((pEvt->OlrDsEvent & AVX_0704_BS_OK_MASK) >> AVX_0704_BS_OK_POS) && (nDirection == DSL_DOWNSTREAM)))
   {
      bBitSwapOccured = DSL_TRUE;
   }

   if (( bSraOccured == DSL_TRUE ) || ( bBitSwapOccured == DSL_TRUE ))
   {
      
      errorCode = DSL_AVX_AllBitswapStatusGet(pContext, nLine, nDirection);
      if (( errorCode == DSL_SUCCESS ) && ( bSraOccured == DSL_TRUE ))
      {
         if (nDirection == DSL_DOWNSTREAM)
         {
            DSL_TimerDB_Restart(pContext, nLine,
                       DSL_DBS_DS_BC_STATUS_TIMEOUT_ID,
                       DSL_TIMEOUTEVENT_DS_BC_STATUS,
                       DSL_DEV_TIMEOUT_DS_BC_STATUS * DSL_TIMEOUT_FACTOR);
         }
         else
            DSL_AVX_AllSraStatusGet(pContext, nLine, DSL_UPSTREAM);
      }
   }

   return (errorCode);
}

/**
   This function handles the AVINAX firmware messages
   \ref ACK_ModemFSM_StateGet and
   \ref EVT_ModemFSM_StateGet
   and processes the current status of the modem state-machine.

   \param pContext  Pointer to dsl library context structure, [I]
   \param nLine     Specifies on which line the message was received, [I]
   \param pStateGet Pointer to received AVINAX firmware message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_Error_t DSL_AVX_OnModemFsmStateGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_AckModemFsmStateGet_t const *pStateGet)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_DEV_LineState_t nActLineState = (DSL_DEV_LineState_t)0;
   DSL_DEV_LineState_t nPreLineState = (DSL_DEV_LineState_t)0;
   DSL_boolean_t bEventCallback = DSL_TRUE;
   DSL_uint32_t   nState = 0;
   /* Will be used by data base access macro and has to be set fixed to '0'
      because the configuration settings in this function are (bearer) channel
      independent  */
   static const DSL_uint8_t nChannel = 0;
#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
   DSL_OperationalDataReset_t opDataReset;
#endif
   DSL_boolean_t bDeferredOnIdle = DSL_FALSE;

   if(DSL_PM_GetReady(pContext))
   {
      IOCTL_MEI3_LINE_message_t sIoMsg;

      sIoMsg.msgId = AVX_ACK_MODEM_FSM_STATE_GET;
      sIoMsg.paylSize_byte = sizeof(AVX_AckModemFsmStateGet_t);
      sIoMsg.pPayload = (DSL_uint16_t*)pStateGet;

      DSL_PM_FirmwareMessageHandle(pContext, nLine, &sIoMsg, sizeof(IOCTL_MEI3_LINE_message_t), DSL_NULL, DSL_NULL);
   }

   nActLineState = (DSL_DEV_LineState_t)(DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE));
   nPreLineState = (DSL_DEV_LineState_t)(DSL_UINT32_GET(DSL_DBS_PRE_LINESTATE));

#define CHECK_LINE_STATE(state) \
   if (nActLineState == DSL_LINESTATUS_IDLE_REQUEST || nActLineState == DSL_LINESTATUS_SILENT_REQUEST) \
   {                                                                                                   \
      if (nPreLineState == state)                                                                      \
      {                                                                                                \
         DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: state 0x%x ignored" DSL_CRLF , nLine, state));    \
         bEventCallback = DSL_FALSE;                                                                   \
         break;                                                                                        \
      }                                                                                                \
   }                                                                                                   \

   nState = DSL_AVX_PARA32_GET(pStateGet->ModemState);
   switch(nState)
   {
   /*                                                                                Reset Showt.           */
   /*              AVINAX Status                          G.997.1 Status              values      PMMode           Text */
   AVX_STATE_SET( AVX_INIT_TRAIN_TRAIN_MASK,   DSL_LINESTATUS_FULL_INIT, DSL_FALSE, DSL_G997_PMS_NA, "FULL_INIT" )

   case AVX_SELT_MASK:
      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, "SELT_ACTIVE" ));
      if (DSL_LINESTATUS_SELT_ACTIVE != nActLineState)
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_SELT_ACTIVE);

         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_SELT_ACTIVE) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);
         nActLineState = DSL_LINESTATUS_SELT_ACTIVE;
         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_LINIT_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
              (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
               "not remove timeout!" DSL_CRLF , nLine ));
         }
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;
   
   case AVX_INIT_TRAIN_CHADISC_MASK:
      DSL_DEBUG( DSL_DBG_WRN, (pContext, 
         "DSL[%02d]: %s" DSL_CRLF , nLine, "FULL_INIT (CHADISC_MASK)" ));
      if (DSL_LINESTATUS_FULL_INIT != nActLineState)
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_FULL_INIT);

         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_FULL_INIT) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);
         nActLineState = DSL_LINESTATUS_FULL_INIT;

         DSL_UINT32_SET(DSL_DBL_LINIT_HS_CNT, 0);
         DSL_UINT32_SET(DSL_DBL_LINIT_HS_STARTUP_CNT, 0);

         nRet = DSL_AVX_XtseStatusGet(pContext, nLine);
         DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_FALSE, errorCode,
            "Error during XTSE status Get!" DSL_CRLF, nLine);

#ifdef INCLUDE_DSL_BND
         if (DSL_BND_IsLineBonded(pContext, nLine))
         {
            DSL_BND_ActivationMode_t nActivationMode = DSL_BND_ACTMODE_FULL;
            DSL_AVX_BND_LineActivationModeGet(pContext, nLine, &nActivationMode);

            
            /* read FE BND status to evaluate or report later */
            nRet = DSL_AVX_SendMsgPafHsStatusGet(pContext, nLine);
            DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
            
            /* request FE vendor info  for Rediscovery check */
            nRet = DSL_AVX_InventoryGet(pContext, nLine);
            DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_FALSE, errorCode,
               "Error during Inventory Get!" DSL_CRLF, nLine);


#ifdef INCLUDE_DSL_BND_PRIMITIVES
            if (pContext->pEventCallback != DSL_NULL)
            {
               DSL_BND_GhsCmdResultStatus_t resultStatus;

               errorCode = DSL_BND_GhsCmdResultStatusGet(pContext, nLine, &resultStatus);
               (void)(pContext->pEventCallback)( (DSL_void_t *)pContext,
                                                     nLine,
                                                     DSL_CHANNEL_NA,
                                                     DSL_ACCESSDIR_NA,
                                                     DSL_ATUDIR_NA,
                                                     DSL_CBS_BND_GHS_CMD_RESULT,
                                                    (DSL_CB_DATA_Union_t *)&resultStatus );

               if (nActivationMode == DSL_BND_ACTMODE_MANUAL)
               {
                  DSL_BND_GhsCmdResultCheckStatus_t checkStatus;
                  
                  DSL_DEBUG( DSL_DBG_WRN, (pContext, 
                     "DSL[%02d]: %s" DSL_CRLF , nLine, "BND_ACTMODE_MANUAL" ));

                  errorCode = DSL_BND_GhsCmdResultCheck(pContext, nLine, &checkStatus);
                  (void)(pContext->pEventCallback)( (DSL_void_t *)pContext,
                                                        nLine,
                                                        DSL_CHANNEL_NA,
                                                        DSL_ACCESSDIR_NA,
                                                        DSL_ATUDIR_NA,
                                                        DSL_CBS_BND_GHS_RESULT_CHECK,
                                                       (DSL_CB_DATA_Union_t *)&checkStatus );
               }
            }
#endif /* def INCLUDE_DSL_BND_PRIMITIVES */
         
            /* don't use bRestart pointer here, because restart is required on the whole group
               and will be handled inside the called function */
            nRet = DSL_AVX_BND_FsmOnFullInit(pContext, nLine, DSL_NULL);
            DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
         }
#endif /* INCLUDE_DSL_BND */
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;

   case AVX_SHORT_INIT_DETECT_MASK:
      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, "DSL_LINESTATUS_FASTRETRAIN" ));
      if (DSL_LINESTATUS_FASTRETRAIN != nActLineState)
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_FASTRETRAIN);

         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_FASTRETRAIN) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);
         nActLineState = DSL_LINESTATUS_FASTRETRAIN;

         DSL_AVX_ResetShowtimeValues(pContext, nLine, nChannel);
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;

   case AVX_SILENT_MASK:
      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, "READY" ));
      if (DSL_LINESTATUS_SILENT != nActLineState)
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_SILENT);

//Ani: Current state of line is Showtime and we get new Modem state to be silent
         if (DSL_LINESTATUS_SHOWTIME_TC_SYNC == nActLineState) {
	     DSL_AVX_HandleChangeEthPptpUni(nLine, PPTP_ETH_UNI_DOWN);
         }
//Ani
         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_SILENT) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);
         nActLineState = DSL_LINESTATUS_SILENT;

         DSL_AVX_PowerSavingTimerStart(pContext, nLine, DSL_TRUE);
         DSL_AVX_ResetShowtimeValues(pContext, nLine, nChannel);

         DSL_TimerDB_Restart(pContext, nLine,
                             DSL_DBS_LINIT_TIMEOUT_ID,
                             DSL_TIMEOUTEVENT_LINE_INIT,
                             DSL_DEV_TIMEOUT_LINIT * DSL_TIMEOUT_FACTOR);
#ifdef INCLUDE_DSL_BND
         /* handle bonding group state */
         nRet = DSL_AVX_BND_FsmOnSilent(pContext, nLine);
#endif
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;

   case AVX_IDLE_MASK:
      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, "IDLE" ));
      if (DSL_LINESTATUS_IDLE != nActLineState)
      {
//Ani: Current state of line is Showtime and we get new Modem state to be idle
         if (DSL_LINESTATUS_SHOWTIME_TC_SYNC == nActLineState) {
	     DSL_AVX_HandleChangeEthPptpUni(nLine, PPTP_ETH_UNI_DOWN);
         }
//Ani
         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_IDLE) != DSL_SUCCESS)
            return DSL_SUCCESS;

         /* don't need CHECK_LINE_STATE(DSL_LINESTATUS_IDLE)  here, otherwise 
            we can get into a stuck at IDLE_REQUEST state */
         
         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);
         nActLineState = DSL_LINESTATUS_IDLE;

         bDeferredOnIdle = DSL_TRUE;

         DSL_AVX_OnIdle(pContext, nLine);
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
#if defined(INCLUDE_DSL_BOARD_PRODUCTION_TEST) && defined(INCLUDE_DSL_API_VINAX_R3)
      if ((DSL_SEMAPHORE_INIT_VALID(&pContext->DeviceContext.BptStateChangeSem[nLine])) && pContext->DeviceContext.bBptEvtWaiting[nLine])
      {
         DSL_SemaphoreSet(&pContext->DeviceContext.BptStateChangeSem[nLine]);
      }
#endif
      break;


   case AVX_INIT_HS_MASK:
      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, "GHS" ));
      if (DSL_LINESTATUS_HANDSHAKE != nActLineState)
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_HANDSHAKE);

         DSL_AVX_PowerSavingL3Toggle(pContext, nLine, DSL_FALSE);
         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_HANDSHAKE) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);
         nActLineState = DSL_LINESTATUS_HANDSHAKE;
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }

#if defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1)
      /* OpData Freeze trigger was updated in 0x200 state. Now we can reset the values if the triiger is not set anymore*/
      if ( !((DSL_uint16_t) DSL_UINT16_GET(DSL_DBS_OPDATA_FREEZE) & (DSL_OPDATA_TRG_FREEZE_ALL)))
      {
         opDataReset.bConfigChanged = DSL_FALSE;
         DSL_DEV_OperationalDataReset(pContext, nLine, &opDataReset);
      }
#endif /* defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1) */

      if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_LINIT_TIMEOUT_ID) != DSL_SUCCESS)
      {
         DSL_DEBUG( DSL_DBG_WRN,
            (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
            "not remove timeout!" DSL_CRLF , nLine ));
      }

      break;

   /*
    * Handle exceptions in general.
    */
   case AVX_FAIL_MASK:
      if ((nActLineState != DSL_LINESTATUS_EXCEPTION) &&
          (nActLineState != DSL_LINESTATUS_IDLE) &&
          /* ignore event if IDLE was triggered from IDLE */
         ((nActLineState != DSL_LINESTATUS_IDLE_REQUEST) ||
         ((DSL_DEV_LineState_t)(DSL_UINT32_GET(DSL_DBS_PRE_LINESTATE)) != DSL_LINESTATUS_IDLE)))
      {
         DSL_boolean_t bFeTimerActive = DSL_FALSE;
         DSL_boolean_t bRestart = DSL_FALSE;

         CHECK_LINE_STATE(DSL_LINESTATUS_EXCEPTION);

         DSL_DEBUG(DSL_DBG_WRN, (pContext, "DSL[%02d]: FAIL" DSL_CRLF , nLine));
         /* DSL_AVX_PowerSavingL3Toggle(pContext, nLine, DSL_FALSE); */
         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_EXCEPTION) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);
         nActLineState = DSL_LINESTATUS_EXCEPTION;
         DSL_UINT8_SET(DSL_DBS_DEV_LAST_EXCEPTION, DSL_LINESTATUS_EXCEPTION);
         /* The Fail Reason is indicated by a dedicated ALM autonomously
            if DSL_AVX_SendMsgEventConfigure enables the Fail event */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
         /* reset the APS state machine */
         DSL_AVX_ApsFsmStateSet(pContext, nLine, DSL_APS_ACTIVE);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

         /* FIXME: state polling for SELT_COMPLETE, as long as not indicated by event */
         pContext->DeviceContext.LineFlags[nLine].bStatePolling = DSL_FALSE;

         /* If the line left SHOWTIME the timeout event has to be removed if still
            active. */
         if (DSL_ULONG_GET(DSL_DBS_FE_STATUS_TIMEOUT_ID) > 0)
         {
            bFeTimerActive = DSL_TRUE;
         }

         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_FE_STATUS_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
               (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
               "not remove timeout!" DSL_CRLF, nLine ));
         }

         /* also remove the DELT FE Status timeout if still active */
         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
               (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
               "not remove timeout!" DSL_CRLF, nLine ));
         }

         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_FE_STATUS_POLLING_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
               (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
               "not remove timeout!" DSL_CRLF, nLine ));
         }

         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_FE_SNR_UPDATE_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
               (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
               "not remove timeout!" DSL_CRLF, nLine ));
         }

         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_LINIT_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
               (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
               "not remove timeout!" DSL_CRLF, nLine ));
         }
         
         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_DS_BC_STATUS_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
               (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
               "not remove DS BC timeout!" DSL_CRLF , nLine ));
         }

         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_BND_TRAFFIC_CHECK_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
               (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
               "not remove BND Traffic check timeout!" DSL_CRLF , nLine ));
         }
        

         /* get Fail reason and SPAR1 bits */
         nRet = DSL_AVX_AllFailStatusGet(pContext, nLine);
         DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
         if (_DSLAPI DSL_AVX_ApsP1FsmStateGet(pContext, nLine) != DSL_APSP1_DISABLED)
         {
            /* get status and make decision */
            nRet = DSL_AVX_ApsP1FailDecision(pContext, nLine, bFeTimerActive, &bRestart);
            DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

            if (bRestart)
            {
               /* restart the line.
                  Reconfiguration will be
                  triggered by modem state RESET */

               /* request the change to the next lower config in the priority list,
                  execution is done at RESET event */
               DSL_AVX_ApsP1FsmStateSet(pContext, nLine, DSL_APSP1_CONFIG);
            }
         }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#ifdef INCLUDE_DSL_BND
         /* handle the PAF state machine */
         /* don't use bRestart pointer here, because restart is required on the whole group
            and will be handled inside the called function */
         nRet = DSL_AVX_BND_FsmOnFail(pContext, nLine, DSL_NULL);
#endif
         /*  In a showtime drop situation with auto-restart line doesn't enter 
            IDLE and we will need to disable L2 when FAIL was indicated. */
         DSL_AVX_SendMsgModemFsmOptionsSet(pContext, nLine);

         /* if RTX Test Mode was on, we should disable it and also restore SRA settings*/
         if (DSL_UINT8_GET(DSL_DBL_RTX_TEST_MODE))
         {
            /* disable RTX Test Mode @ CO-side*/
            DSL_AVX_SendMsgTxErrorControl( pContext, nLine, nChannel, DSL_TRUE, DSL_TRUE);

            /* restore SRA settings*/
            DSL_AVX_SendMsgOlrControl(pContext, nLine, DSL_FALSE);

            DSL_UINT8_SET(DSL_DBL_RTX_TEST_MODE, 0);

            if (pContext->pEventCallback != DSL_NULL)
            {
               DSL_boolean_t bSemMask = DSL_FALSE;
               DSL_CB_DATA_RtxTestMode_t rtxTestMode;

               bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_RTX_TESTMODE));

               rtxTestMode.bActive = DSL_FALSE;

               if (bSemMask == DSL_FALSE)
               {
                 (void)(pContext->pEventCallback)( pContext,
                                              nLine,
                                              DSL_CHANNEL_NA,
                                              DSL_ACCESSDIR_NA,
                                              DSL_ATUDIR_NA,
                                              DSL_CBS_RTX_TESTMODE,
                                              (DSL_CB_DATA_Union_t *)&rtxTestMode );
               }
            }
         }
         if (bRestart)
         {
            nRet = DSL_AVX_RequestIdle(pContext, nLine, DSL_FALSE);
            DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode, "DSL_AVX_RequestIdle failed!" DSL_CRLF, nLine);
         }

      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;

   case AVX_PARK_MASK:
      DSL_UINT32_SET(DSL_DBS_ACT_LINESTATE, (DSL_uint32_t)DSL_LINESTATUS_MELT_PARK);
      DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, (DSL_uint32_t)nActLineState);
      nActLineState = DSL_LINESTATUS_MELT_PARK;
      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, "MELT_PARK" ));
#ifdef INCLUDE_DSL_API_AVINAX_MELT
      {
         DSL_MELT_Context_t *pMeltContext = pContext->pMELT_Ctx;
         DSL_uint8_t nDevNum, nSlic;
         MELT_Slic_t *pSlic;
         DSL_MELT_Priority_t meltPrio;
         DSL_LayoutMapEntry_t *pLayoutMap = &pMeltContext->pDSL_Context->DeviceContext.lowlevelConfig.sCommonConfig.nConfigLayout.sLayoutMap[nLine];

         CHECK_LINE_STATE(DSL_LINESTATUS_MELT_PARK);

         meltPrio = (DSL_MELT_Priority_t) DSL_UINT8_GET(DSL_DBL_MELT_PRIORITY);

         //nDevNum = DSL_RelativeDevNumGet(pMeltContext, nLine);
         //nSlic = DSL_RelativeSlicNumGet(pMeltContext, nLine);

         if ((pLayoutMap->nSlicMasterDevice == (DSL_uint8_t)-1 ) &&
             (pLayoutMap->nSlicTipRing != (DSL_uint16_t) -1 ))
         {
            nDevNum = pMeltContext->pDSL_Context->DeviceContext.lowlevelConfig.sCommonConfig.nConfigLayout.sLayoutMap[pLayoutMap->nSlicTipRing].nSlicMasterDevice;
            nSlic = pMeltContext->pDSL_Context->DeviceContext.lowlevelConfig.sCommonConfig.nConfigLayout.sLayoutMap[pLayoutMap->nSlicTipRing].nDfeSlicId;
         }
         else
         {
            nDevNum = pLayoutMap->nSlicMasterDevice;
            nSlic = pLayoutMap->nDfeSlicId;
         }

         pSlic = &pMeltContext->devs[nDevNum]->slics[nSlic];

         if(( meltPrio == DSL_MELT_PRIORITY_MELT_MEASUREMENT ) &&
           ( pSlic->nState != LTC_SlicWetting ))
         {
            break;
         }
         /* triggers an asynchronous stopping of MELT */
         DSL_UINT32_SET(DSL_DBS_LAST_MELT_ACTION, DSL_MELT_ModeDisabled);
         nRet = DSL_MELT_AsyncRestart( pContext, nLine );
      }
#endif
      break;

   case AVX_SHOWTIME_TC_NOSYNC_MASK:
   case AVX_SHOWTIME_ENTER_TC_NOSYNC_MASK:
      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, "STEADY_STATE" ));
      if (DSL_LINESTATUS_SHOWTIME_NO_SYNC != nActLineState)
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_SHOWTIME_NO_SYNC);

         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_SHOWTIME_NO_SYNC) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, (DSL_uint32_t)nActLineState);

         DSL_AVX_HandleLinitValue(pContext, nLine, LINIT_SUCCESSFUL, LINIT_SUB_NONE, DSL_FALSE);

         /* if this was the first showtime event after training, get the status */
         /* if (nActLineState == DSL_LINESTATUS_FULL_INIT) */
         {
            nRet = DSL_AVX_ShowtimeReached(pContext, nLine, &bEventCallback);
            DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
         }
         nActLineState = DSL_LINESTATUS_SHOWTIME_NO_SYNC;
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;

   /*
    * Check, if the message reports that the modem entered
    * INITIAL_SHOWTIME_TC_SYNC state.
    */
   case AVX_SHOWTIME_TC_SYNC_MASK:
   case AVX_SHOWTIME_ENTER_TC_SYNC_MASK:
      /*
       * Connection is established, TC-layer status has to be requested.
       */
      DSL_DEBUG(DSL_DBG_WRN, (pContext, "DSL[%02d]: SHOWTIME" DSL_CRLF , nLine));
      if ((nActLineState == DSL_LINESTATUS_SHOWTIME_NO_SYNC) ||
         (nActLineState == DSL_LINESTATUS_FULL_INIT))
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_SHOWTIME_TC_SYNC);

//Ani
	 DSL_AVX_HandleChangeEthPptpUni(nLine, PPTP_ETH_UNI_UP);
//Ani
         /* the statechange has to be stored in any case,
            because it is used internally */
         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_SHOWTIME_TC_SYNC) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);

         /* LTU means near-end here */
         /* clear all line failures, the firmware does not support clearing of events here */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU,
                  DSL_G997_LINEFAILURE_LOF |
                  DSL_G997_LINEFAILURE_LOL |
                  DSL_G997_LINEFAILURE_LOS |
                  DSL_G997_LINEFAILURE_LOM |
                  DSL_G997_LINEFAILURE_ESE |
                  DSL_G997_LINEFAILURE_LPR, DSL_FALSE);
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU,
                  DSL_G997_LINEFAILURE_LOF |
                  DSL_G997_LINEFAILURE_LOL |
                  DSL_G997_LINEFAILURE_LOS |
                  DSL_G997_LINEFAILURE_LOM |
                  DSL_G997_LINEFAILURE_ESE |
                  DSL_G997_LINEFAILURE_LPR, DSL_FALSE);

         DSL_AVX_HandleLinitValue(pContext, nLine, LINIT_SUCCESSFUL, LINIT_SUB_NONE, DSL_FALSE);

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
         opDataReset.bConfigChanged = DSL_FALSE;
         /* clear operational data when reaching showtime*/
         DSL_DEV_OperationalDataReset(pContext, nLine, &opDataReset);
#endif /* #defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

         nRet = DSL_AVX_ShowtimeReached(pContext, nLine, &bEventCallback);
         DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

         /* start the SNR w/o VN query only in TCSync state */
         DSL_AVX_SNR_WOVN_DATA_CLEAR(nLine);
         DSL_AVX_SnrWoVnUsQuery(pContext, nLine);
         DSL_AVX_SnrWoVnUsQueryRestartTimer(pContext, nLine);

#ifdef INCLUDE_DSL_API_AVINAX_MELT
         {
            DSL_MELT_Priority_t meltPrio;
            DSL_MELT_OperationMode_t lastMeltAction;

            meltPrio = (DSL_MELT_Priority_t) DSL_UINT8_GET(DSL_DBL_MELT_PRIORITY);
            lastMeltAction = (DSL_MELT_OperationMode_t) DSL_UINT32_GET(DSL_DBS_LAST_MELT_ACTION);
            if (( lastMeltAction != DSL_MELT_ModeDisabled ) &&
                   ((meltPrio == DSL_MELT_PRIORITY_MELT_MEASUREMENT) ||
                    (meltPrio == DSL_MELT_PRIORITY_MIXED)))
            {
               nRet = DSL_MELT_AsyncRestart( pContext, nLine );
               DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
            }
         }
#endif /* INCLUDE_DSL_API_AVINAX_MELT */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
         if (DSL_AVX_Eaps2FsmStateGet(pContext, nLine) == DSL_EAPS2_RETRAIN)
            break;
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

         nActLineState = DSL_LINESTATUS_SHOWTIME_TC_SYNC;

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
         /* Readout operational data "init" values */
         DSL_AVX_OnTimeoutEvent_OpDataGet(pContext, nLine, DSL_OPDATA_TYPE_INIT);

         DSL_TimerDB_Restart(pContext, nLine,
                             DSL_DBS_OPDATA_GET_TIMEOUT_ID,
                             DSL_TIMEOUTEVENT_OPDATA_GET,
                             10 * DSL_TIMEOUT_FACTOR);
#endif /* #defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;

   /*
    * Handle SELT_COMPLETED.
    */
   case AVX_SELT_COMPLETE_MASK:
      /* ATTENTION: SELT data has to be requested first before signalling the
         SELT ready event to the upper layer application! */
      if (nActLineState != DSL_LINESTATUS_SELT_COMPLETE)
      {
         DSL_SELT_LineData_t *pLineData = DSL_NULL;

         CHECK_LINE_STATE(DSL_LINESTATUS_SELT_DATA_REQUEST);
         CHECK_LINE_STATE(DSL_LINESTATUS_SELT_COMPLETE);

         pLineData = _DSLAPI DSL_SeltLineDataGet(pContext, nLine);
         if ((pLineData == DSL_NULL))
         {
            DSL_DEBUG(DSL_DBG_ERR,
               (pContext, "DSL[%02d]: there is no SELT params entry for this line!"
                DSL_CRLF, nLine));
            return (DSL_ERROR);
         }

         /* FIXME: state polling for SELT_COMPLETE, as long as not indicated by event */
         pContext->DeviceContext.LineFlags[nLine].bStatePolling = DSL_FALSE;
         bEventCallback = DSL_FALSE;

         DSL_AVX_SetLineState(pContext, nLine, DSL_LINESTATUS_SELT_DATA_REQUEST, DSL_TRUE);

         if (pLineData->nError & AVX_SELT_FDR_REQUEST)
         {
            errorCode = DSL_AVX_SeltFDRVarUpdate(pContext, nLine);
            if(errorCode != DSL_SUCCESS)
            {
               DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: failed to receive FDR_VAR data" DSL_CRLF, nLine));
               return (DSL_ERROR);
            }
            else
            {
               DSL_DEBUG(DSL_DBG_WRN, (pContext, "DSL[%02d]: SELT_FDR_VAR_COMPLETED" DSL_CRLF, nLine));
            }

            errorCode = DSL_AVX_SeltFDRUpdate(pContext, nLine);
            if(errorCode != DSL_SUCCESS)
            {
               DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: failed to receive FDR data" DSL_CRLF, nLine));
               return (DSL_ERROR);
            }
            else
            {
               DSL_DEBUG(DSL_DBG_WRN, (pContext, "DSL[%02d]: SELT_FDR_COMPLETED" DSL_CRLF, nLine));
            }
         }

         if (pLineData->nError & AVX_SELT_ICN_REQUEST)
         {
            errorCode = DSL_AVX_SeltICNUpdate(pContext, nLine);
            if(errorCode != DSL_SUCCESS)
            {
               DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: failed to receive ICN data" DSL_CRLF, nLine));
               return (DSL_ERROR);
            }
            else
            {
               DSL_DEBUG(DSL_DBG_WRN, (pContext, "DSL[%02d]: SELT_ICN_COMPLETED" DSL_CRLF, nLine));
            }
         }

         if (pLineData->nError == AVX_SELT_COMPLETE)
         {
            errorCode = DSL_AVX_SeltCpeDetect(pContext, nLine);
            if(errorCode != DSL_SUCCESS)
            {
               DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: failed to detect CPE" DSL_CRLF, nLine));
            }
            else
            {
               DSL_DEBUG(DSL_DBG_WRN, (pContext, "DSL[%02d]: CPE_DETECTION_COMPLETED" DSL_CRLF, nLine));
            }
            DSL_AVX_SetLineState(pContext, nLine, DSL_LINESTATUS_SELT_COMPLETE,DSL_TRUE);
            DSL_DEBUG(DSL_DBG_WRN, (pContext, "DSL[%02d]: SELT_COMPLETED" DSL_CRLF, nLine));
         }
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;

   case AVX_DELT_MASK:
      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, "DIAG_MODE" ));
      if (DSL_LINESTATUS_LOOPDIAGNOSTIC_ACTIVE != nActLineState)
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_LOOPDIAGNOSTIC_ACTIVE);

         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_LOOPDIAGNOSTIC_ACTIVE) != DSL_SUCCESS)
            return DSL_SUCCESS;
         
         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, (DSL_uint32_t)nActLineState);
         nActLineState = DSL_LINESTATUS_LOOPDIAGNOSTIC_ACTIVE;

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, BitAllocation, US, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, BitAllocation, DS, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, GainNSC, US, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, GainNSC, DS, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, Tss, US, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, Tss, DS, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, TxPsd, US, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, TxPsd, DS, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlin, US, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlin, DS, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlog, US, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlog, DS, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltQln, US, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltQln, DS, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltSnr, US, DSL_FALSE);
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltSnr, DS, DSL_FALSE);
#endif /* defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;


   case AVX_DELT_COMPLETE_MASK:
      bEventCallback = DSL_TRUE;
      DSL_DEBUG(DSL_DBG_WRN, (pContext, "DSL[%02d]: DIAG_COMPLETE" DSL_CRLF , nLine));
      if (nActLineState != DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE)
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE);

         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);
         nActLineState = DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE;

         DSL_UINT8_SET(DSL_DBL_LDSF, 0);

         /* start requesting the status data */
         errorCode = DSL_AVX_AllDeltStatusGet(pContext, nLine);

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
         /* Readout operational data "loop diag." values */
         DSL_AVX_OnTimeoutEvent_OpDataGet(pContext, nLine, DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS);
#endif /* #defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;


   case AVX_TEST_MASK:
      bEventCallback = DSL_TRUE;
      switch (DSL_UINT8_GET(DSL_DBL_TESTMODE))
      {
         AVX_STATE_SET( DSL_TESTMODE_ADSL_REVERB, DSL_LINESTATUS_TEST_REVERB, DSL_FALSE, DSL_G997_PMS_NA, "TEST_REVERB" )
         AVX_STATE_SET( DSL_TESTMODE_ADSL_MEDLEY, DSL_LINESTATUS_TEST_MEDLEY, DSL_FALSE, DSL_G997_PMS_NA, "TEST_MEDLEY" )
         AVX_STATE_SET( DSL_TESTMODE_UTOPIA_LOOP, DSL_LINESTATUS_TEST_LOOP,   DSL_FALSE, DSL_G997_PMS_NA, "TEST_LOOP" )
      default:
         DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: TEST" DSL_CRLF , nLine ));
         if (DSL_LINESTATUS_TEST != nActLineState)
         {
            CHECK_LINE_STATE(DSL_LINESTATUS_TEST);

            if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_TEST) != DSL_SUCCESS)
               return DSL_SUCCESS;

            DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, (DSL_uint32_t)nActLineState);
            nActLineState = DSL_LINESTATUS_TEST;
         }
         else
            bEventCallback = DSL_FALSE;
      }
#if defined(INCLUDE_DSL_BOARD_PRODUCTION_TEST) && defined(INCLUDE_DSL_API_VINAX_R3)
      if ((DSL_SEMAPHORE_INIT_VALID(&pContext->DeviceContext.BptStateChangeSem[nLine])) && pContext->DeviceContext.bBptEvtWaiting[nLine])
      {
         DSL_SemaphoreSet(&pContext->DeviceContext.BptStateChangeSem[nLine]);
      }
#endif /*defined(INCLUDE_DSL_BOARD_PRODUCTION_TEST)*/
      break;

#ifdef INCLUDE_DSL_BND_EFM
   case AVX_GHS_BONDING_COMPLETE_MASK:

      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, "GHS_BONDING_COMPLETE" ));
      if (DSL_LINESTATUS_GHS_BONDING_COMPLETE != nActLineState)
      {
         CHECK_LINE_STATE(DSL_LINESTATUS_GHS_BONDING_COMPLETE);

         if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, DSL_LINESTATUS_GHS_BONDING_COMPLETE) != DSL_SUCCESS)
            return DSL_SUCCESS;

         DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, nActLineState);
         nActLineState = DSL_LINESTATUS_GHS_BONDING_COMPLETE;

         /* trigger the Bonding State Machine */
         errorCode = DSL_AVX_BND_FsmOnBondingComplete(pContext, nLine);
#ifdef INCLUDE_DSL_BND_PRIMITIVES
         if (pContext->pEventCallback != DSL_NULL)
         {
            DSL_BND_GhsCmdResultStatus_t resultStatus;
            DSL_BND_GhsCmdResultCheckStatus_t checkStatus;
            errorCode = DSL_BND_GhsCmdResultStatusGet(pContext, nLine, &resultStatus);
            (void)(pContext->pEventCallback)( (DSL_void_t *)pContext,
                                                  nLine,
                                                  DSL_CHANNEL_NA,
                                                  DSL_ACCESSDIR_NA,
                                                  DSL_ATUDIR_NA,
                                                  DSL_CBS_BND_GHS_CMD_RESULT,
                                                 (DSL_CB_DATA_Union_t *)&resultStatus );
            errorCode = DSL_BND_GhsCmdResultCheck(pContext, nLine, &checkStatus);
            (void)(pContext->pEventCallback)( (DSL_void_t *)pContext,
                                                  nLine,
                                                  DSL_CHANNEL_NA,
                                                  DSL_ACCESSDIR_NA,
                                                  DSL_ATUDIR_NA,
                                                  DSL_CBS_BND_GHS_RESULT_CHECK,
                                                 (DSL_CB_DATA_Union_t *)&checkStatus );
         }
#endif /* INCLUDE_DSL_BND_PRIMITIVES */
      }
      else
      {
         bEventCallback = DSL_FALSE;
      }
      break;
#endif /* def INCLUDE_DSL_BND_EFM */

   default:
      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: Modem State %x" DSL_CRLF ,
                 nLine, nState) );
      bEventCallback = DSL_FALSE;
      break;
   }

   switch (((AVX_AckModemFsmStateGet_t*)pStateGet)->Parameter1)
   {
   case AVX_PMS_L0_MASK:
      DSL_AVX_dbSetPMMode(pContext, nLine, DSL_G997_PMS_L0);
      break;
   case AVX_PMS_L2_MASK:
      DSL_AVX_dbSetPMMode(pContext, nLine, DSL_G997_PMS_L2);
      break;
   case AVX_PMS_L3_MASK:
      DSL_AVX_dbSetPMMode(pContext, nLine, DSL_G997_PMS_L3);
      break;
   default:
      break;
   }

/* AVX_STATE_GET: */

   if (pContext->pEventCallback != DSL_NULL)
   {
      if (bEventCallback == DSL_TRUE)
      {
         DSL_boolean_t bSemMask = DSL_FALSE;

         bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_LINE_STATE));
         if (bSemMask == DSL_FALSE)
         {
            DSL_CB_DATA_LineState_t nCbData;
            nCbData.nLineState = nActLineState;

            (void)(pContext->pEventCallback)( (DSL_void_t *)pContext,
                                        nLine,
                                        DSL_CHANNEL_NA,
                                        DSL_ACCESSDIR_NA,
                                        DSL_ATUDIR_NA,
                                        DSL_CBS_LINE_STATE,
                                        (DSL_CB_DATA_Union_t *)&nCbData );
         }
      }
   }

   if (bDeferredOnIdle)
   {
      nRet = DSL_AVX_HandleDefferedAction( pContext, nLine);
   }

   return (errorCode);
}

/**
   This function handles an exception which has been send by the firmware
   messages \ref ALM_ModemFSM_FailReasonGet or
   \ref ACK_ModemFSM_FailReasonGet.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]
   \param pMsg     Pointer to received AVINAX firmware message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_Error_t DSL_AVX_OnFailReasonGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_AckModemFsmFailReasonGet_t const *pAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;
   DSL_uint32_t nTriggerMask = 0;
   DSL_uint32_t nActualTrigger = 0;
   DSL_uint8_t nErrorCode = 0, nSubErrorCode = 0;
   DSL_G997_LineInitStatus_t  nStatus = LINIT_SUCCESSFUL;
   DSL_G997_LineInitSubStatus_t  nSubStatus = LINIT_SUB_NONE;
   DSL_char_t const *pStatusString  = "E_OK";
   DSL_boolean_t bLineRetrain = DSL_FALSE;

   /* map the failure code to G997.1 LINIT fail codes (if it was an initialization failure)
      Abuse LINIT_SUCCESSFUL to mark events as "no LINIT" and don't indicate them further */

   nErrorCode = (DSL_uint8_t)((pAck->tFailReason.FailCode & AVX_0205_ERROR_CODE_MASK) >> AVX_0205_ERROR_CODE_POS);
   nSubErrorCode = (DSL_uint8_t)((pAck->tFailReason.FailCode & AVX_0205_SUB_ERROR_CODE_MASK) >> AVX_0205_SUB_ERROR_CODE_POS);
   
   /* DSLCOSW-2389: in case of a modem reset by DMS XSM_E_CODE_MODEM_RESET = 407
      don't indicate and store LINIT failures */
   if (pAck->tFailReason.FwFailCode == 407)
   {
      nStatus = LINIT_SUCCESSFUL;
   }
   else
   {
      switch (nErrorCode)
      {
      AVX_EXCEPTION_SET(AVX_E_CONFIG,      LINIT_CONFIG_ERROR,          "E_CONFIG")
      AVX_EXCEPTION_SET(AVX_E_COMMCRC,     LINIT_COMMUNICATION_PROBLEM, "E_COMMCRC")
      AVX_EXCEPTION_SET(AVX_E_NOPEER,      LINIT_NO_PEER_XTU,           "E_NOPEER")
      AVX_EXCEPTION_SET(AVX_E_UNKNOWN,     LINIT_UNKNOWN,               "E_UNKNOWN")
      AVX_EXCEPTION_SET(AVX_E_CHIPSET,     LINIT_UNKNOWN,               "E_CHIPSET")
      AVX_EXCEPTION_SET(AVX_E_RESERVED,    LINIT_UNKNOWN,               "E_RESERVED")
      AVX_EXCEPTION_SET(AVX_E_COMM,        LINIT_COMMUNICATION_PROBLEM, "E_COMM")
      AVX_EXCEPTION_SET(AVX_E_NOTFEASIBLE, LINIT_CONFIG_NOT_FEASIBLE,   "E_NOTFEASIBLE")
      AVX_EXCEPTION_SET(AVX_E_RTX,         LINIT_HS_NO_RTX,             "E_RTX")

      /* those are no Initialization failures */
      AVX_EXCEPTION_SET(AVX_E_OK,          LINIT_SUCCESSFUL,            "E_OK")
      AVX_EXCEPTION_SET(AVX_E_SHOWTIME_NE, LINIT_SUCCESSFUL,            "E_OK")
      AVX_EXCEPTION_SET(AVX_E_SHOWTIME_FE, LINIT_SUCCESSFUL,            "E_OK")

      default:
         DSL_DEBUG( DSL_DBG_WRN, (pContext,
            "DSL[%02d]: Unknown Exception Reason code: 0x%X" DSL_CRLF,
            nLine, nErrorCode ));
         nStatus = LINIT_UNKNOWN;
         pStatusString = "E_UNKNOWN";
         break;
      }
   }

   /* map the sub codes to API sub error classes */
   switch (nSubErrorCode)
   {
   case AVX_S_OK:
      nSubStatus = LINIT_SUB_NONE;
      break;
   case AVX_S_MODE:
      break;
   case AVX_S_HW_MODE:
      nSubStatus = LINIT_SUB_DOUBLE_TRAIN;
      break;
   case AVX_S_UPBO:
      nSubStatus = LINIT_SUB_UPBO_VIOLATION;
      break;
   case AVX_S_TEMP:
      DSL_DEBUG( DSL_DBG_WRN, (pContext,
         "DSL[%02d]: Temperature Failure %d" DSL_CRLF ,
         nLine, nSubErrorCode));
      nSubStatus = LINIT_SUB_TEMPERATURE;
      break;
   case AVX_S_APS_XDSL_MODE:
   case AVX_S_CODESWAP:
   case AVX_S_PSDCONFIG:
   case AVX_S_MINRATE_US:
   case AVX_S_MINRATE_DS:
   case AVX_S_INIT:
   case AVX_S_TIMEOUT:
   case AVX_S_XDSL_MODE:
   case AVX_S_SELT_CPE:
   case AVX_S_LOS:
   case AVX_S_LOF:
   case AVX_S_LPR:
   case AVX_S_LOM:
   case AVX_S_LOL:
   case AVX_S_ESE:
   case AVX_S_32CRC0:
   case AVX_S_32CRC1:
   case AVX_S_OOS0:
   case AVX_S_OOS1:
   case AVX_S_OOS2:
   case AVX_S_LCD0:
   case AVX_S_LCD1:
   case AVX_S_LCD2:
   case AVX_S_NCD0:
   case AVX_S_NCD1:
   case AVX_S_NCD2:
   case AVX_S_EOC_G992_1:
   case AVX_S_OH_MSG:
   case AVX_S_INTERCHIP_COMM:
   case AVX_S_MELT:
   case AVX_S_FWDOWNLOAD_REQ:
   case AVX_S_MEM_WATCHDOG:
      nSubStatus = LINIT_SUB_UNKNOWN;
      break;
   default:
      DSL_DEBUG( DSL_DBG_WRN, (pContext,
         "DSL[%02d]: Unknown Exception SubReason code: 0x%X" DSL_CRLF,
         nLine, nSubErrorCode ));
      nSubStatus = LINIT_SUB_UNKNOWN;
      break;
   }

   /* remember the failure in any case */
   DSL_UINT8_SET(DSL_DBS_DEV_LAST_EXCEPTION, nErrorCode);
   DSL_UINT8_SET(DSL_DBS_DEV_LAST_SUB_ERROR_CODE, nSubErrorCode);
   DSL_UINT16_SET(DSL_DBS_DEV_LAST_FW_FAIL_CODE, pAck->tFailReason.FwFailCode);

   /**/
   if (pContext->pEventCallback != DSL_NULL)
   {
      DSL_boolean_t bSemMask = DSL_FALSE;

      bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_EXCEPTION_CODES));
      if (bSemMask == DSL_FALSE)
      {
         DSL_CB_DATA_Exception_Code_t nCbData;

         nCbData.failCodes.nError1 = ((DSL_uint32_t)pAck->tFailReason.FwFailCode<<16) | pAck->tFailReason.FailCode;
         nCbData.failCodes.nError2 = ((DSL_uint32_t)pAck->tFailReason.RxStateOnFail<<16) | pAck->tFailReason.TxStateOnFail;
         nCbData.failCodes.nError3 = 0;

         (void)(pContext->pEventCallback)( (DSL_void_t *)pContext,
                                     nLine,
                                     DSL_CHANNEL_NA,
                                     DSL_ACCESSDIR_NA,
                                     DSL_ATUDIR_NA,
                                     DSL_CBS_DBG_EXCEPTION_CODE,
                                     (DSL_CB_DATA_Union_t *)&nCbData );
      }
   }

   /* Treat it as LINIT event only if not made otherwise */
   if (nStatus != LINIT_SUCCESSFUL)
   {
      DSL_DEBUG( DSL_DBG_WRN, (pContext,
         "DSL[%02d]: Exception Reason: %s Subreason %d" DSL_CRLF,
         nLine, pStatusString, nSubStatus ));
      DSL_AVX_HandleLinitValue(pContext,
         nLine, (DSL_G997_LineInitStatus_t)nStatus, nSubStatus, DSL_TRUE);
   }
   
   /* Soft Recovery handling */
   if (((nSubErrorCode == AVX_S_FWDOWNLOAD_REQ) && (pAck->tFailReason.FwFailCode == 230)) || 
         /*	XSM_E_CODE_MEMORY_CORRUPTION (230) */
       (nSubErrorCode == AVX_S_MEM_WATCHDOG))
   {
      DSL_DBG_ExceptionHistoryAddEvent(pContext, nLine, 
         ((DSL_uint32_t)pAck->tFailReason.FwFailCode<<16) | pAck->tFailReason.FailCode, 
         ((DSL_uint32_t)pAck->tFailReason.RxStateOnFail<<16) | pAck->tFailReason.TxStateOnFail,
         0, DSL_AUTORECOVER_TRIGGER_SOFT_RECOVERY);

      return DSL_AVX_OnSoftRecoveryTrigger(pContext, nLine, &pAck->tFailReason);
   }

   if ((nSubErrorCode == AVX_S_CODESWAP) ||
       ((pAck->tFailReason.FailCode == 0xAFFE) && (pAck->tFailReason.FwFailCode == 0xDEAD)) ||
       (nSubErrorCode == AVX_S_FWDOWNLOAD_REQ))
   {
      nTriggerMask = DSL_UINT32_GET(DSL_DBI_AUTORECOVER_TRIGGERMASK);

      DSL_DEBUG( DSL_DBG_ERR, (pContext,
         "DSL[%02d]: Recovery requested by FW code %d" DSL_CRLF ,
         nLine, pAck->tFailReason.FwFailCode));

      if ((nTriggerMask & DSL_AUTORECOVER_TRIGGER_CODESWAP_ERROR) && (nSubErrorCode == AVX_S_CODESWAP))
      {
         nActualTrigger = DSL_AUTORECOVER_TRIGGER_CODESWAP_ERROR;
      }

      if ((nTriggerMask & DSL_AUTORECOVER_TRIGGER_FW_REQUEST) &&
          (pAck->tFailReason.FailCode == 0xAFFE) && (pAck->tFailReason.FwFailCode == 0xDEAD))
      {
         nActualTrigger = DSL_AUTORECOVER_TRIGGER_FW_REQUEST;
      }

      if (nSubErrorCode == AVX_S_FWDOWNLOAD_REQ)
      {
         /* Silent Stuck */
         switch(pAck->tFailReason.FwFailCode)
         {
         case 10: /*	XSM_E_CODE_RSM_TIMEOUT (10) */
         case 111: /*	XSM_E_CODE_REVERB5_IPTC_TIMEOUT (111) */
         case 112: /*	XSM_E_CODE_REVERB7BIS_IPTC_TIMEOUT (112) */
         case 113: /*	XSM_E_CODE_CHDISC1_IPTC_TIMEOUT (113) */
         case 114: /*	XSM_E_CODE_REVERB7BIS_IPTC_BUSY (114) */
         case 211: /*	XSM_E_CODE_AFE_LOCK_LOST (211) */
         case 212: /*	XSM_E_CODE_FATAL_AFE_IF (212) */
         case 223: /*	XSM_E_CODE_RX_PATH_SILENT_STUCK (223) */
         case 753: /*	XSM_E_CODE_IPD_IPTC_ERR_FATAL (753) */
            pContext->DeviceContext.DumpBuffer[nLine].nMemoryDumpTrigger = DSL_DBG_TRIGGER_LINE_STUCK;
            if (nTriggerMask & DSL_AUTORECOVER_TRIGGER_FW_REQUEST)
            {
               nActualTrigger = DSL_AUTORECOVER_TRIGGER_FW_REQUEST;
            }
            break;

         default:
            break;
         }

         if (nTriggerMask & DSL_AUTORECOVER_TRIGGER_FW_REQUEST)
         {
            /* remember the current counters to restore them after recovery */
#if 0 /* Counter restore is not supported yet */
            DSL_AVX_CountersBackup(pContext, nLine);
#endif
            nActualTrigger = DSL_AUTORECOVER_TRIGGER_FW_REQUEST;
         }
      }
   }

   if (nActualTrigger)
   {
      /* send the line to IDLE in order to avoid further failed activation retries flushing the ExceptionHistory */
      nRet = DSL_AVX_RequestIdle(pContext, nLine, DSL_FALSE);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode, "DSL_AVX_RequestIdle failed!" DSL_CRLF, nLine);

      DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_REQUIRED);
   }

   DSL_DBG_ExceptionHistoryAddEvent(pContext, nLine, 
      ((DSL_uint32_t)pAck->tFailReason.FwFailCode<<16) | pAck->tFailReason.FailCode, 
      ((DSL_uint32_t)pAck->tFailReason.RxStateOnFail<<16) | pAck->tFailReason.TxStateOnFail,
      0, nActualTrigger);

   DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_OnFailReasonGet: "
      "Error Code 0x%02X, " , nLine, nErrorCode));
   DSL_DEBUG( DSL_DBG_WRN, (pContext,
      "SubError Code 0x%02X, " , nSubErrorCode));
   DSL_DEBUG( DSL_DBG_WRN, (pContext,
      "FW Fail Code 0x%04X" DSL_CRLF , pAck->tFailReason.FwFailCode));
   DSL_DEBUG( DSL_DBG_WRN, (pContext,
      "Debug Codes: 0x%X 0x%04X 0x%04X 0x%X 0x%04X 0x%04X 0x%04X 0x%04X" DSL_CRLF,
      DSL_AVX_PARA32_GET(pAck->tFailReason.TxSymCount),
      pAck->tFailReason.TxStateOnFail,
      pAck->tFailReason.TxSubStateOnFail,
      DSL_AVX_PARA32_GET(pAck->tFailReason.RxSymCount),
      pAck->tFailReason.RxStateOnFail,
      pAck->tFailReason.RxSubStateOnFail,
      pAck->tFailReason.TxSubStateCountOnFail,
      pAck->tFailReason.RxSubStateCountOnFail));

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   DSL_AVX_Eaps2OnFail(pContext, nLine, &bLineRetrain);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (DSL_ENABLE_EAPS == 1)
   /* For the EAPS the fail reason needs to be evaluated.
      When the modem reaches FAIL state it's not ensured, that fail reason is
      already available or can be retrieved right now as the modem may have
      already restarted again.
      Therefore the FSM handling is triggered here. */
   if (_DSLAPI DSL_AVX_EapsFsmStateGet(pContext, nLine) != DSL_EAPS_DISABLED)
   {
      DSL_boolean_t bRestart = DSL_FALSE;

      /* get status and make decision */
      nRet = DSL_AVX_EapsFailDecision(pContext, nLine, &bRestart);
      DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

      if (bRestart)
      {
         /* restart the line.
            EAPS states were already changed, the reconfiguration will be
            triggered by modem state RESET */
         bLineRetrain = DSL_TRUE;
      }
   }
#endif /* #if (DSL_ENABLE_EAPS == 1) */

   if ( bLineRetrain && nActualTrigger == 0 )
   {
      nRet = DSL_AVX_RequestIdle(pContext, nLine, DSL_FALSE);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode, "DSL_AVX_RequestIdle failed!" DSL_CRLF, nLine);
   }

   if (nErrorCode == AVX_E_SHOWTIME_NE)
      DSL_UINT32_SET(DSL_DBS_SHOWTIME_DROP_NE, DSL_SysTimeGet());

   return (errorCode);
}
/**
   This function handles the AVINAX firmware message
   "ACK_Vdsl2FrameDataXX_Get for the VDSL2 framing"

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]
   \param pMsg     Pointer to received AVINAX firmware message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_Error_t DSL_AVX_OnVdsl2FrameData(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDir,
   AVX_AckVdsl2FrameDataUsGet_t const *pMsg)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   /* Will be used by data base access macro and has to be set fixed to '0'
      because the configuration settings in this function are (bearer) channel
      independent  */
   static const DSL_uint8_t nChannel = 0;
   DSL_float_t    Lp, Rp, Dp, q_p;

   Lp = pMsg->tVdsl2FrameData.Lp;
   Rp = pMsg->tVdsl2FrameData.Rp;
   Dp = pMsg->tVdsl2FrameData.Dp;
   q_p  = pMsg->tVdsl2FrameData.Q;

   DSL_DEBUG( DSL_DBG_MSG, (pContext,
      "DSL[%02d][%01d]: Lp = %f, Rp = %f, Dp = %f, q_p = %f" DSL_CRLF,
      nLine, nChannel, Lp, Rp, Dp, q_p));

   /* skip unused bearer channels */
   if (Lp == 0)
      return errorCode;

   if (nDir == DSL_UPSTREAM)
   {
      DSL_UINT16_SET(DSL_DBS_FRAMING_RP_US,   pMsg->tVdsl2FrameData.Rp);
      DSL_UINT16_SET(DSL_DBS_FRAMING_DP_US,   pMsg->tVdsl2FrameData.Dp);
      DSL_UINT16_SET(DSL_DBS_FRAMING_TP_US,   pMsg->tVdsl2FrameData.Tp);
      DSL_UINT16_SET(DSL_DBS_FRAMING_LP_US,   pMsg->tVdsl2FrameData.Lp);
      DSL_UINT16_SET(DSL_DBS_FRAMING_MP_US,   pMsg->tVdsl2FrameData.Mp);
      DSL_UINT16_SET(DSL_DBS_FRAMING_SEQ_US,  pMsg->tVdsl2FrameData.SeqP);
      DSL_UINT16_SET(DSL_DBS_FRAMING_BP_US,   pMsg->tVdsl2FrameData.Bp0);
      DSL_UINT16_SET(DSL_DBS_FRAMING_MSGC_US, pMsg->tVdsl2FrameData.MsgC);
      DSL_UINT16_SET(DSL_DBS_FRAMING_MSGLP_US,0);
      DSL_UINT16_SET(DSL_DBS_FRAMING_IBLOCK_US, pMsg->tVdsl2FrameData.Ip);
      DSL_UINT16_SET(DSL_DBS_FRAMING_NFEC_US,   pMsg->tVdsl2FrameData.NFecp);
      DSL_UINT16_SET(DSL_DBS_FRAMING_OHPOH_US,  pMsg->tVdsl2FrameData.Gp);
      DSL_UINT16_SET(DSL_DBS_FRAMING_QP_US,     pMsg->tVdsl2FrameData.Q);
      DSL_UINT16_SET(DSL_DBS_FRAMING_BPF_US,    pMsg->tVdsl2FrameData.Perb);
      DSL_UINT16_SET(DSL_DBS_FRAMING_IMP_US,    pMsg->tVdsl2FrameData.Dp);

      DSL_UINT32_SET(DSL_DBSC_TOTAL_DATARATE_US,
         1000 * ((pMsg->tVdsl2FrameData.DrpMsw<<16) | pMsg->tVdsl2FrameData.DrpLsw) );
   }
   else
   {
      if ((DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) == (DSL_uint8_t)DSL_RTX_USED) && (pMsg->tLpSelector == AVX_LP1))
      {
         /* take care to use LP1 */
         DSL_UINT16_SET(DSL_DBS_FRAMING_RP_DS,   pMsg->tVdsl2FrameData.Rp);
         DSL_UINT16_SET(DSL_DBS_FRAMING_DP_DS,   pMsg->tVdsl2FrameData.Dp);
         DSL_UINT16_SET(DSL_DBS_FRAMING_TP_DS,   pMsg->tVdsl2FrameData.Tp);
         DSL_UINT16_SET(DSL_DBS_FRAMING_LP_DS,   pMsg->tVdsl2FrameData.Lp);
         DSL_UINT16_SET(DSL_DBS_FRAMING_MP_DS,   pMsg->tVdsl2FrameData.Mp);
         DSL_UINT16_SET(DSL_DBS_FRAMING_SEQ_DS,  pMsg->tVdsl2FrameData.SeqP);
         DSL_UINT16_SET(DSL_DBS_FRAMING_BP_DS,   pMsg->tVdsl2FrameData.Bp0);
         DSL_UINT16_SET(DSL_DBS_FRAMING_IBLOCK_DS, pMsg->tVdsl2FrameData.Ip);
         DSL_UINT16_SET(DSL_DBS_FRAMING_NFEC_DS, pMsg->tVdsl2FrameData.NFecp);
         DSL_UINT16_SET(DSL_DBS_FRAMING_OHPOH_DS, pMsg->tVdsl2FrameData.Gp);
         DSL_UINT16_SET(DSL_DBS_FRAMING_QP_DS,   pMsg->tVdsl2FrameData.Q);
         DSL_UINT32_SET(DSL_DBSC_TOTAL_DATARATE_DS,
            1000 * ((pMsg->tVdsl2FrameData.DrpMsw<<16) | pMsg->tVdsl2FrameData.DrpLsw) );
      }
      else if ((pMsg->tLpSelector == AVX_LP0))
      {
         if (DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) != (DSL_uint8_t)DSL_RTX_USED)
         {
            DSL_UINT16_SET(DSL_DBS_FRAMING_RP_DS,   pMsg->tVdsl2FrameData.Rp);
            DSL_UINT16_SET(DSL_DBS_FRAMING_DP_DS,   pMsg->tVdsl2FrameData.Dp);
            DSL_UINT16_SET(DSL_DBS_FRAMING_TP_DS,   pMsg->tVdsl2FrameData.Tp);
            DSL_UINT16_SET(DSL_DBS_FRAMING_LP_DS,   pMsg->tVdsl2FrameData.Lp);
            DSL_UINT16_SET(DSL_DBS_FRAMING_MP_DS,   pMsg->tVdsl2FrameData.Mp);
            DSL_UINT16_SET(DSL_DBS_FRAMING_SEQ_DS,  pMsg->tVdsl2FrameData.SeqP);
            DSL_UINT16_SET(DSL_DBS_FRAMING_BP_DS,   pMsg->tVdsl2FrameData.Bp0);
            DSL_UINT16_SET(DSL_DBS_FRAMING_IBLOCK_DS, pMsg->tVdsl2FrameData.Ip);
            DSL_UINT16_SET(DSL_DBS_FRAMING_NFEC_DS, pMsg->tVdsl2FrameData.NFecp);
            DSL_UINT16_SET(DSL_DBS_FRAMING_OHPOH_DS, pMsg->tVdsl2FrameData.Gp);
            DSL_UINT16_SET(DSL_DBS_FRAMING_QP_DS,   pMsg->tVdsl2FrameData.Q);
            DSL_UINT16_SET(DSL_DBS_FRAMING_BPF_DS,    pMsg->tVdsl2FrameData.Perb);
            DSL_UINT16_SET(DSL_DBS_FRAMING_IMP_DS,    pMsg->tVdsl2FrameData.Dp);
            DSL_UINT32_SET(DSL_DBSC_TOTAL_DATARATE_DS,
               1000 * ((pMsg->tVdsl2FrameData.DrpMsw<<16) | pMsg->tVdsl2FrameData.DrpLsw) );
         }
      }
      DSL_UINT16_SET(DSL_DBS_FRAMING_MSGC_DS, pMsg->tVdsl2FrameData.MsgC);
      DSL_UINT16_SET(DSL_DBS_FRAMING_MSGLP_DS, 0);
   }

   if(pMsg->tLpSelector == AVX_LP0)
   {
      /* in RTX case take the OHRate from LP0 */
      DSL_uint32_t nOverheadDataRate = 0, nPER = 0, nDivisor = 0, nFloor = 0, nFdmt;

      /* if OpProfile==0 then fdmt=8; end; // we have profile 30a
         if OpProfile>=1 then fdmt=4; end; // not profile 30a

         OR=L*(fdmt*256/257)*(M*G/T)/(M*G/T+R) * 1000;
	   */

      if (DSL_UINT8_GET(DSL_DBS_PROFILES) == DSL_G997_PROFILES_30A)
         nFdmt = 8;
      else
         nFdmt = 4;

      if (pMsg->tVdsl2FrameData.Tp != 0)
         nDivisor = ((pMsg->tVdsl2FrameData.Gp * pMsg->tVdsl2FrameData.Mp)/
            pMsg->tVdsl2FrameData.Tp) + pMsg->tVdsl2FrameData.Rp;

      if (nDivisor != 0)
         nOverheadDataRate = (DSL_uint32_t)
            (((pMsg->tVdsl2FrameData.Mp * pMsg->tVdsl2FrameData.Lp * pMsg->tVdsl2FrameData.Gp *256) /
            (257 * pMsg->tVdsl2FrameData.Tp * nDivisor)) * nFdmt * 1000);

      /*
      PERB=T/M*(M*G/T+R)floor(17000*L(fdmt*256/257)/7880*M/T/(M*G/T+R));
      PER=8*PERB/L/(fdmt*256/257); // 15 <= PER <= 20
      */
      if ((pMsg->tVdsl2FrameData.Tp != 0) && (nDivisor != 0))
         nFloor = (pMsg->tVdsl2FrameData.Mp * pMsg->tVdsl2FrameData.Lp * nFdmt *256 * 17000)/
            (7880*257*pMsg->tVdsl2FrameData.Tp * nDivisor);


      if ((nFloor != 0) && (pMsg->tVdsl2FrameData.Mp != 0))
      {
         nPER = nDivisor * nFloor / pMsg->tVdsl2FrameData.Mp;
      }

      if (nDir == DSL_UPSTREAM)
      {
         DSL_UINT32_SET(DSL_DBSC_PER_US, nPER);
         DSL_UINT32_SET(DSL_DBSC_OVERHEAD_DATARATE_US, nOverheadDataRate);
      }
      else
      {
         DSL_UINT32_SET(DSL_DBSC_PER_DS, nPER);
         DSL_UINT32_SET(DSL_DBSC_OVERHEAD_DATARATE_DS, nOverheadDataRate);
      }
   }

   return (errorCode);
}

/**
   This function sets the NE line failures to the data base.

   \param pContext - Pointer to dsl library context structure, [I]
   \param nLine    - Specifies for which line the function should be applied, [I]
   \param pMsg     - pointer to received message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnLineFailureNeGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtLineFailureNeGet_t const *pAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   /* Will be used by data base access macro and has to be set fixed to '0'
      because the configuration settings in this function are (bearer) channel
      independent  */
   static const DSL_uint8_t nChannel = 0;
   DSL_uint32_t nActLF_NE = 0;
   DSL_uint32_t nActLFM_NE = 0;
   DSL_uint32_t nPreLF_NE = 0;
   DSL_uint32_t nCfgLFM_NE = 0;
   DSL_uint32_t nRelevantBitMask = 0;
   DSL_boolean_t bL3Accepted = DSL_FALSE;
   DSL_boolean_t bState;

#if (DSL_FAILURE_PRIORITIZATION > 0)
   DSL_FailureMask_t nFailureMask;
#endif

#if (DSL_FAILURE_PRIORITIZATION > 0)
   nFailureMask = (DSL_FailureMask_t) DSL_UINT32_GET(DSL_DBS_FAILURE_MASK);
#endif

   /* Get previous state of line failures */
   nPreLF_NE = DSL_UINT32_GET(DSL_DBS_LF_NE);
   /* Get (user) mask configuration for line failure event handling */
   nCfgLFM_NE = DSL_UINT32_GET(DSL_DBL_LFM_NE);

   nRelevantBitMask = DSL_G997_LINEFAILURE_LPR |
                      DSL_G997_LINEFAILURE_LOF |
                      DSL_G997_LINEFAILURE_LOS |
                      DSL_G997_LINEFAILURE_LOM |
                      DSL_G997_LINEFAILURE_LOL |
                      DSL_G997_LINEFAILURE_ESE;

   DSL_FAILUREBIT_SET( LineFailNe, AVX_0700_LOS_NE, nPreLF_NE, DSL_G997_LINEFAILURE_LOS, nActLF_NE, nActLFM_NE);
   DSL_FAILUREBIT_SET( LineFailNe, AVX_0700_LOF_NE, nPreLF_NE, DSL_G997_LINEFAILURE_LOF, nActLF_NE, nActLFM_NE);
   DSL_FAILUREBIT_SET( LineFailNe, AVX_0700_LOM_NE, nPreLF_NE, DSL_G997_LINEFAILURE_LOM, nActLF_NE, nActLFM_NE);
   DSL_FAILUREBIT_SET( LineFailNe, AVX_0700_LOL_NE, nPreLF_NE, DSL_G997_LINEFAILURE_LOL, nActLF_NE, nActLFM_NE);
   DSL_FAILUREBIT_SET( LineFailNe, AVX_0700_ESE_NE, nPreLF_NE, DSL_G997_LINEFAILURE_ESE, nActLF_NE, nActLFM_NE);

#if 0
   /* to decide wether LOLS, LOFS and LPRS shall be counted,
      check if the errors are caused by an L3 shutdown. If so, don't count. */
   errorCode = DSL_AVX_SendMsgRxL3RequestStatusGet(pContext, nLine, &bL3Accepted);
#endif

   /* Write new settings for line failures back to data base. Take care to set
      only failures bits that should be handled by this function (relevant bit
      mask). */
   nActLF_NE &= nRelevantBitMask;
   DSL_UINT32_SET(DSL_DBS_LF_NE, nActLF_NE);

   /* Change values for counters and timestamps if needed for near-end */
   if ((nActLFM_NE != 0) && (bL3Accepted == DSL_FALSE))
   {
      /* Check for DSL_G997_LINEFAILURE_LOF bit has been changed for near-end
         from last failure event */
      if (nActLFM_NE & DSL_G997_LINEFAILURE_LOF)
      {
         bState = (nActLF_NE & DSL_G997_LINEFAILURE_LOF) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU, DSL_G997_LINEFAILURE_LOF, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, NE_LOF, bState);
         if (bState)
            nActLFM_NE &= ~DSL_G997_LINEFAILURE_LOF;
         else
            DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU, DSL_G997_LINEFAILURE_LOF, bState);
#endif
      }
      /* Check for DSL_G997_LINEFAILURE_LOS bit has been changed for near-end
         from last failure event */
      if (nActLFM_NE & DSL_G997_LINEFAILURE_LOS)
      {
         bState = (nActLF_NE & DSL_G997_LINEFAILURE_LOS) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU, DSL_G997_LINEFAILURE_LOS, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, NE_LOS, bState);
         if (bState)
            nActLFM_NE &= ~DSL_G997_LINEFAILURE_LOS;
         else
            DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU, DSL_G997_LINEFAILURE_LOS, bState);
#endif
      }
      /* Check for DSL_G997_LINEFAILURE_LOL bit has been changed for near-end
         from last failure event */
      if (nActLFM_NE & DSL_G997_LINEFAILURE_LOL)
      {
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU,
            DSL_G997_LINEFAILURE_LOL,
            (nActLF_NE & DSL_G997_LINEFAILURE_LOL) ? DSL_TRUE : DSL_FALSE);
      }
      /* Check for DSL_G997_LINEFAILURE_LOM bit has been changed for near-end
         from last failure event */
      if (nActLFM_NE & DSL_G997_LINEFAILURE_LOM)
      {
         bState = (nActLF_NE & DSL_G997_LINEFAILURE_LOM) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU, DSL_G997_LINEFAILURE_LOM, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, NE_LOM, bState);
         if (bState)
            nActLFM_NE &= ~DSL_G997_LINEFAILURE_LOM;
         else
            DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU, DSL_G997_LINEFAILURE_LOM, bState);
#endif
      }
      /* Check for DSL_G997_LINEFAILURE_ESE bit has been changed for near-end
         from last failure event */
      if (nActLFM_NE & DSL_G997_LINEFAILURE_ESE)
      {
         bState = (nActLF_NE & DSL_G997_LINEFAILURE_ESE) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU, DSL_G997_LINEFAILURE_ESE, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, NE_ESE, bState);
         if (bState)
            nActLFM_NE &= ~DSL_G997_LINEFAILURE_ESE;
         else
            DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU, DSL_G997_LINEFAILURE_ESE, bState);
#endif
      }
   }

   if (pContext->pEventCallback != DSL_NULL)
   {
      /* If the line is deactivated or not in showtime the failures should be
         NOT reported autonomously in any case.
      */
      if ((DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC)  ||
         (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_NO_SYNC)  ||
         (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_MELT_PARK)  ||
         (DSL_UINT8_GET(DSL_DBS_DEV_LAST_EXCEPTION) != 0))
      {
         DSL_CB_DATA_LineFailures_t lineFailures;

         /* Do not signal line failure events that are disbaled (masked) by the
            user. */
         nActLFM_NE &= nCfgLFM_NE;

         if (nActLFM_NE != 0)
         {
            lineFailures.nLineFailures = nActLF_NE;
            lineFailures.nMaskLineFailures = nActLFM_NE;
            (void)(pContext->pEventCallback)( pContext,
                                        nLine,
                                        DSL_CHANNEL_NA,
                                        DSL_ACCESSDIR_NA,
                                        DSL_NEAR_END,
                                        DSL_CBI_LINE_FAILURES,
                                        (DSL_CB_DATA_Union_t *)&lineFailures );
         }
      }
   }

#if (DSL_FAILURE_PRIORITIZATION > 0)
   DSL_AVX_FailureEventReset(pContext, nLine, nFailureMask);
#endif

   return errorCode;
}

/**
   This function sets the FE line failures to the data base.

   \param pContext - Pointer to dsl library context structure, [I]
   \param nLine    - Specifies for which line the function should be applied, [I]
   \param pMsg     - pointer to received message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnLineFailureFeGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtLineFailureFeGet_t const *pAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   /* Will be used by data base access macro and has to be set fixed to '0'
      because the configuration settings in this function are (bearer) channel
      independent  */
   static const DSL_uint8_t nChannel = 0;
   DSL_uint32_t nActLF_FE = 0;
   DSL_uint32_t nActLFM_FE = 0;
   DSL_uint32_t nPreLF_FE = 0;
   DSL_uint32_t nCfgLFM_FE = 0;
   DSL_uint32_t nRelevantBitMask = 0;
   DSL_boolean_t bState;

#if (DSL_FAILURE_PRIORITIZATION > 0)
   DSL_FailureMask_t nFailureMask;
#endif

#if (DSL_FAILURE_PRIORITIZATION > 0)
   nFailureMask = (DSL_FailureMask_t) DSL_UINT32_GET(DSL_DBS_FAILURE_MASK);
#endif

   /* Get previous state of line failures */
   nPreLF_FE = DSL_UINT32_GET(DSL_DBS_LF_FE);
   /* Get (user) mask configuration for line failure event handling */
   nCfgLFM_FE = DSL_UINT32_GET(DSL_DBL_LFM_FE);

   nRelevantBitMask = DSL_G997_LINEFAILURE_LPR |
                      DSL_G997_LINEFAILURE_LOF |
                      DSL_G997_LINEFAILURE_LOS |
                      DSL_G997_LINEFAILURE_LOM |
                      DSL_G997_LINEFAILURE_LOL |
                      DSL_G997_LINEFAILURE_ESE;

   DSL_FAILUREBIT_SET( LineFailFe, AVX_0701_LOS_FE, nPreLF_FE, DSL_G997_LINEFAILURE_LOS, nActLF_FE, nActLFM_FE);
   DSL_FAILUREBIT_SET( LineFailFe, AVX_0701_LOM_FE, nPreLF_FE, DSL_G997_LINEFAILURE_LOM, nActLF_FE, nActLFM_FE);
   DSL_FAILUREBIT_SET( LineFailFe, AVX_0701_LOF_FE, nPreLF_FE, DSL_G997_LINEFAILURE_LOF, nActLF_FE, nActLFM_FE);
   DSL_FAILUREBIT_SET( LineFailFe, AVX_0701_ESE_FE, nPreLF_FE, DSL_G997_LINEFAILURE_ESE, nActLF_FE, nActLFM_FE);
   DSL_FAILUREBIT_SET( LineFailFe, AVX_0701_LPR_FE, nPreLF_FE, DSL_G997_LINEFAILURE_LPR, nActLF_FE, nActLFM_FE);

   /* Write new settings for line failures back to data base. Take care to set
      only failures bits that should be handled by this function (relevant bit
      mask). */
   nActLF_FE &= nRelevantBitMask;
   DSL_UINT32_SET(DSL_DBS_LF_FE, nActLF_FE);

   /* Change values for counters and timestamps if needed for far-end */
   if (nActLFM_FE != 0)
   {
      /* Check for DSL_G997_LINEFAILURE_LOF bit has been changed for far-end
         from last failure event */
      if (nActLFM_FE & DSL_G997_LINEFAILURE_LOF)
      {
         bState = (nActLF_FE & DSL_G997_LINEFAILURE_LOF) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_LOF, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, FE_LOF, bState);
         if (bState)
            nActLFM_FE &= DSL_G997_LINEFAILURE_LOF;
         else
           DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_LOF, bState);
#endif
      }
      /* Check for DSL_G997_LINEFAILURE_LOS bit has been changed for near-end
         from last failure event */
      if (nActLFM_FE & DSL_G997_LINEFAILURE_LOS)
      {
         bState = (nActLF_FE & DSL_G997_LINEFAILURE_LOS) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_LOS, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, FE_LOS, bState);
         if (bState)
            nActLFM_FE &= ~DSL_G997_LINEFAILURE_LOS;
         else
            DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_LOS, bState);
#endif
      }
      /* Check for DSL_G997_LINEFAILURE_LPR bit has been changed for near-end
         from last failure event */
      if (nActLFM_FE & DSL_G997_LINEFAILURE_LPR)
      {
         bState = (nActLF_FE & DSL_G997_LINEFAILURE_LPR) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_LPR, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, FE_LPR, bState);
         if (bState)
            nActLFM_FE &= ~DSL_G997_LINEFAILURE_LPR;
         else
            DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_LPR, bState);
#endif
      }
      /* Check for DSL_G997_LINEFAILURE_LOM bit has been changed for near-end
         from last failure event */
      if (nActLFM_FE & DSL_G997_LINEFAILURE_LOM)
      {
         bState = (nActLF_FE & DSL_G997_LINEFAILURE_LOM) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_LOM, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, FE_LOM, bState);
         if (bState)
            nActLFM_FE &= ~DSL_G997_LINEFAILURE_LOM;
         else
            DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_LOM, bState);
#endif
      }
      /* Check for DSL_G997_LINEFAILURE_ESE bit has been changed for near-end
         from last failure event */
      if (nActLFM_FE & DSL_G997_LINEFAILURE_ESE)
      {
         bState = (nActLF_FE & DSL_G997_LINEFAILURE_ESE) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         /* bit has been changed so update timestamp and counters */
         DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_ESE, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, FE_ESE, bState);
         if (bState)
            nActLFM_FE &= ~DSL_G997_LINEFAILURE_ESE;
         else
            DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU, DSL_G997_LINEFAILURE_ESE, bState);
#endif
      }
   }

   if (pContext->pEventCallback != DSL_NULL)
   {
      /* If the line is deactivated or not in showtime the failures should be
         NOT reported autonomously in any case.
      */
      if ((DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC)  ||
         (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_NO_SYNC)  ||
         (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_MELT_PARK)  ||
         (DSL_UINT8_GET(DSL_DBS_DEV_LAST_EXCEPTION) != 0))
      {
         DSL_CB_DATA_LineFailures_t lineFailures;

         /* Do not signal line failure events that are disabled (masked) by the
            user. The firmware does not take care about this topic! */
         nActLFM_FE &= nCfgLFM_FE;

         if (nActLFM_FE != 0)
         {
            lineFailures.nLineFailures = nActLF_FE;
            lineFailures.nMaskLineFailures = nActLFM_FE;
            (void)(pContext->pEventCallback)( pContext,
                                        nLine,
                                        DSL_CHANNEL_NA,
                                        DSL_ACCESSDIR_NA,
                                        DSL_FAR_END,
                                        DSL_CBI_LINE_FAILURES,
                                        (DSL_CB_DATA_Union_t *)&lineFailures );
         }
      }
   }

#if (DSL_FAILURE_PRIORITIZATION > 0)
   DSL_AVX_FailureEventReset(pContext, nLine, nFailureMask);
#endif

   return errorCode;
}

/**
   This function sets the NE data path failures to the data base.

   \param pContext - Pointer to dsl library context structure, [I]
   \param nLine    - Specifies for which line the function should be applied, [I]
   \param pAck     - pointer to received message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnDataPathFailuresNeGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtDataPathFailureNeGet_t const *pAck)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint32_t nActDPF_NE = 0;
   DSL_uint32_t nActDPFM_NE = 0;
   DSL_uint32_t nPreDPF_NE = 0;
   DSL_uint32_t nCfgDPFM_NE = 0;
   DSL_uint32_t nRelevantBitMask = 0;

   DSL_uint32_t actLineState;
   DSL_boolean_t bState;

#if (DSL_FAILURE_PRIORITIZATION > 0)
   DSL_FailureMask_t nFailureMask;
#endif

#if (DSL_FAILURE_PRIORITIZATION > 0)
   nFailureMask = (DSL_FailureMask_t) DSL_UINT32_GET(DSL_DBS_FAILURE_MASK);
#endif

   nPreDPF_NE = DSL_UINT32_GET(DSL_DBSC_DPF_NE);
   nCfgDPFM_NE = DSL_UINT32_GET(DSL_DBC_DPFM_NE);

   nRelevantBitMask = DSL_G997_DATAPATHFAILURE_NCD |
                      DSL_G997_DATAPATHFAILURE_LCD |
                      DSL_G997_DATAPATHFAILURE_OOS |
                      DSL_G997_DATAPATHFAILURE_LPD |
                      DSL_G997_DATAPATHFAILURE_NPD;

   DSL_FAILUREBIT_SET(tTcFail.TcFail, AVX_TC_FAIL_NCD, nPreDPF_NE, DSL_G997_DATAPATHFAILURE_NCD, nActDPF_NE, nActDPFM_NE);
   DSL_FAILUREBIT_SET(tTcFail.TcFail, AVX_TC_FAIL_LCD, nPreDPF_NE, DSL_G997_DATAPATHFAILURE_LCD, nActDPF_NE, nActDPFM_NE);
   DSL_FAILUREBIT_SET(tTcFail.TcFail, AVX_TC_FAIL_NPD, nPreDPF_NE, DSL_G997_DATAPATHFAILURE_NPD, nActDPF_NE, nActDPFM_NE);
   DSL_FAILUREBIT_SET(tTcFail.TcFail, AVX_TC_FAIL_LPD, nPreDPF_NE, DSL_G997_DATAPATHFAILURE_LPD, nActDPF_NE, nActDPFM_NE);

   nActDPF_NE &= nRelevantBitMask;
   DSL_UINT32_SET(DSL_DBSC_DPF_NE, nActDPF_NE);

   actLineState = DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE);

   if (nActDPFM_NE != 0)
   {
      /* Check for DSL_G997_LINEFAILURE_NCD bit has been changed for near-end
         from last failure event */
      if (nActDPFM_NE & DSL_G997_DATAPATHFAILURE_NCD)
      {
         bState = (nActDPF_NE & DSL_G997_DATAPATHFAILURE_NCD) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_LTU, DSL_G997_DATAPATHFAILURE_NCD, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, NE_NCD, bState);
         if (bState)
            nActDPFM_NE &= ~DSL_G997_DATAPATHFAILURE_NCD;
         else
            DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_LTU, DSL_G997_DATAPATHFAILURE_NCD, bState);
#endif
      }

      /* Check for DSL_G997_LINEFAILURE_LCD bit has been changed for near-end
         from last failure event */
      if (nActDPFM_NE & DSL_G997_DATAPATHFAILURE_LCD)
      {
         bState = (nActDPF_NE & DSL_G997_DATAPATHFAILURE_LCD) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_LTU, DSL_G997_DATAPATHFAILURE_LCD, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, NE_LCD, bState);
         if (bState)
            nActDPFM_NE &= ~DSL_G997_DATAPATHFAILURE_LCD;
         else
            DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_LTU, DSL_G997_DATAPATHFAILURE_LCD, bState);
#endif
      }

      /* Check for DSL_G997_LINEFAILURE_NPD bit has been changed for near-end
         from last failure event */
      if (nActDPFM_NE & DSL_G997_DATAPATHFAILURE_NPD)
      {
         bState = (nActDPF_NE & DSL_G997_DATAPATHFAILURE_NPD) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_LTU, DSL_G997_DATAPATHFAILURE_NPD, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, NE_NPD, bState);
         if (bState)
            nActDPFM_NE &= ~DSL_G997_DATAPATHFAILURE_NPD;
         else
            DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_LTU, DSL_G997_DATAPATHFAILURE_NPD, bState);
#endif
      }

      /* Check for DSL_G997_LINEFAILURE_LPD bit has been changed for near-end
         from last failure event */
      if (nActDPFM_NE & DSL_G997_DATAPATHFAILURE_LPD)
      {
         bState = (nActDPF_NE & DSL_G997_DATAPATHFAILURE_LPD) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_LTU, DSL_G997_DATAPATHFAILURE_LPD, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, NE_LPD, bState);
         if (bState)
            nActDPFM_NE &= ~DSL_G997_DATAPATHFAILURE_LPD;
         else
            DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_LTU, DSL_G997_DATAPATHFAILURE_LPD, bState);
#endif
      }
   }

   if (pContext->pEventCallback != DSL_NULL)
   {
      /* If the line is deactivated or not in showtime the failures should be
         NOT reported autonomously in any case.
      */
      if ((actLineState == DSL_LINESTATUS_SHOWTIME_TC_SYNC)  ||
         (actLineState == DSL_LINESTATUS_SHOWTIME_NO_SYNC)  ||
         (actLineState == DSL_LINESTATUS_MELT_PARK)  ||
         (DSL_UINT8_GET(DSL_DBS_DEV_LAST_EXCEPTION) != 0))
      {
         DSL_CB_DATA_DataPathFailures_t dataPathFailures;

         /* Do not signal line failure events that are disbaled (masked) by the
            user. */
         nActDPFM_NE &= nCfgDPFM_NE;

         if (nActDPFM_NE != 0)
         {
            dataPathFailures.nDataPathFailures = nActDPF_NE;
            dataPathFailures.nMaskDataPathFailures = nActDPFM_NE;
            (void) pContext->pEventCallback(pContext,
                     nLine,
                     DSL_CHANNEL_NA,
                     DSL_ACCESSDIR_NA,
                     DSL_NEAR_END,
                     DSL_CBI_DATA_PATH_FAILURES,
                     (DSL_CB_DATA_Union_t *) &dataPathFailures);
         }
      }
   }

#if (DSL_FAILURE_PRIORITIZATION > 0)
   DSL_AVX_FailureEventReset(pContext, nLine, nFailureMask);
#endif

   return errorCode;
}

/**
   This function sets the FE data path failures to the data base.

   \param pContext - Pointer to dsl library context structure, [I]
   \param nLine    - Specifies for which line the function should be applied, [I]
   \param pAck     - pointer to received message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnDataPathFailuresFeGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtDataPathFailureFeGet_t const *pAck)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint32_t nActDPF_FE = 0;
   DSL_uint32_t nActDPFM_FE = 0;
   DSL_uint32_t nPreDPF_FE = 0;
   DSL_uint32_t nCfgDPFM_FE = 0;
   DSL_uint32_t nRelevantBitMask = 0;

   DSL_uint32_t actLineState;
   DSL_boolean_t bState;

#if (DSL_FAILURE_PRIORITIZATION > 0)
   DSL_FailureMask_t nFailureMask;
#endif

#if (DSL_FAILURE_PRIORITIZATION > 0)
   nFailureMask = (DSL_FailureMask_t) DSL_UINT32_GET(DSL_DBS_FAILURE_MASK);
#endif

   nPreDPF_FE = DSL_UINT32_GET(DSL_DBSC_DPF_FE);
   nCfgDPFM_FE = DSL_UINT32_GET(DSL_DBC_DPFM_FE);

   nRelevantBitMask = DSL_G997_DATAPATHFAILURE_NCD |
                      DSL_G997_DATAPATHFAILURE_LCD |
                      DSL_G997_DATAPATHFAILURE_OOS |
                      DSL_G997_DATAPATHFAILURE_LPD |
                      DSL_G997_DATAPATHFAILURE_NPD;

   DSL_FAILUREBIT_SET(tTcFail.TcFail, AVX_TC_FAIL_NCD, nPreDPF_FE, DSL_G997_DATAPATHFAILURE_NCD, nActDPF_FE, nActDPFM_FE);
   DSL_FAILUREBIT_SET(tTcFail.TcFail, AVX_TC_FAIL_LCD, nPreDPF_FE, DSL_G997_DATAPATHFAILURE_LCD, nActDPF_FE, nActDPFM_FE);
   DSL_FAILUREBIT_SET(tTcFail.TcFail, AVX_TC_FAIL_NPD, nPreDPF_FE, DSL_G997_DATAPATHFAILURE_NPD, nActDPF_FE, nActDPFM_FE);
   DSL_FAILUREBIT_SET(tTcFail.TcFail, AVX_TC_FAIL_LPD, nPreDPF_FE, DSL_G997_DATAPATHFAILURE_LPD, nActDPF_FE, nActDPFM_FE);

   nActDPF_FE &= nRelevantBitMask;
   DSL_UINT32_SET(DSL_DBSC_DPF_FE, nActDPF_FE);

   actLineState = DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE);

   if (nActDPFM_FE != 0)
   {
      /* Check for DSL_G997_LIFEFAILURE_NCD bit has been changed for far-end
         from last failure event */
      if (nActDPFM_FE & DSL_G997_DATAPATHFAILURE_NCD)
      {
         bState = (nActDPF_FE & DSL_G997_DATAPATHFAILURE_NCD) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_NTU, DSL_G997_DATAPATHFAILURE_NCD, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, FE_NCD, bState);
         if (bState)
            nActDPFM_FE &= ~DSL_G997_DATAPATHFAILURE_NCD;
         else
            DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_NTU, DSL_G997_DATAPATHFAILURE_NCD, bState);
#endif
      }

      /* Check for DSL_G997_LIFEFAILURE_LCD bit has been changed for far-end
         from last failure event */
      if (nActDPFM_FE & DSL_G997_DATAPATHFAILURE_LCD)
      {
         bState = (nActDPF_FE & DSL_G997_DATAPATHFAILURE_LCD) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_NTU, DSL_G997_DATAPATHFAILURE_LCD, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, FE_LCD, bState);
         if (bState)
            nActDPFM_FE &= ~DSL_G997_DATAPATHFAILURE_LCD;
         else
            DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_NTU, DSL_G997_DATAPATHFAILURE_LCD, bState);
#endif
      }

      /* Check for DSL_G997_LINEFAILURE_NPD bit has been changed for far-end
         from last failure event */
      if (nActDPFM_FE & DSL_G997_DATAPATHFAILURE_NPD)
      {
         bState = (nActDPF_FE & DSL_G997_DATAPATHFAILURE_NPD) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_NTU, DSL_G997_DATAPATHFAILURE_NPD, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, FE_NPD, bState);
         if (bState)
            nActDPFM_FE &= ~DSL_G997_DATAPATHFAILURE_NPD;
         else
            DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_NTU, DSL_G997_DATAPATHFAILURE_NPD, bState);
#endif
      }

      /* Check for DSL_G997_LINEFAILURE_LPD bit has been changed for far-end
         from last failure event */
      if (nActDPFM_FE & DSL_G997_DATAPATHFAILURE_LPD)
      {
         bState = (nActDPF_FE & DSL_G997_DATAPATHFAILURE_LPD) ? DSL_TRUE : DSL_FALSE;
#if (DSL_FAILURE_PRIORITIZATION == 0)
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_NTU, DSL_G997_DATAPATHFAILURE_LPD, bState);
#else
         DSL_FAILURE_MASK_BIT_SET(nFailureMask, FE_LPD, bState);
         if (bState)
            nActDPFM_FE &= ~DSL_G997_DATAPATHFAILURE_LPD;
         else
            DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_NTU, DSL_G997_DATAPATHFAILURE_LPD, bState);
#endif
      }
   }

   if (pContext->pEventCallback != DSL_NULL)
   {
      /* If the line is deactivated or not in showtime the failures should be
         NOT reported autonomously in any case.
      */
      if ((actLineState == DSL_LINESTATUS_SHOWTIME_TC_SYNC)  ||
         (actLineState == DSL_LINESTATUS_SHOWTIME_NO_SYNC)  ||
         (actLineState == DSL_LINESTATUS_MELT_PARK)  ||
         (DSL_UINT8_GET(DSL_DBS_DEV_LAST_EXCEPTION) != 0))
      {
         DSL_CB_DATA_DataPathFailures_t dataPathFailures;

         /* Do not signal line failure events that are disbaled (masked) by the
            user. */
         nActDPFM_FE &= nCfgDPFM_FE;

         if (nActDPFM_FE != 0)
         {
            dataPathFailures.nDataPathFailures = nActDPF_FE;
            dataPathFailures.nMaskDataPathFailures = nActDPFM_FE;
            (void) pContext->pEventCallback(pContext,
                     nLine,
                     DSL_CHANNEL_NA,
                     DSL_ACCESSDIR_NA,
                     DSL_FAR_END,
                     DSL_CBI_DATA_PATH_FAILURES,
                     (DSL_CB_DATA_Union_t *) &dataPathFailures);
         }
      }
   }

#if (DSL_FAILURE_PRIORITIZATION > 0)
   DSL_AVX_FailureEventReset(pContext, nLine, nFailureMask);
#endif

   return errorCode;
}

#ifdef DSL_PM_FW_THRESHOLD_CHECKING
DSL_LOCAL DSL_Error_t DSL_AVX_OnTr1LineCountThreshHit(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtTr1LineCountThreshHit_t const *pAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_OnTr1LineCountThreshHit Timestamp=%d ThreshHitStatus=%04x" DSL_CRLF,
      nLine, pAck->Timestamp, pAck->ThreshHitStatus.LineThreshEvt));

   errorCode = DSL_DEV_LineCountThreshUpdate(pContext, nLine, DSL_NEAR_END,
         pAck->ThreshHitStatus.LineThreshEvt);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_LineCountTreshUpdate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_DEV_LineCountThreshUpdate(pContext, nLine, DSL_FAR_END,
         pAck->ThreshHitStatus.LineThreshEvt);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_LineCountTreshUpdate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OnTr1TcCountThreshHit(
                  DSL_Context_t *pContext,
                  const DSL_uint16_t nLine,
                  AVX_EvtTr1TcCountThreshHit_t const *pAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_OnTr1TcCountThreshHit Timestamp=%d AtmTcNeThreshEvt=%04x "
      "AtmTcFeThreshEvt=%04x PtmTcNeThreshEvt=%04x" DSL_CRLF,
      nLine, pAck->Timestamp,
      pAck->tAtmNeThreshHitStatus.AtmTcNeThreshEvt,
      pAck->tAtmFeThreshHitStatus.AtmTcFeThreshEvt,
      pAck->tPtmNeThreshHitStatus.PtmTcNeThreshEvt));

   errorCode = DSL_DEV_DataPathThreshUpdate(pContext, nLine, DSL_NEAR_END,
         pAck->tAtmNeThreshHitStatus.AtmTcNeThreshEvt,
         pAck->tPtmNeThreshHitStatus.PtmTcNeThreshEvt);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_DataPathThreshUpdate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_DEV_DataPathThreshUpdate(pContext, nLine, DSL_FAR_END,
         pAck->tAtmFeThreshHitStatus.AtmTcFeThreshEvt, 0);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_DataPathThreshUpdate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OnTr1ChCountThreshHit
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_AckTr1ChannelCountThreshHit_t const *pAck
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_OnTr1ChCountThreshHit "
         "Timestamp=%d ThreshHitStatus=%04x" DSL_CRLF,
      nLine, pAck->Timestamp,
      pAck->ThreshHitStatus.ChThreshEvt ));

   errorCode = DSL_DEV_ChannelThreshUpdate(pContext, nLine, DSL_NEAR_END,
         pAck->ThreshHitStatus.ChThreshEvt);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OnTr1ChCountThreshHit failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_DEV_ChannelThreshUpdate(pContext, nLine, DSL_FAR_END,
         pAck->ThreshHitStatus.ChThreshEvt);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_OnTr1ChCountThreshHit failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   return errorCode;
}

#endif

/**
   almost empty now

   \param pContext - Pointer to dsl library context structure, [I]
   \param nLine    - Specifies for which line the function should be applied, [I]
   \param pMsg     - pointer to received message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed

*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnPerformanceCounters(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   const DSL_uint16_t *pMsg)
{

   DSL_PM_CONTEXT(pContext)->bTR1ExpiryEvent[nLine] = DSL_TRUE;

   return DSL_SUCCESS;
}

/**
   This function reset all values within the data base that are not valid
   anymor if the showtime state has been left.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_Error_t DSL_AVX_ResetShowtimeValues(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint8_t nChannel)
{
   DSL_G997_ChannelStatus_t nData;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_int_t i;
   DSL_AccessDir_t nDirection;

   /* stop timing supervisions */
   if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID) != DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_WRN,
         (pContext, "DSL[%02d]: DSL_AVX_ResetShowtimeValues - could "
         "not remove timeout!" DSL_CRLF , nLine ));
   }

   if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_FE_STATUS_TIMEOUT_ID) != DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_WRN,
         (pContext, "DSL[%02d]: DSL_AVX_ResetShowtimeValues - could "
         "not remove timeout!" DSL_CRLF , nLine ));
   }

   if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_FE_STATUS_POLLING_TIMEOUT_ID) != DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_WRN,
         (pContext, "DSL[%02d]: DSL_AVX_ResetShowtimeValues - could "
         "not remove polling timeout!" DSL_CRLF , nLine ));
   }

   if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_FE_SNR_UPDATE_TIMEOUT_ID) != DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_WRN,
         (pContext, "DSL[%02d]: DSL_AVX_ResetShowtimeValues - could "
         "not remove snr polling timeout!" DSL_CRLF , nLine ));
   }
   
   if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_DS_BC_STATUS_TIMEOUT_ID) != DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_WRN,
         (pContext, "DSL[%02d]: DSL_AVX_ResetShowtimeValues - could "
         "not remove DS BC timeout!" DSL_CRLF , nLine ));
   }
   

   memset(&nData, 0, sizeof(nData));
   for (i=0; i<2; i++)
   {
      if (i) nDirection = DSL_DOWNSTREAM;
      else nDirection = DSL_UPSTREAM;

      DSL_AVX_dbGetDataRates(pContext, nLine, nChannel, nDirection, &nData);
      nData.ActualDataRate = 0;
      nData.ActualL2DataRate = 0;
      nData.ActualL0DataRate = 0;
      nData.ActualInterleaveDelay = 0;
      nData.ActualImpulseNoiseProtection = 0;
      nData.ActualImpulseNoiseProtectionNoErasure = 0;
      DSL_AVX_dbSetDataRates(pContext, nLine, nChannel, nDirection, &nData);
   }

   DSL_UINT32_SET(DSL_DBSC_RETX_ACTNDR_DS, 0);
   DSL_UINT16_SET(DSL_DBSC_RETX_ACTINP_REIN_DS, 0);
   DSL_UINT32_SET(DSL_DBSC_RETX_ACTNDR_US, 0);
   DSL_UINT16_SET(DSL_DBSC_RETX_ACTINP_REIN_US, 0);
   DSL_UINT32_SET(DSL_DBSC_RETX_ATTETRU_US, 0);
   DSL_UINT32_SET(DSL_DBSC_RETX_ATTETRU_DS, 0);
   DSL_UINT8_SET(DSL_DBS_RTX_USED_DS, DSL_RTX_UNKNOWN);
   DSL_UINT8_SET(DSL_DBS_RTX_USED_US, DSL_RTX_UNKNOWN);
   DSL_UINT32_SET(DSL_DBSC_RETX_EST_ETR_DS, 0);
   DSL_UINT32_SET(DSL_DBSC_RETX_EST_ETR_US, 0);

   DSL_UINT32_SET(DSL_DBSC_TOTAL_DATARATE_US, 0);
   DSL_UINT32_SET(DSL_DBSC_OVERHEAD_DATARATE_US, 0);
   DSL_UINT32_SET(DSL_DBSC_PER_US, 0);
   DSL_UINT32_SET(DSL_DBSC_TC_LAYER_STATUS_US, DSL_TC_STATUS_ATM);
   DSL_UINT32_SET(DSL_DBSC_INIT_DATARATE_US, 0);

   DSL_UINT32_SET(DSL_DBSC_TOTAL_DATARATE_DS, 0);
   DSL_UINT32_SET(DSL_DBSC_OVERHEAD_DATARATE_DS, 0);
   DSL_UINT32_SET(DSL_DBSC_PER_DS, 0);
   DSL_UINT32_SET(DSL_DBSC_TC_LAYER_STATUS_DS, DSL_TC_STATUS_ATM);
   DSL_UINT32_SET(DSL_DBSC_INIT_DATARATE_DS, 0);
   
   DSL_UINT32_SET(DSL_DBS_ATTNDR_SHOWTIME_US, 0);
   DSL_UINT32_SET(DSL_DBS_ATTNDR_SHOWTIME_DS, 0);
   DSL_INT16_SET(DSL_DBS_SNR_MARGIN_SHOWTIME_DS, 0);
   DSL_INT16_SET(DSL_DBS_SNR_MARGIN_SHOWTIME_US, 0);
   DSL_UINT8_SET(DSL_DBSC_ERASURE_DECODING_DS, 0);
   DSL_UINT8_SET(DSL_DBSC_ERASURE_DECODING_US, 0);
   
   DSL_INT8_SET(DSL_DBS_ACT_DATARATE_LX_STATE, (DSL_int8_t)DSL_G997_PMS_L3);

   /* clear all FE inventory data */
   memset(&(pContext->G997.FeLineInventory[nLine]), 0, sizeof(DSL_G997_LineInventory_t));

   /* LOF and LOL counters shall not count when the line is down
      LTU means near-end here */
   DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_LTU,
            DSL_G997_LINEFAILURE_LOF |
            DSL_G997_LINEFAILURE_LOL |
            DSL_G997_LINEFAILURE_LPR, DSL_FALSE);
   DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, DSL_PM_NTU,
            DSL_G997_LINEFAILURE_LOF |
            DSL_G997_LINEFAILURE_LOL |
            DSL_G997_LINEFAILURE_LPR, DSL_FALSE);

   /* clear ATSE status info */
   DSL_UINT8_SET(DSL_DBS_ATSE_1, 0);
   DSL_UINT8_SET(DSL_DBS_ATSE_2, 0);
   DSL_UINT8_SET(DSL_DBS_ATSE_3, 0);
   DSL_UINT8_SET(DSL_DBS_ATSE_4, 0);
   DSL_UINT8_SET(DSL_DBS_ATSE_5, 0);
   DSL_UINT8_SET(DSL_DBS_ATSE_6, 0);
   DSL_UINT8_SET(DSL_DBS_ATSE_7, 0);
   DSL_UINT8_SET(DSL_DBS_ATSE_8, 0);
   DSL_UINT8_SET(DSL_DBS_ATSE_9, 0);

#if defined(INCLUDE_DSL_DSM) && (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   DSL_UINT8_SET(DSL_DBS_DSM_SUPPORT_STATUS_US, (DSL_uint8_t)DSL_DSM_SUPPORT_NONE);
   DSL_UINT8_SET(DSL_DBS_DSM_SUPPORT_STATUS_DS, (DSL_uint8_t)DSL_DSM_SUPPORT_NONE);
   DSL_UINT8_SET(DSL_DBS_DSM_ACTMODE, DSL_G997_ACTVECTORMODE_OFF);
   DSL_UINT8_SET(DSL_DBS_DSM_ANYVECTORING_STATUS, (DSL_uint8_t)DSL_DSM_ANYVECTORINGSTATUS_OFF);
#endif /* defined(INCLUDE_DSL_DSM) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   DSL_UINT16_SET(DSL_DBS_PMS_TC_OMSG1_OCT_2_3, 0);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_OMSG1_OCT_4_5, 0);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_OMSG1_OCT_6_7, 0);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_OMSG1_OCT_8_9, 0);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_2_3, 0);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_4_5, 0);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_6_7, 0);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_8_9, 0);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_10_11, 0);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_12_13, 0);
   DSL_UINT32_SET(DSL_DBS_OPMS_INFO_MAXDELAY_OCT_DS_0, 0);
   DSL_UINT32_SET(DSL_DBS_OPMS_INFO_MAXDELAY_OCT_DS_1, 0);
   DSL_UINT32_SET(DSL_DBS_OPMS_INFO_MAXDELAY_OCT_US_0, 0);
   DSL_UINT32_SET(DSL_DBS_OPMS_INFO_MAXDELAY_OCT_US_1, 0);

#endif
   DSL_UINT32_SET(DSL_DBS_RTX_AGG_ACHIEVABLE_NDR_NE, 0);
   DSL_UINT32_SET(DSL_DBS_RTX_AGG_ACHIEVABLE_NDR_FE, 0);

   return (errorCode);
}

/**
   This function set the actual power management mode in the data base and also
   handles to set the previous values if necessary.
   If necessary a callback event will be processed to inform the upper layer
   software about data power management state change.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies on which line the message was received, [I]
   \param pData      Includes the the new power management mode, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_dbSetPMMode(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_G997_PowerManagementState_t nPMMode)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_G997_PowerManagementState_t nPrePmMode = (DSL_G997_PowerManagementState_t)0;

   /* Will be used by data base access macro and has to be set fixed to '0'
      because the configuration settings in this function are (bearer) channel
      independent  */
   static const DSL_uint8_t nChannel = 0;

   nPrePmMode = (DSL_G997_PowerManagementState_t)DSL_INT8_GET(DSL_DBS_ACT_PMSTATUS);

   if (nPrePmMode != nPMMode)
   {
      DSL_INT8_SET(DSL_DBS_ACT_PMSTATUS, nPMMode);
      DSL_INT8_SET(DSL_DBS_PRE_PMSTATUS, nPrePmMode);

      /* request the status here when L2 was entered or left,
         but not when Showtime was entered */
      if ( ((nPrePmMode == DSL_G997_PMS_L0) && (nPMMode == DSL_G997_PMS_L2)) ||
           ((nPrePmMode == DSL_G997_PMS_L2) && (nPMMode == DSL_G997_PMS_L0)))
      {
         /* showtime status changed, update status */
         DSL_AVX_AllStatusGet (pContext, nLine);
      }

      /* The L2 fallback detection result shall be reset only if showtime is left  */
      if (nPMMode == DSL_G997_PMS_L3)
      {
         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_L2_HANDLING_FALLBACK_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
               (pContext, "DSL[%02d]: DSL_AVX_dbSetPMMode - could "
               "not remove L2_HANDLING_FALLBACK timeout!" DSL_CRLF, nLine ));
         }
         DSL_UINT8_SET(DSL_DBS_L2_HANDLING_FALLBACK_ENABLED, 0);
      }
      
      if (nPMMode == DSL_G997_PMS_L2)
      {
         /* if L2 is enetered without L2_REJECT ( fallback disabled ) - set L2-mode capability = 1*/
         if ((((DSL_boolean_t)DSL_UINT8_GET(DSL_DBS_L2_HANDLING_FALLBACK_ENABLED) == DSL_FALSE) &&
             (DSL_INT8_GET(DSL_DBL_IFS_L2_AMD4_ENABLE) == 1)) ||
             (DSL_INT8_GET(DSL_DBL_IFS_L2_AMD4_ENABLE) == 2))
         {
            DSL_UINT8_SET(DSL_DBS_L2_AMD4_MODE_USED, 1);
         }
         else
         {
            DSL_UINT8_SET(DSL_DBS_L2_AMD4_MODE_USED, 0);
         }

         /* if a successful L2 is indicated, remove a running fallback timer  */
         if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_L2_HANDLING_FALLBACK_TIMEOUT_ID) != DSL_SUCCESS)
         {
            DSL_DEBUG( DSL_DBG_WRN,
               (pContext, "DSL[%02d]: DSL_AVX_dbSetPMMode - could "
               "not remove L2_HANDLING_FALLBACK timeout!" DSL_CRLF, nLine ));
         }
      }
      
      /* the detection of CPE L2-mode capability shall be done during Showtime.
          It shall start each time leaving L2 state.  */
      if ((nPrePmMode == DSL_G997_PMS_L2) && (nPMMode == DSL_G997_PMS_L0))
      {
         DSL_UINT8_SET(DSL_DBS_L2_HANDLING_FALLBACK_ENABLED, 0);
         
         nRet = DSL_AVX_WriteL2Configuration(pContext, nLine);
         DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
            "Error during L2 Config write!" DSL_CRLF, nLine); 
      }

      /* If callback procedure is enabled inform the upper software layer
         about the new power management state changes */
      if (pContext->pEventCallback != DSL_NULL)
      {
         DSL_boolean_t bSemMask = DSL_FALSE;

         bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_PM_STATE));
         if (bSemMask == DSL_FALSE)
         {
            DSL_CB_DATA_PowerManagementState_t pmMode;

            pmMode.nPowerManagementState = nPMMode;
            pmMode.nPmsFailure = DSL_PMSFAIL_OK;
            pmMode.nPmsSubFailure = DSL_PMSSUBFAIL_OK;

            (void)(pContext->pEventCallback)( (DSL_void_t*)pContext,
                                        nLine,
                                        DSL_CHANNEL_NA,
                                        DSL_ACCESSDIR_NA,
                                        DSL_ATUDIR_NA,
                                        DSL_CBS_LINE_POWERMANAGEMENT_STATE,
                                        (DSL_CB_DATA_Union_t *)&pmMode );
         }
      }
   }

   return (errorCode);
}

/**
   This function triggers to send a specified message which requests data from
   the local device and waits for appropriate answer.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message has to be send, [I]
   \param nMsgID   Specifies the message ID as defined in the AVINAX firmware
                   message specification. It includes the message type and
                   subtype, [I]
   \param nLength  number of bytes of the message payload, [I]
   \param nData    pointer to the message payload data, [I]
   \param nLenAck  available buffer size for received ack, [I]
   \param pDataAck pointer to buffer for receiving ack message, [O]
   \param nArrStrt Array starting index

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed or message ID of acknowledge wrong
*/
DSL_Error_t DSL_AVX_SendMessageArrayIndex(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint32_t nMsgID,
   const DSL_uint16_t nLength,
   const DSL_uint8_t *pData,
   const DSL_uint16_t nLenAck,
   DSL_uint8_t *pDataAck,
   const DSL_uint16_t nArrStrt)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   IOCTL_MEI3_LINE_messageSend_t sMsg;
   DSL_uint16_t errorCodeBuf;

   if (((nMsgID & 0xFFFF) != AVX_CMD_VERSION_INFO_GET) &&
       ((nMsgID & 0xFFFF) != AVX_CMD_DBG_MEM_MAP_MULTIPLE_WRITE))
      DSL_CHECK_LINEACCESS(nLine);

   nRet = DSL_AVX_ApplicabilityCheck (pContext, nLine, nMsgID);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   sMsg.write_msg.msgId          = (DSL_uint16_t)(nMsgID & 0xFFFF);
   sMsg.write_msg.reserved       = 0;
   sMsg.write_msg.offset         = nArrStrt; /* tb filled with external param */
   sMsg.write_msg.paylSize_byte  = nLength;
   sMsg.write_msg.pPayload       = (unsigned short *)pData;
   /* to receive the answer hand over the payload buffer */
   sMsg.ack_msg.pPayload         = (unsigned short *)pDataAck;
   sMsg.ack_msg.msgId = 0;
   sMsg.ack_msg.paylSize_byte    = nLenAck;

   if ((sMsg.ack_msg.pPayload == DSL_NULL) || (sMsg.ack_msg.paylSize_byte == 0))
   {
      sMsg.ack_msg.paylSize_byte    = sizeof(errorCodeBuf);
      sMsg.ack_msg.pPayload         = (unsigned short *)&errorCodeBuf;
   }

   errorCode = DSL_AVX_MsgTransmit(pContext, nLine, DSL_NEAR_END, &sMsg);
   if(errorCode != DSL_SUCCESS)
      return errorCode;

   /* check if received ID was the same as the sent one */
   if (((DSL_uint16_t)(nMsgID & 0xFFFF)) != sMsg.ack_msg.msgId)
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext, "DSL[%02d]: SendMsgIdx: Ack mismatch in MsgID (0x%04X vs 0x%04X expected)!" DSL_CRLF,
         nLine, sMsg.ack_msg.msgId, nMsgID));
      errorCode = DSL_ERR_FUNCTION_WAITING;
      pContext->nErrno = errorCode;
   }

   return errorCode;
}

/**
   This function triggers to send a specified message which requests data from
   the local device and waits for appropriate answer.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message has to be send, [I]
   \param nMsgID   Specifies the message ID as defined in the AVINAX firmware
                   message specification. It includes the message type and
                   subtype, [I]
   \param nLength  number of bytes of the message payload, [I]
   \param nData    pointer to the message payload data, [I]
   \param nLenAck  available buffer size for received ack, [I]
   \param pDataAck pointer to buffer for receiving ack message, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed or message ID of acknowledge wrong
*/
DSL_Error_t DSL_AVX_SendMessage(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint32_t nMsgID,
   const DSL_uint16_t nLength,
   const DSL_uint8_t *pData,
   const DSL_uint16_t nLenAck,
   DSL_uint8_t *pDataAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   IOCTL_MEI3_LINE_messageSend_t sMsg;
   DSL_uint16_t errorCodeBuf;

   if (((nMsgID & 0xFFFF) != AVX_CMD_VERSION_INFO_GET) &&
       ((nMsgID & 0xFFFF) != AVX_CMD_DBG_MEM_MAP_MULTIPLE_WRITE) &&
       ((nMsgID & 0xFFFF) != AVX_CMD_DBG_MEM_MAP_MULTIPLE_READ))
      DSL_CHECK_LINEACCESS(nLine); 

   nRet = DSL_AVX_ApplicabilityCheck (pContext, nLine, nMsgID);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   sMsg.write_msg.msgId          = (DSL_uint16_t)(nMsgID & 0xFFFF);
   sMsg.write_msg.reserved       = 0;
   sMsg.write_msg.offset         = 0; /* tb filled woth external param */
   sMsg.write_msg.paylSize_byte  = nLength;
   sMsg.write_msg.pPayload       = (unsigned short *)pData;
   /* to receive the answer hand over the payload buffer */
   sMsg.ack_msg.pPayload         = (unsigned short *)pDataAck;
   sMsg.ack_msg.msgId = 0;
   sMsg.ack_msg.paylSize_byte    = nLenAck;

   if ((sMsg.ack_msg.pPayload == DSL_NULL) || (sMsg.ack_msg.paylSize_byte == 0))
   {
      sMsg.ack_msg.paylSize_byte    = sizeof(errorCodeBuf);
      sMsg.ack_msg.pPayload         = (unsigned short *)&errorCodeBuf;
   }

   errorCode = DSL_AVX_MsgTransmit(pContext, nLine, DSL_NEAR_END, &sMsg);
   if(errorCode != DSL_SUCCESS)
      return errorCode;

   /* check if received ID was the same as the sent one */
   if (((DSL_uint16_t)(nMsgID & 0xFFFF)) != sMsg.ack_msg.msgId)
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext, "DSL[%02d]: SendMsg: Ack mismatch in MsgID (0x%04X vs 0x%04X expected)!" DSL_CRLF,
         nLine, sMsg.ack_msg.msgId, (nMsgID & 0xFFFF)));
      errorCode = DSL_ERR_FUNCTION_WAITING;
      pContext->nErrno = errorCode;
   }

   return errorCode;
}

/**
   This function triggers to send a specified message which requests data from
   the local device and waits for appropriate answer.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message has to be send, [I]
   \param nMsgID   Specifies the message ID as defined in the AVINAX firmware
                   message specification. It includes the message type and
                   subtype, [I]
   \param nLength  number of bytes of the message payload, [I]
   \param nData    pointer to the message payload data, [I]
   \param nLenAck  available buffer size for received ack, [I]
   \param pDataAck pointer to buffer for receiving ack message, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed or message ID of acknowledge wrong
*/
DSL_Error_t DSL_AVX_SendMessageAndWaitArrayIndex(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint32_t nMsgID,
   const DSL_uint16_t nLength,
   const DSL_uint8_t *pData,
   const DSL_uint16_t nLenAck,
   DSL_uint8_t *pDataAck,
   const DSL_uint16_t nArrStrt)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   IOCTL_MEI3_LINE_messageSend_t sMsg;
   DSL_FctWaiting_t *pFctWait = DSL_NULL;
   DSL_uint16_t errorCodeBuf;

   DSL_FctWaitingGet(pContext, nLine, &pFctWait);

   /* Set processing information for control thread */
   pFctWait->bFctWaiting = DSL_TRUE;
   pFctWait->bDataReceived = DSL_FALSE;
   pFctWait->nLine = nLine;

   nRet = DSL_AVX_ApplicabilityCheck (pContext, nLine, nMsgID);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   sMsg.write_msg.msgId          = (DSL_uint16_t)nMsgID;
   sMsg.write_msg.pPayload       = (unsigned short *)pData;
   sMsg.write_msg.offset         = nArrStrt;

   sMsg.write_msg.paylSize_byte  = nLength;
   /* to receive the answer hand over the payload buffer */
   sMsg.ack_msg.pPayload         = (unsigned short *)pDataAck;

   sMsg.ack_msg.msgId = 0;
   sMsg.write_msg.paylSize_byte  = nLength;
   sMsg.ack_msg.paylSize_byte    = nLenAck;

   if ((sMsg.ack_msg.pPayload == DSL_NULL) || (sMsg.ack_msg.paylSize_byte == 0))
   {
      sMsg.ack_msg.paylSize_byte    = sizeof(errorCodeBuf);
      sMsg.ack_msg.pPayload         = (unsigned short *)&errorCodeBuf;
   }

   errorCode = DSL_AVX_MsgTransmit(pContext, nLine, DSL_NEAR_END, &sMsg);
   if(errorCode != DSL_SUCCESS)
   {
      pFctWait->bFctWaiting = DSL_FALSE;
      pContext->nErrno = errorCode;
      return errorCode;
   }

   /* check if received ID was the same as the sent one */
   if (((DSL_uint16_t)nMsgID) != sMsg.ack_msg.msgId)
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext, "DSL[%02d]: SendMsgIdxW: Ack mismatch in MsgID (0x%04X vs 0x%04X expected)!" DSL_CRLF,
         nLine, sMsg.ack_msg.msgId, nMsgID));
      errorCode = DSL_ERR_FUNCTION_WAITING;
      pContext->nErrno = errorCode;
      pFctWait->bFctWaiting = DSL_FALSE;
   }

   /* Wait for received data with timeout */
   if(DSL_SemaphoreGet(&pFctWait->FuncWaitSem, DSL_FCTWAIT_TIMEOUT) != DSL_SUCCESS)
   {
      /* Timeout! */
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: Timeout during waiting for AVX message" DSL_CRLF, nLine));
      errorCode = DSL_ERR_FUNCTION_WAITING_TIMEOUT;
      pContext->nErrno = errorCode;
   }

   return errorCode;
}


/**
   This function triggers to send a specified message which requests data from
   the local device and waits for appropriate answer.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message has to be send, [I]
   \param nMsgID   Specifies the message ID as defined in the AVINAX firmware
                   message specification. It includes the message type and
                   subtype, [I]
   \param nLength  number of bytes of the message payload, [I]
   \param nData    pointer to the message payload data, [I]
   \param nLenAck  available buffer size for received ack, [I]
   \param pDataAck pointer to buffer for receiving ack message, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed or message ID of acknowledge wrong
*/
DSL_Error_t DSL_AVX_SendMessageAndWait(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint32_t nMsgID,
   const DSL_uint16_t nLength,
   const DSL_uint8_t *pData,
   const DSL_uint16_t nLenAck,
   DSL_uint8_t *pDataAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   IOCTL_MEI3_LINE_messageSend_t sMsg;
   DSL_FctWaiting_t *pFctWait = DSL_NULL;
   DSL_uint16_t errorCodeBuf;

   DSL_FctWaitingGet(pContext, nLine, &pFctWait);

   /* Set processing information for control thread */
   pFctWait->bFctWaiting = DSL_TRUE;
   pFctWait->bDataReceived = DSL_FALSE;
   pFctWait->nLine = nLine;

   nRet = DSL_AVX_ApplicabilityCheck (pContext, nLine, nMsgID);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   sMsg.write_msg.msgId          = (DSL_uint16_t)nMsgID;
   sMsg.write_msg.pPayload       = (unsigned short *)pData;
   sMsg.write_msg.paylSize_byte  = nLength;
   /* to receive the answer hand over the payload buffer */
   sMsg.ack_msg.pPayload         = (unsigned short *)pDataAck;

   sMsg.ack_msg.msgId = 0;
   sMsg.write_msg.paylSize_byte  = nLength;
   sMsg.ack_msg.paylSize_byte    = nLenAck;

   if ((sMsg.ack_msg.pPayload == DSL_NULL) || (sMsg.ack_msg.paylSize_byte == 0))
   {
      sMsg.ack_msg.paylSize_byte    = sizeof(errorCodeBuf);
      sMsg.ack_msg.pPayload         = (unsigned short *)&errorCodeBuf;
   }

   errorCode = DSL_AVX_MsgTransmit(pContext, nLine, DSL_NEAR_END, &sMsg);
   if(errorCode != DSL_SUCCESS)
   {
      pFctWait->bFctWaiting = DSL_FALSE;
      pContext->nErrno = errorCode;
      return errorCode;
   }

   /* check if received ID was the same as the sent one */
   if (((DSL_uint16_t)nMsgID) != sMsg.ack_msg.msgId)
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext, "DSL[%02d]: SendMsgW: Ack mismatch in MsgID (0x%04X vs 0x%04X expected)!" DSL_CRLF,
         nLine, sMsg.ack_msg.msgId, nMsgID));
      errorCode = DSL_ERR_FUNCTION_WAITING;
      pContext->nErrno = errorCode;
      pFctWait->bFctWaiting = DSL_FALSE;
   }

   /* Wait for received data with timeout */
   if(DSL_SemaphoreGet(&pFctWait->FuncWaitSem, DSL_FCTWAIT_TIMEOUT) != DSL_SUCCESS)
   {
      /* Timeout! */
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: Timeout during waiting for AVX message" DSL_CRLF, nLine));
      errorCode = DSL_ERR_FUNCTION_WAITING_TIMEOUT;
      pContext->nErrno = errorCode;
   }

   return errorCode;
}

#if 0
/**
   This function triggers to send a specified message which requests data from
   a remote device and waits for appropriate answer.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message has to be send, [I]
   \param nMsgID   Specifies the message ID as defined in the AVINAX firmware
                   message specification. It includes the message type and
                   subtype, [I]
   \param nLength  number of bytes of the message payload, [I]
   \param nData    pointer to the message payload data, [I]
   \param nLenAck  available buffer size for received ack, [I]
   \param pDataAck pointer to buffer for receiving ack message, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed or message ID of acknowledge wrong
*/
DSL_Error_t DSL_AVX_SendMessageRemote(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint32_t nMsgID,
   const DSL_uint16_t nLength,
   const DSL_uint8_t *pData,
   const DSL_uint16_t nLenAck,
   DSL_uint8_t *pDataAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
#if (INCLUDE_DSL_REMOTE_IF == 1)
   IOCTL_MEI3_LINE_messageSend_t sMsg;
   DSL_uint16_t errorCodeBuf;

   /* FIXME: some checks are different for remote
   nRet = DSL_AVX_ApplicabilityCheck (pContext, nLine, nMsgID);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode); */

   sMsg.write_msg.msgId          = (DSL_uint16_t)nMsgID;
   sMsg.write_msg.pPayload       = (unsigned short *)pData;
   sMsg.write_msg.paylSize_byte  = nLength;
   /* to receive the answer hand over the payload buffer */
   sMsg.ack_msg.pPayload         = (unsigned short *)pDataAck;

   sMsg.ack_msg.msgId = 0;
   sMsg.write_msg.paylSize_byte  = nLength;
   sMsg.ack_msg.paylSize_byte    = nLenAck;

   if ((sMsg.ack_msg.pPayload == DSL_NULL) || (sMsg.ack_msg.paylSize_byte == 0))
   {
      sMsg.ack_msg.paylSize_byte    = sizeof(errorCodeBuf);
      sMsg.ack_msg.pPayload         = (unsigned short *)&errorCodeBuf;
   }

   errorCode = DSL_AVX_MsgTransmit(pContext, nLine, DSL_FAR_END, &sMsg);
   if(errorCode != DSL_SUCCESS)
      return errorCode;

   /* check if received ID was the same as the sent one */
   if (((DSL_uint16_t)nMsgID) != sMsg.ack_msg.msgId)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: SendMsgRem: Ack mismatch in MsgID (0x%04X vs 0x%04X expected)!" DSL_CRLF,
         nLine, sMsg.ack_msg.msgId, nMsgID));
      errorCode = DSL_ERR_FUNCTION_WAITING;
      pContext->nErrno = errorCode;
   }
#endif
   return errorCode;
}
#endif

/**
   This function exchanges a command/acknowledge couple with the driver.
   The return code is checked and several retries might be done, or the
   line might be locked.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message has to be send, [I]
   \param nDirection
                   Near end or far end, [I]
   \param pMsg     pointer to message exchange data, [IO]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed or message ID of acknowledge wrong
*/
DSL_LOCAL DSL_Error_t DSL_AVX_MsgTransmit(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_ATUDir_t nDirection,
   IOCTL_MEI3_LINE_messageSend_t *pMsg)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_uint16_t i, j, nTmpLine;
   DSL_uint16_t nDev = 0;   
   DSL_uint16_t nLength, nLenAck;
   DSL_uint16_t nFwErrorCode = 0;
   DSL_uint32_t nTriggerMask, nRecoveryTrigger = 0;
   /* Will be used by data base access macro and has to be set
      fixed to '0' because the configuration settings in this
      function are (bearer) channel independent  */
   static const DSL_uint8_t nChannel = 0;
   IOCTL_MEI3_exchange_t ex;

   nLength = pMsg->write_msg.paylSize_byte;
   nLenAck = pMsg->ack_msg.paylSize_byte;

   for (i=0; i<3; i++)
   {
      if (i > 0)
         DSL_MSleep(10);
      /* for any retry set the CMD and ACK Buffer length again,
         because the driver is changing these fields to indicate
         the bytes processed */
      pMsg->write_msg.paylSize_byte  = nLength;
      pMsg->write_msg.reserved = (((rand()%254) + 1) & 0x00FF) << 8;
      pMsg->ack_msg.paylSize_byte    = nLenAck;
      ex.pData = pMsg;
      ex.nLength = sizeof(IOCTL_MEI3_LINE_messageSend_t);

      nRet = DSL_AVX_ChRequestMessage(pContext, nLine, nDirection, &ex);
      /* Send and wait for received data */
      if(nRet == DSL_SUCCESS)
      {
         if (pMsg->write_msg.msgId != pMsg->ack_msg.msgId)
         {
            DSL_DEBUG(DSL_DBG_ERR,
               (pContext, "DSL[%02d]: msgId mismatch: writeMsgId=0x%04X != ackMsgId=0x%04X"
                  "on try %d!" DSL_CRLF,
                  nLine, pMsg->write_msg.msgId, pMsg->ack_msg.msgId, i));
            continue;
         }

         if ((pMsg->write_msg.reserved & 0xFF00) != (pMsg->ack_msg.reserved & 0xFF00))
         {
            DSL_DEBUG(DSL_DBG_ERR,
               (pContext, "DSL[%02d]: MsgID=0x%04X Tan mismatch: writeTan=0x%02X != ackTan=0x%02X"
                  "on try %d!" DSL_CRLF,
                  nLine, pMsg->write_msg.msgId, (0x00FF & (pMsg->write_msg.reserved >> 8)), (0x00FF & (pMsg->ack_msg.reserved >> 8)) ,i));
            continue;
         }

         if (pMsg->ack_msg.offset & 0x8000)
         {
            /* ack is not valid */
            if (pMsg->ack_msg.pPayload != DSL_NULL)
            {
               nFwErrorCode = pMsg->ack_msg.pPayload[0];
               /* negative response - retry sending, keep the line alive */
               if ((pMsg->write_msg.msgId == AVX_CMD_OHC_TRANSMIT) && (nFwErrorCode == AVX_FW_LINE_BUSY))
               {
                  DSL_DEBUG(DSL_DBG_WRN,
                     (pContext, "DSL[%02d]: Line Busy for "
                        "MsgID=0x%04X (FwErrorCode=0x%04X) - on try %d! Skipped." DSL_CRLF,
                        nLine, pMsg->write_msg.msgId, nFwErrorCode, i));
                  i = 3;
                  break;
               }

               if ( (nFwErrorCode == AVX_FW_GLOBAL_REQ_PENDING) ||
                    (nFwErrorCode == AVX_FW_SYSIF_REQ_PENDING) ||
                    (nFwErrorCode == AVX_FW_CH_REQ_PENDING) ||
                    (nFwErrorCode == AVX_FW_CH_NON_IDLE) ||
                    /* DSLCOSW-2538: needs to be reworked with FW
                    (nFwErrorCode == AVX_FW_SEMAPHORE_BUSY) ||*/
                    (nFwErrorCode == AVX_FW_LINE_BUSY)
                   )
               {
                  /* currently unavailable, try again */
                  DSL_DEBUG(DSL_DBG_WRN,
                     (pContext, "DSL[%02d]: Line Busy for "
                        "MsgID=0x%04X (FwErrorCode=0x%04X) - on try %d! Retry." DSL_CRLF,
                        nLine, pMsg->write_msg.msgId, nFwErrorCode, i));
                  continue;
               }
               if ( nFwErrorCode == AVX_FW_MSG_UNKNOWN )
               {
                  DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: Msg Denied for "
                        "MsgID=0x%04X (FwErrorCode=0x%04X) - on try %d! Break." DSL_CRLF,
                        nLine, pMsg->write_msg.msgId, nFwErrorCode, i));
                  nRet = DSL_WRN_FIRMWARE_MSG_DENIED;
                  i = 3;
                  break;
               }
               DSL_DEBUG(DSL_DBG_ERR,
                  (pContext, "DSL[%02d]: negative response for "
                     "MsgID=0x%04X (FwErrorCode=0x%04X) - on try %d! Retry." DSL_CRLF,
                     nLine, pMsg->write_msg.msgId, nFwErrorCode, i));
            }
            else
            {
               DSL_DEBUG(DSL_DBG_WRN,
                  (pContext, "DSL[%02d]: negative response for "
                     "MsgID=0x%04X on try %d! Break." DSL_CRLF,
                     nLine, pMsg->write_msg.msgId, i));
               nRet = DSL_WRN_FIRMWARE_MSG_DENIED;
               i = 3;
               break;
            }
         }
         /* msg write ok, exit from loop */
         i=3;
         break;
      }
      else
      {
         if (pMsg->ack_msg.offset & 0x8000 &&
             pMsg->ack_msg.pPayload != DSL_NULL)
         {
            /* FW returned NACK with error code */
            nFwErrorCode = pMsg->ack_msg.pPayload[0];
         }

         /* interpret return code */
         switch(ex.nError)
         {
            case -e_MEI3_ERR_DEVICE_NOT_AVAILABLE:
               /* driver will return this code if hotplug is compiled in */
               /* disable lines to prevent further actions */
               DSL_GET_DEVICE_NUMBER(nLine, nDev);
               for (j=0; j<DSL_LINES_PER_DEVICE; j++)
               {
                  DSL_DEV_GET_LINE_PARAM(nDev, j, nTmpLine);
                  if (nTmpLine == 0xFFFF) continue;
                  _DSLAPI DSL_LineEnabledSet(pContext, nTmpLine, DSL_FALSE);
               }
               DSL_DEBUG(DSL_DBG_ERR,
                  (pContext, "DSL[%02d]: device not available meanwhile sending "
                     "MsgID=0x%04X!" DSL_CRLF,
                     nLine, pMsg->write_msg.msgId));
               nRet = DSL_ERR_MSG_EXCHANGE;
               i = 3;
               break;
            case -e_MEI3_ERR_MAILBOX_TIMEOUT:
               DSL_DEBUG(DSL_DBG_ERR,
                  (pContext, "DSL[%02d]: timeout "
                     "MsgID=0x%04X - on try %d!" DSL_CRLF,
                     nLine, pMsg->write_msg.msgId, i));
               if (i >= 2)
               {
                  nRecoveryTrigger |= DSL_AUTORECOVER_TRIGGER_DEFAULT;
                  nRet = DSL_ERR_MSG_EXCHANGE;
               }
               break;
            case -e_MEI3_ERR_INVAL_STATE:
            case -e_MEI3_ERR_DEV_NO_RESP:
               /* line not available - stop sending, block this line */
               DSL_DEBUG(DSL_DBG_ERR,(pContext,
                  "DSL[%02d]: Config Error or line not available - block!"
                  DSL_CRLF, nLine));

               nRecoveryTrigger |= DSL_AUTORECOVER_TRIGGER_DEFAULT;
               nRet = DSL_ERR_MSG_EXCHANGE;
               i = 3;
               break;

            case -e_MEI3_ERR_OP_FAILED:
               /* MBX busy, try again */
               DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: MBX busy, "
                        "MsgID=0x%04X (Class=0x%08X) - on try %d!" DSL_CRLF,
                        nLine, pMsg->write_msg.msgId, nFwErrorCode, i));
               if (i >= 2)
               {
                  pContext->DeviceContext.DumpBuffer[nLine].nMemoryDumpTrigger = DSL_DBG_TRIGGER_MAILBOX_BUSY;
                  nRecoveryTrigger |= DSL_AUTORECOVER_TRIGGER_DEFAULT;
                  nRet = DSL_ERR_MSG_EXCHANGE;
               }
               break;

            case -e_MEI3_ERR_MSG_PARAM:
               /* wrong message content */
               DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: wrong params, "
                        "MsgID=0x%04X (Class=0x%08X)!" DSL_CRLF,
                        nLine, pMsg->write_msg.msgId, nFwErrorCode));
               if (i >= 2)
               {
                  nRecoveryTrigger |= DSL_AUTORECOVER_TRIGGER_DEFAULT;
                  nRet = DSL_ERR_MSG_EXCHANGE;
               }
               break;

            default:
               /* try it again */
               if (nFwErrorCode == 0xFFFF)
               {
                  DSL_DEBUG(DSL_DBG_WRN,
                     (pContext, "DSL[%02d]: message not yet supported, "
                        "MsgID=0x%04X (Class=0x%08X) - on try %d!" DSL_CRLF,
                        nLine, pMsg->write_msg.msgId, nFwErrorCode, i));
                  nRet = DSL_WRN_FIRMWARE_MSG_DENIED;
                  i = 3;
                  break;
               }
               else
               {
                  /* Write Error! */
                  DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: error[%d] WRITE AVINAX Cmd"
                        "(MsgID=0x%04X, Class=0x%08X) on try %d!" DSL_CRLF,
                        nLine, nRet, pMsg->write_msg.msgId,
                        nFwErrorCode, i));
               }

               if (i >= 2)
               {
                  /* no ACK after 3 retries, assume mailbox dead */
                  nRecoveryTrigger |= DSL_AUTORECOVER_TRIGGER_DEFAULT;
                  pContext->DeviceContext.DumpBuffer[nLine].nMemoryDumpTrigger = DSL_DBG_TRIGGER_MAILBOX_BUSY;
               }

               nRet = DSL_ERR_FUNCTION_WAITING_TIMEOUT;
               break;
         }     /* switch(pMsg->ictl.retCode) {...} */
      }
   }

   if(nRet != DSL_SUCCESS)
   {
      /* Error - Line not available */
      DSL_DEBUG((nRecoveryTrigger ? DSL_DBG_ERR : DSL_DBG_WRN),
         (pContext, "DSL[%02d]: Error for send CMD MsgID=0x%04X, Recovery Trigger 0x%X!" DSL_CRLF,
         nLine, pMsg->write_msg.msgId, nRecoveryTrigger));

      nTriggerMask = DSL_UINT32_GET(DSL_DBI_AUTORECOVER_TRIGGERMASK);
      nRecoveryTrigger &= nTriggerMask;

      /* block the line and try a recovery later */
      if (nRecoveryTrigger)
      {
         DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_REQUIRED);
         DSL_DBG_ExceptionHistoryAddTrigger(pContext, nLine, nRecoveryTrigger);
      }

      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
   }

   return errorCode;
}

#if 0 /* using only in EVT_PMD_TESTPARAMSGET which is commented now */
/**
   This function copies the received data to the structure \ref DSL_FctWaiting_t.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message has to be send, [I]
   \param pMsg    - Pointer to message data, [I]
   \param nSize   - total byte count of the message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_WaitingMessageCopyData(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t const *pMsg,
   const DSL_uint16_t nSize)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_FctWaiting_t *pFctWait = DSL_NULL;
   DSL_int_t nLength=0;

   /* Set pointer to function waiting structure that includes the actual
      settings for the messages that has to be processed here */
   DSL_FctWaitingGet(pContext, nLine, &pFctWait);
   nLength = nSize;
   if (nLength<=0)
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext, "DSL[%02d]: DSL_AVX_WaitingMessageCopyData - Length <= 0 !!" DSL_CRLF,
         nLine));
      pContext->nErrno = DSL_ERR_FUNCTION_WAITING;
      errorCode = pContext->nErrno;
      pFctWait->bDataReceived = DSL_FALSE;
      DSL_AVX_FUNCWAITING_UNLOCK();
      return (errorCode);
   }

   /* Copies the data from the firmware message to the message buffer included
      within the function waiting structure */
   memcpy(&pFctWait->nData[0], pMsg, nLength);

   /* release the waiting semaphore */
   pFctWait->bDataReceived = DSL_TRUE;
   DSL_AVX_FUNCWAITING_UNLOCK();

   return (errorCode);
}
#endif

/**
   This function gets all relevant Near End status information right
   when Steady State was entered.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies on which line the message was received, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_AllStatusGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_AVX_LineStatus_t lineStatus;

   DSL_CHECK_CTX_POINTER(pContext);

   nRet = DSL_AVX_XtseStatusGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during XTSE Status Get!" DSL_CRLF, nLine);

   /* some of the LineStatus Data is stored in the DB */
   nRet = DSL_AVX_SendMsgLineStatus(pContext, nLine, DSL_UPSTREAM, &lineStatus);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Line Status US Get!" DSL_CRLF, nLine);

   /* some of the LineStatus Data is stored in the DB */
   nRet = DSL_AVX_SendMsgLineStatus(pContext, nLine, DSL_DOWNSTREAM, &lineStatus);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Line Status DS Get!" DSL_CRLF, nLine);

   /* request the current Rate and delay
      do this after the framing parameters because from here the callback for
      data rate change will be issued which reports INP and DELAY also*/
   nRet = DSL_AVX_BearerChannelStatusGet(pContext, nLine, 0, DSL_DOWNSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Channel Status DS Get!" DSL_CRLF, nLine);

   nRet = DSL_AVX_BearerChannelStatusGet(pContext, nLine, 0, DSL_UPSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Channel Status US Get!" DSL_CRLF, nLine);

   nRet = DSL_AVX_SendMsgTestParamsAuxGet(pContext, nLine, DSL_UPSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Measurement Time US Get!" DSL_CRLF, nLine);

   /* request FE vendor info and inventory  */
   nRet = DSL_AVX_InventoryGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Inventory Get!" DSL_CRLF, nLine);

   /* get the FE capabilities */
   nRet = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Hs FE Caps Get!" DSL_CRLF, nLine);

   /* Retrieve RA mode */
   nRet = DSL_AVX_SendMsgRaModeGet(pContext, nLine, DSL_DOWNSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during ACT-RA-MODE DS Get!" DSL_CRLF, nLine);

   nRet = DSL_AVX_SendMsgRaModeGet(pContext, nLine, DSL_UPSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during ACT-RA-MODE US Get!" DSL_CRLF, nLine);

   /* not for ADSL-only mode */
   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      nRet = DSL_AVX_SendMsgStandardInfoFeVdsl2Get(pContext, nLine);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error during FE VTSE Get!" DSL_CRLF, nLine);
   }

   return (DSL_SUCCESS);
}

/**
   This function gets all relevant status information after
   a successfull Rate Adaptation procedure.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies on which line the message was received, [I]
   \param nDirection Upstream or Downstream, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_AllSraStatusGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;

   /* request the current Rate and delay
      do this after the framing parameters because from here the callback for
      data rate change will be issued which reports INP and DELAY also*/
   nRet = DSL_AVX_BearerChannelStatusGet(pContext, nLine, 0, nDirection);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Channel Status Get!" DSL_CRLF, nLine);

   return (DSL_SUCCESS);
}

/**
   This function gets all relevant status information after
   a successfull bitswap procedure.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies on which line the message was received, [I]
   \param nDirection Upstream or Downstream, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_AllBitswapStatusGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_AVX_LineStatus_t nLineSatusData;
#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
   DSL_DEV_PsdDslMode_t nDslDevMode = DSL_DEV_XDSL_MODE_FIRST;
   static const DSL_uint8_t nChannel = 0;
#endif /* defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1) */

   nRet = DSL_AVX_SendMsgLineStatus(pContext, nLine, nDirection, &nLineSatusData);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Line Status Get!" DSL_CRLF, nLine);

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
   errorCode = DSL_G997_DslModeFromXtseGet(pContext, nLine, &nDslDevMode);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, 
         ", Error during dsl mode from xtse get (%d)!" DSL_CRLF, errorCode));
      return errorCode;
   }

   if ( (DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF )
   {
#if defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1)
      if (!((DSL_uint16_t) DSL_UINT16_GET(DSL_DBS_OPDATA_FREEZE) & DSL_OPDATA_TRG_FREEZE_L2))
#endif /* defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1) */
      {
         /* get carrier load for DS/US */
         if ( nDirection == DSL_UPSTREAM )
         {
            errorCode = DSL_G997_DEV_BitAllocationNSCGet(pContext, 
               nLine, nDirection, DSL_AVX_CARRIER_DATA_GET(nLine, BitAllocation, US));
            if ( errorCode != DSL_SUCCESS )
            {
               DSL_DEBUG (DSL_DBG_MSG, (pContext, 
                  ", Error during carrier load US get (%d)!" DSL_CRLF, errorCode));
            }
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, BitAllocation, US, DSL_TRUE);
         }
         else
         {
            errorCode = DSL_G997_DEV_BitAllocationNSCGet(pContext, 
               nLine, nDirection, DSL_AVX_CARRIER_DATA_GET(nLine, BitAllocation, DS));
            if ( errorCode != DSL_SUCCESS )
            {
               DSL_DEBUG (DSL_DBG_MSG, (pContext, 
                  ", Error during carrier load DS get (%d)!" DSL_CRLF, errorCode));
            }
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, BitAllocation, DS, DSL_TRUE);
         }

         if (( nDirection == DSL_UPSTREAM ) || ( nDslDevMode != DSL_DEV_XDSL_MODE_LAST ))
         {
            /* get carrier gain for DS/US */
            if ( nDirection == DSL_UPSTREAM )
            {
               errorCode = DSL_G997_DEV_GainNSCGet(pContext, 
                  nLine, nDirection, DSL_AVX_CARRIER_DATA_GET(nLine, GainNSC, US));
               if ( errorCode != DSL_SUCCESS )
               {
                  DSL_DEBUG (DSL_DBG_MSG, (pContext, 
                     ", Error during carrier gain US get (%d)!" DSL_CRLF, errorCode));
               }
               DSL_AVX_CARRIER_DATA_VALID_SET(nLine, GainNSC, US, DSL_TRUE);
            }
            else
            {
               errorCode = DSL_G997_DEV_GainNSCGet(pContext, 
                  nLine, nDirection, DSL_AVX_CARRIER_DATA_GET(nLine, GainNSC, DS));
               if ( errorCode != DSL_SUCCESS )
               {
                  DSL_DEBUG (DSL_DBG_MSG, (pContext, 
                     ", Error during carrier gain DS get (%d)!" DSL_CRLF, errorCode));
               }
               DSL_AVX_CARRIER_DATA_VALID_SET(nLine, GainNSC, DS, DSL_TRUE);
            }
         }
      }
   }
#endif /* defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

   return (DSL_SUCCESS);
}

/**
   This function gets all relevant status information right
   when Fail State was entered.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies on which line the message was received, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_AllFailStatusGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS,
               nRet = DSL_SUCCESS;

   /* request Operation State (DSL-mode, Annex...) */
   nRet = DSL_AVX_XtseStatusGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during XTSE Status Get!" DSL_CRLF, nLine);

      nRet = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Hs FE Caps Get!" DSL_CRLF, nLine);

   return (DSL_SUCCESS);
}

/**
   This function gets all relevant status information
   when "Diagnostic mode completed" was entered.
   In this state near end as well as fsar end data is available.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies on which line the message was received, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_AllDeltStatusGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS,
               nRet = DSL_SUCCESS;

   if(DSL_DeltLineDataAlloc(pContext, nLine) == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: failed to allocate/reset params entry!" DSL_CRLF, nLine));
      return (DSL_ERROR);
   }

   /* some of the LineStatus Data is stored in the DB */
   nRet = DSL_AVX_SendMsgLineStatus(pContext, nLine, DSL_UPSTREAM, DSL_NULL);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Line Status US Get!" DSL_CRLF, nLine);

   /* some of the LineStatus Data is stored in the DB */
   nRet = DSL_AVX_SendMsgLineStatus(pContext, nLine, DSL_DOWNSTREAM, DSL_NULL);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Line Status DS Get!" DSL_CRLF, nLine);

   nRet = DSL_AVX_SendMsgTestParamsAuxGet(pContext, nLine, DSL_UPSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during DELT US data Get!" DSL_CRLF, nLine);

   nRet = DSL_AVX_SendMsgTestParamsAuxGet(pContext, nLine, DSL_DOWNSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during DELT DS data Get!" DSL_CRLF, nLine);

   nRet = DSL_AVX_XtseStatusGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during XTSE Status Get!" DSL_CRLF, nLine);

   /* FE inventory is not exchanged during DELT */

   return (DSL_SUCCESS);
}

/**
   This function gets all relevant Far End status information right
   when Steady State was entered.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies on which line the message was received, [I]
   \param nChannel   Specifies for which bearer channel the function will
                     apply, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_AllStatusFeGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS,
               nRet = DSL_SUCCESS;
   DSL_uint8_t nChannel = 0;
   DSL_AVX_LineStatus_t lineStatus;

   DSL_CHECK_CTX_POINTER(pContext);

   /* request only far end information here */
   /* some of the LineStatus Data is stored in the DB */
   nRet = DSL_AVX_SendMsgLineStatus(pContext, nLine, DSL_DOWNSTREAM, &lineStatus);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Line Status DS Get!" DSL_CRLF, nLine);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   /* Since ATTNDR could be updated in SendMsgLineStatus - recalculate ATTETR */
   nRet = DSL_AVX_RtxActEtruCalculate(pContext, nLine, DSL_DOWNSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during RTX ETRU DS calculation!" DSL_CRLF, nLine);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

   nRet = DSL_AVX_SendMsgTestParamsAuxGet(pContext, nLine, DSL_DOWNSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Measurement Time DS Get!" DSL_CRLF, nLine);

   /* request FE vendor info and inventory  */
   nRet = DSL_AVX_InventoryGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Inventory Get!" DSL_CRLF, nLine);

   /* not for ADSL-only mode */
   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      nRet = DSL_AVX_SendMsgStandardInfoFeVdsl2Get(pContext, nLine);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error during FE VTSE Get!" DSL_CRLF, nLine);
   }

   /* if retransmission in DS direction is active ETR (DataRate) and ActDelay
    are FE parameters retreived via OHC; refresh DS BC status also in IFEC operation */
   nRet = DSL_AVX_BearerChannelStatusGet(pContext, nLine, 0, DSL_DOWNSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Channel Status DS Get!" DSL_CRLF, nLine);
   DSL_UINT8_SET(DSL_DBS_RTX_MINEFTR_AVAILABLE, 1);

   /* give the "Inventory Available" Event if requested */
   if (pContext->pEventCallback != DSL_NULL)
   {
      DSL_boolean_t bSemMask = DSL_FALSE;

      bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_CPE_INVENTORY_AVAILABLE));
      if (bSemMask == DSL_FALSE)
      {
         DSL_CB_DATA_CpeInventoryAvailable_t nCbData;

         memset(&nCbData, 0, sizeof(nCbData));
         (void)(pContext->pEventCallback)( pContext,
                                     nLine,
                                     DSL_CHANNEL_NA,
                                     DSL_ACCESSDIR_NA,
                                     DSL_ATUDIR_NA,
                                     DSL_CBS_CPE_INVENTORY_AVAILABLE,
                                     (DSL_CB_DATA_Union_t *)&nCbData );

         DSL_DEBUG( DSL_DBG_WRN, (pContext,
            "DSL[%02d]: CPE inventory information available!" DSL_CRLF , nLine));
      }
   }

   /* PMSF status polling is no longer required since L2 rejects are indicated by event */

   return (DSL_SUCCESS);
}

/**
   This routine handles a timeout that occured.

   \param pContext   DSL library context
   \param nDevice    Specifies for which listIdx (device) the timeout has been
                     occurred, [I]
   \param nLine      Specifies for which line the function will apply, [I]
   \param nEventType Include information on which timeout has been occured.
                     The possible values are defined by
                     \ref DSL_TimeoutEvent_t, [I]
   \param nTimeoutID Includes the timeout element id. This unique value
                     identifies the timeout event and might be compared to
                     a stored value returned from \ref DSL_Timeout_AddEvent, [I]

   \return
   - DSL_Success Timeout event handled successfully
   - DSL_Error Error during handling of timeout event
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnTimeoutEvent(
   DSL_Context_t *pContext,
   DSL_uint16_t nDevice,
   DSL_uint16_t nLine,
   DSL_int_t nEventType,
   DSL_ulong_t nTimeoutID)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   /* Will be used by data base access macro and has to be set
      fixed to '0' because the configuration settings in this
      function are (bearer) channel independent  */
   static const DSL_uint8_t nChannel = 0;
#if (INCLUDE_RESTART == 1) && (DSL_LINES_PER_DEVICE == 1)
   DSL_uint32_t nTriggerMask;
   DSL_boolean_t bAutoRecoverEnabled;
#endif

   DSL_DEBUG(DSL_DBG_MSG,(pContext, "DSL: DSL_AVX_OnTimeoutEvent: nLine=%d, "
      "nEventType=%d, nTimeoutID=0x%08lX" DSL_CRLF ,
      (DSL_int_t)nLine, nEventType, nTimeoutID));

   switch (nEventType)
   {
   case DSL_TIMEOUTEVENT_API_INIT:
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "(API_INIT)" DSL_CRLF));
      DSL_AVX_OnTimeoutEvent_ApiInit(pContext);
      break;

   case DSL_TIMEOUTEVENT_NONRECOVERY:
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "(NONRECOVERY)" DSL_CRLF));
      DSL_UINT8_SET(DSL_DBDS_AUTORECOVER_COUNT, 0);
      DSL_ULONG_SET(DSL_DBDS_AUTORECOVER_TIMEOUT_ID, 0);
      break;

   case DSL_TIMEOUTEVENT_LINE_INIT:
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "(LINE_INIT)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_LINIT_TIMEOUT_ID, 0);
      DSL_AVX_HandleLinitValue(pContext, nLine, LINIT_NO_PEER_XTU, LINIT_SUB_NONE, DSL_FALSE);
      break;

   case DSL_TIMEOUTEVENT_FE_STATUS:
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "(FE_STATUS)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_FE_STATUS_TIMEOUT_ID, 0);
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "DSL[%02d]: after %d Sec in showtime ask far end data" DSL_CRLF ,
         nLine, DSL_DEV_TIMEOUT_FE_STATUS));
      DSL_AVX_AllStatusFeGet(pContext, nLine);
      /* TBD: actions of DSL_AVX_OnFeStatusAvailable are also done in
         DSL_AVX_OnDeltInventoryAvailable */
      DSL_AVX_OnFeStatusAvailable(pContext, nLine);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      {
         DSL_Eaps2States_t nEaps2States = DSL_EAPS2_DISABLED;
         
         nEaps2States = DSL_AVX_Eaps2FsmStateGet(pContext, nLine);
         if (( nEaps2States == DSL_EAPS2_FINISHED ) || ( nEaps2States == DSL_EAPS2_RETRAIN ))
         {
            DSL_UINT8_SET(DSL_DBS_EAPS2_FW_FAIL_COUNT, 0);
            DSL_UINT8_SET(DSL_DBS_EAPS2_FAIL_COUNT, 0);
         }
      }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
      break;

   case DSL_TIMEOUTEVENT_DELT_FE_STATUS:
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "(DELT_FE_STATUS)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID, 0);
      DSL_AVX_DeltFeRepeat(pContext, nLine);
      break;

#if (DSL_DEV_TIMEOUT_FE_SNR_UPDATE > 0)
   case DSL_TIMEOUTEVENT_FE_SNR_UPDATE:
      {
         DSL_deltLineData_t *pLineData = DSL_NULL;
         DSL_deltDirectionData_t *pDirData = DSL_NULL;
         DSL_uint32_t nCurrentState;

         DSL_ULONG_SET(DSL_DBS_FE_SNR_UPDATE_TIMEOUT_ID, 0);

         nCurrentState = DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE);
         if ((nCurrentState == DSL_LINESTATUS_SHOWTIME_TC_SYNC) ||
             (nCurrentState == DSL_LINESTATUS_SHOWTIME_NO_SYNC) ||
             (nCurrentState == DSL_LINESTATUS_MELT_PARK))
         {
            pLineData = DSL_DeltLineDataGet(pContext, nLine);
            if (pLineData)
            {
               DSL_DEBUG(DSL_DBG_MSG,(pContext, "(FE_SNR_UPDATE)" DSL_CRLF));
               pLineData->nLastMsgId   =  DSL_OHC_TESTPARAM_ID_SNR | DSL_OHC_SINGLE_REQUEST;
               pDirData = _DSLAPI DSL_DeltDirectionDataGet(pContext, nLine, DSL_DOWNSTREAM);
               if (pDirData == DSL_NULL)
               {
                  DSL_DEBUG(DSL_DBG_ERR, (pContext,
                     "DSL[%02d]: there is no DELT data element for this line!" DSL_CRLF,
                     nLine));
                  return (DSL_ERROR);
               }
               pDirData->rSNR.nCurrDataSize = 0;

               nRet = DSL_AVX_DeltArrayParamsQuery(pContext, nLine, 0, AVX_MAX_TESTPARAMS_BLOCK-1);
               DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
                  "Error during FE DELT data update!" DSL_CRLF, nLine);

               /* restart 30sec timer to update SNR data */
               DSL_TimerDB_Add(pContext, nLine,
                               DSL_DBS_FE_SNR_UPDATE_TIMEOUT_ID,
                               DSL_TIMEOUTEVENT_FE_SNR_UPDATE,
                               DSL_DEV_TIMEOUT_FE_SNR_UPDATE * DSL_TIMEOUT_FACTOR);
            }
            else
            {
               DSL_ULONG_SET(DSL_DBS_FE_SNR_UPDATE_TIMEOUT_ID, 0);
               DSL_DEBUG(DSL_DBG_ERR,(pContext, "DSL[%02d]: no delt poiner for SNR data (FE_SNR_UPDATE)" DSL_CRLF, nLine));
            }
         }
         else
         {
            DSL_ULONG_SET(DSL_DBS_FE_SNR_UPDATE_TIMEOUT_ID, 0);
         }
      }
      break;
#endif /* (DSL_DEV_TIMEOUT_FE_SNR_UPDATE > 0) */

   case DSL_TIMEOUTEVENT_FE_STATUS_POLLING:
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "(FE_STATUS_POLLING)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_FE_STATUS_POLLING_TIMEOUT_ID, 0);
      /* PMSF status polling is no longer required since L2 rejects are indicated by event */
      break;

#if (INCLUDE_RESET_RETRIES == 1)
   case DSL_TIMEOUTEVENT_RESET:
      {
#ifdef INCLUDE_DSL_API_AVINAX_MELT
         DSL_Error_t meltIdle;
#endif
         DSL_ULONG_SET(DSL_DBS_RESET_TIMEOUT_ID, 0);
         /* timer is set inside DSL_AVX_SendMsgModemStateSet */
         DSL_DEBUG(DSL_DBG_MSG,(pContext, "(RESET)" DSL_CRLF));
#ifdef INCLUDE_DSL_API_AVINAX_MELT
         meltIdle = DSL_MELT_LineIdle(pContext->pMELT_Ctx, nLine);
         if ((meltIdle == DSL_SUCCESS) ||
             (((DSL_MELT_Priority_t) DSL_UINT8_GET(DSL_DBL_MELT_PRIORITY)) == DSL_MELT_PRIORITY_DSL_TRAINING))
#endif /* INCLUDE_DSL_API_AVINAX_MELT */
         {
            nRet = DSL_AVX_SendMsgModemStateSet(pContext, nLine, AVX_FORCE_IDLE_MASK);
            DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_FALSE, errorCode,
               "Error during FSM state set!" DSL_CRLF, nLine);
         }
#ifdef INCLUDE_DSL_API_AVINAX_MELT
         else
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: TIMEOUTEVENT_RESET: MELT was activated, "
               "and EPS2 statemachine is interrupted! "
               "(meltIdle=%d, MELT_PRIORITY=%d)" DSL_CRLF,
            nLine, meltIdle, DSL_UINT8_GET(DSL_DBL_MELT_PRIORITY)));
         }
#endif /* INCLUDE_DSL_API_AVINAX_MELT */
      }
      break;
#endif /* (INCLUDE_RESET_RETRIES == 1) */

#if defined(INCLUDE_DSL_BND_EFM)
   case DSL_TIMEOUTEVENT_PAF_RATE_CHECK:
      {
         DSL_uint16_t nArrayIdx;

         nRet = DSL_BND_GroupIdByLineGet(pContext, nLine, &nArrayIdx);
         DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

         DSL_ULONG_ASET(DSL_DBGAS_PAF_RATE_TIMEOUT_ID, 0);

         nRet = DSL_AVX_BND_FsmOnTimer(pContext, nArrayIdx);
         DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
      }
      break;
#endif /* defined(INCLUDE_DSL_BND_EFM) */

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
   case DSL_TIMEOUTEVENT_OPDATA_GET:
      {
         DSL_G997_PowerManagementState_t nPwrMntState = 
            (DSL_G997_PowerManagementState_t) DSL_INT8_GET(DSL_DBS_ACT_PMSTATUS);

         DSL_DEBUG(DSL_DBG_MSG,(pContext, "(OPDATA_GET)" DSL_CRLF));
         DSL_ULONG_SET(DSL_DBS_OPDATA_GET_TIMEOUT_ID, 0);

         if (( nPwrMntState != DSL_G997_PMS_L0 ) && ( nPwrMntState != DSL_G997_PMS_L2 )) break;

         DSL_AVX_OnTimeoutEvent_OpDataGet(pContext, nLine, (nPwrMntState==DSL_G997_PMS_L0)?DSL_OPDATA_TYPE_SHOWTIME_L0:DSL_OPDATA_TYPE_SHOWTIME_L2);

         /* restart timer for reading the "loop diagnostics" values */
         DSL_TimerDB_Restart(pContext, nLine,
                             DSL_DBS_OPDATA_GET_TIMEOUT_ID,
                             DSL_TIMEOUTEVENT_OPDATA_GET,
                             10 * DSL_TIMEOUT_FACTOR);
      }
      break;
#endif /* #defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

#ifdef DSL_DELAYED_CALLBACK_ENABLED
   case DSL_TIMEOUTEVENT_CALLBACK:
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "(CALLBACK)" DSL_CRLF));
      DSL_AVX_OnDelayedCallbackEvent(pContext, nLine, nTimeoutID);
      break;
#endif

#if (DSL_FAILURE_PRIORITIZATION > 0)
   case DSL_TIMEOUTEVENT_FAILURE:
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "(FAILURE)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_FAILURE_TIMEOUT_ID, 0);
      DSL_AVX_OnFailureEvent(pContext, nLine, nTimeoutID);
      break;
#endif

#if (DSL_PM_DELAYED_REF_TIME == 1)
   case DSL_TIMEOUTEVENT_DSL_DBS_PM_DELAYED_REF_TIME:
      DSL_ULONG_SET(DSL_DBDS_PM_DELAYED_REF_TIME_TIMEOUT_ID, 0);

      /* Save adjustmet system time and real time to be set */
      DSL_PM_CONTEXT(pContext)->nAdjustTime = DSL_PM_CONTEXT(pContext)->nAdjustTimeDelayed;

      DSL_PM_CONTEXT(pContext)->nRefTimeInSec.nCurrTimeInSec =
         DSL_PM_CONTEXT(pContext)->nRefTimeInSecDelayed;

      /* store this corrected time as last checkpoint of tick task
         to avoid interval breaks on time corrections */
      DSL_PM_CONTEXT(pContext)->nLastSysTime = DSL_PM_GET_ADJUSTED_SYS_TIME();
      break;
#endif

   case DSL_TIMEOUTEVENT_L2_HANDLING_FALLBACK:
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "(DSL_TIMEOUTEVENT_L2_HANDLING_FALLBACK)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_L2_HANDLING_FALLBACK_TIMEOUT_ID, 0);
      DSL_UINT8_SET(DSL_DBS_L2_HANDLING_FALLBACK_ENABLED, 1);
      if ( (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC ) &&
         (DSL_CalcLpMin1(pContext, nLine) < 1024) )
      {
         nRet = DSL_AVX_WriteL2Configuration(pContext, nLine);
         DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
            "Error during L2 Config write!" DSL_CRLF, nLine);
         /* check if after a time period of 10 s L2 state is reached.
            If not do parameter configuration according G.992.3 Amd4*/
         DSL_TimerDB_Add(pContext, nLine,
                     DSL_DBS_L2_FALLBACK_TO_AMD4_TIMEOUT_ID,
                     DSL_TIMEOUTEVENT_L2_FALLBACK_TO_AMD4,
                     DSL_DEV_TIMEOUT_L2_FALLBACK_TO_AMD4 * DSL_TIMEOUT_FACTOR);

      }   
      break;

   case DSL_TIMEOUTEVENT_L2_FALLBACK_TO_AMD4:
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "(DSL_TIMEOUTEVENT_L2_FALLBACK_TO_AMD4)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_L2_FALLBACK_TO_AMD4_TIMEOUT_ID, 0);

      if ((DSL_INT8_GET(DSL_DBS_ACT_PMSTATUS) != DSL_G997_PMS_L2) &&
          (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC ))
      {
         /*If L2 is not reached do parameter configuration according G.992.3 Amd4 */
         DSL_UINT8_SET(DSL_DBS_L2_HANDLING_FALLBACK_ENABLED, 0);
         nRet = DSL_AVX_WriteL2Configuration(pContext, nLine);
         DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
             "Error during L2 Config write!" DSL_CRLF, nLine);
      }
      break;


   case DSL_TIMEOUTEVENT_L2_CONFIGURATION_DELAY:
      DSL_DEBUG(DSL_DBG_MSG,(pContext, "(DSL_TIMEOUTEVENT_L2_CONFIGURATION_DELAY)" DSL_CRLF));

      DSL_ULONG_SET(DSL_DBS_L2_CONFIGURATION_DELAY_TIMEOUT_ID, 0);

      DSL_UINT8_SET(DSL_DBS_L2_HANDLING_FALLBACK_ENABLED, 0);
      if ( DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC )
      {
         /* if line is in showtime and L2 is configured, enable it */
         DSL_AVX_SendMsgModemFsmOptionsSet(pContext, nLine);
         
         if ( DSL_IsL2Feasible(pContext, nLine) == DSL_TRUE )
         {
            nRet = DSL_AVX_WriteL2Configuration(pContext, nLine);
            DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
               "Error during L2 Config write!" DSL_CRLF, nLine); 
         }
      }   
      break;

   case DSL_TIMEOUTEVENT_LINE_STATE_MONITORING:
      {
         DSL_uint16_t nDev = 0;
         DSL_GET_DEVICE_NUMBER(nLine, nDev);

         DSL_ULONG_SET(DSL_TIMEOUTEVENT_LINE_STATE_MONITORING_ID, 0);

         DSL_DeviceStatusSet(pContext, nDev, DSL_DEVSTATE_RECOVERY_REQUIRED);
         DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_REQUIRED);
         DSL_DBG_ExceptionHistoryAddTrigger(pContext, nLine, DSL_AUTORECOVER_TRIGGER_LINE_STATE_FREEZE);

         DSL_DEBUG( DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_TIMEOUTEVENT_LINE_STATE_MONITORING timer: initiate recovery for device %d, line %d" DSL_CRLF ,
            nLine, nDev, nLine));

#ifdef INCLUDE_DSL_DBG_TEST_LINE_STATE_MONITORING
         DSL_UINT8_SET(DSL_DBS_LINE_STATE_FREEZE_ENABLE, 0);
         DSL_UINT32_SET(DSL_DBS_LINE_STATE_TO_FREEZE, 0);
#endif
      }
      break; 

   case DSL_TIMEOUTEVENT_NE_SNR_WOVN_UPDATE:
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "(NE_SNR_WOVN_UPDATE)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_NE_SNR_WOVN_UPDATE_TIMEOUT_ID, 0);

      if (DSL_CHECK_LINE_SHOWTIME(nLine))
      {
         DSL_AVX_SnrWoVnUsQuery(pContext, nLine);
         DSL_AVX_SnrWoVnUsQueryRestartTimer(pContext, nLine);
      }
      break;

   case DSL_TIMEOUTEVENT_POWERSAVE_ENABLE:
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "(POWERSAVE_ENABLE)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBDS_POWERSAVE_ENABLE_TIMEOUT_ID, 0);
      DSL_AVX_PowerSavingL3Toggle(pContext, nLine, DSL_TRUE);
      break;
   
   case DSL_TIMEOUTEVENT_ERROR_GENERATION:
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "(ERROR_GENERATION)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_ERROR_GENERATION_TIMEOUT_ID, 0);
   
      nRet = DSL_AVX_SendMsgTxErrorControl(pContext, nLine, nChannel, DSL_TRUE, DSL_FALSE);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
   
      break;
   
   case DSL_TIMEOUTEVENT_DS_BC_STATUS:
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "(DS_BC_STATUS)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_DS_BC_STATUS_TIMEOUT_ID, 0);

      DSL_AVX_OnTimeoutEvent_DsBCStatus(pContext, nLine);
      
      break;
#ifdef INCLUDE_DSL_BND
   case DSL_TIMEOUTEVENT_BND_TRAFFIC_CHECK:
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "(BND_TRAFFIC_CHECK)" DSL_CRLF));
      DSL_ULONG_SET(DSL_DBS_BND_TRAFFIC_CHECK_TIMEOUT_ID, 0);
      
      DSL_AVX_BND_FsmOnTrafficCheckTimer(pContext, nLine);

      break;
#endif
   default:
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: Unknown nEventType (%d)" DSL_CRLF , nEventType));
      break;
   }

   return (errorCode);
}

/**
   This routine handles a DSL API initialization timeout.

   \param pContext DSL library context

   \return
   - DSL_Success Timeout event handled successfully
   - DSL_Error Error during handling of timeout event
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnTimeoutEvent_ApiInit(
   DSL_Context_t *pContext)
{
   DSL_DeviceContext_t *pDevCtx = &pContext->DeviceContext;
   DSL_uint32_t nDevMask = 0;

   pDevCtx->Init.nTimeoutID[0] = 0;

   if (pContext->pEventCallback != DSL_NULL)
   {
      /* Will be used by data base access macro and has to be set
         fixed to '0' because the configuration settings in this
         function are (bearer) channel independent  */
      static const DSL_uint8_t nChannel = 0;
      static const DSL_uint16_t nLine = 0;
      DSL_boolean_t bSemMask = DSL_FALSE;

      DSL_SemaphoreGet(&pDevCtx->Init.LineInitSemaphore, 0xFFFFFFFF);

      /* Set new device mask in common device context for later usage */
      nDevMask = pDevCtx->Init.nDeviceInitMask;
      DSL_DeviceMaskSet(pContext, nDevMask);

      DSL_DEBUG_NOLINE( DSL_DBG_WRN, (pContext,
         "DSL[--]: Initialization timed out (nDeviceMask=0x%08X)!" DSL_CRLF ,
         nDevMask));

      bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBI_SEM_INIT_READY));
      if (bSemMask == DSL_FALSE)
      {
         DSL_CB_DATA_InitReadyStatus_t nCbData;

         memset(&nCbData, 0, sizeof(nCbData));

         nCbData.nInitReadyStatus.nDeviceMask = nDevMask;
         nCbData.nInitReadyStatus.nDeviceMaskLast = pDevCtx->Init.nDeviceRecoveryMaskLast;
         memcpy(nCbData.nInitReadyStatus.nLineMask,
               pDevCtx->Init.nLineInitSuccessMask,
               sizeof(pDevCtx->Init.nLineInitSuccessMask));

         (void)(pContext->pEventCallback)( pContext,
                                     0,
                                     DSL_CHANNEL_NA,
                                     DSL_ACCESSDIR_NA,
                                     DSL_ATUDIR_NA,
                                     DSL_CBS_INIT_READY,
                                     (DSL_CB_DATA_Union_t *)&nCbData );

      }
      DSL_SemaphoreSet(&pDevCtx->Init.LineInitSemaphore);
   }

   return (DSL_SUCCESS);
}

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_OnTimeoutEvent_OpDataGet(
   DSL_Context_t *pContext, 
   const DSL_uint16_t nLine, 
   const DSL_OpDataType_t nOpDataType)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_AVX_LineStatus_t nLineSatusData;
   AVX_AckBearerChStatusUsGet_t sAck;
   static const DSL_uint8_t nChannel = 0;
   DSL_DEV_PsdDslMode_t nDslDevMode = DSL_DEV_XDSL_MODE_FIRST;
   DSL_boolean_t bAdsl1 = DSL_FALSE;

#if defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1)
   if ((DSL_uint16_t) DSL_UINT16_GET(DSL_DBS_OPDATA_FREEZE) & DSL_OPDATA_TRG_FREEZE_ALL)
   {
      /* freeze the operational data - do not collect anything */
      return DSL_SUCCESS;
   }
#endif /* defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1) */

   if (( nOpDataType != DSL_OPDATA_TYPE_SHOWTIME_L0 ) && ( nOpDataType != DSL_OPDATA_TYPE_SHOWTIME_L2 ))
   {
      /* Request Current Operational Mode
         Data will be stored in DB */
      errorCode = DSL_AVX_SendMsgVtseStatusGet(pContext, nLine);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during VTSE Status Get (%d)!" DSL_CRLF, errorCode));
      }
   }

   if ((DSL_UINT8_GET(DSL_DBS_ATSE_1)) || (DSL_UINT8_GET(DSL_DBS_ATSE_2)))
      bAdsl1 = DSL_TRUE;

   errorCode = DSL_G997_DslModeFromXtseGet(pContext, nLine, &nDslDevMode);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during dsl mode from xtse get (%d)!" DSL_CRLF, errorCode));
      return errorCode;
   }

   /* Get DS line status: SNR, LATN, SATN, ATTNDR, ACTATP, ACTPSD, ActLineRate
      Note: only some of the LineStatus Data is stored in the DB */
   errorCode = DSL_AVX_SendMsgLineStatus(pContext, nLine, DSL_DOWNSTREAM, &nLineSatusData);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during Line Status DS Get (%d)!" DSL_CRLF, errorCode));
   }
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   /* Since ATTNDR could be updated in SendMsgLineStatus - recalculate ATTETR */
   errorCode = DSL_AVX_RtxActEtruCalculate(pContext, nLine, DSL_DOWNSTREAM);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, ",Error during RTX ETRU DS calculation! (%d)" DSL_CRLF, errorCode));
   }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

   /* Get US line status: SNR, LATN, SATN, ATTNDR, ACTATP, ACTPSD, ActLineRate
      Note: only some of the LineStatus Data is stored in the DB */
   errorCode = DSL_AVX_SendMsgLineStatus(pContext, nLine, DSL_UPSTREAM, &nLineSatusData);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during Line Status DS Get (%d)!" DSL_CRLF, errorCode));
   }

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)

   errorCode = DSL_AVX_RtxActEtruCalculate(pContext, nLine, DSL_UPSTREAM);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, ",Error during RTX ETRU US calculation! (%d)" DSL_CRLF, errorCode));
   }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

   errorCode = DSL_AVX_SendMsgLineStatusPerBandGet (pContext, nLine, DSL_UPSTREAM);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during Line Status US Get (%d)!" DSL_CRLF, errorCode));
   }

   errorCode = DSL_AVX_SendMsgLineStatusPerBandGet (pContext, nLine, DSL_DOWNSTREAM);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during Line Status DS Get (%d)!" DSL_CRLF, errorCode));
   }

   /* Get FE inventory: SerialNumber, SystemVendorID, VersionNumber
      (SelfTestResult are not currently receving from FW).
      Data will be stored into pContext->G997.FeLineInventory structure */
   errorCode = DSL_AVX_InventoryGet(pContext, nLine);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during Fe inventory get (%d)!" DSL_CRLF, errorCode));
   }

   errorCode = DSL_AVX_SendMsgLastTxState(pContext, nLine);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during Last Tx Status Get (%d)!" DSL_CRLF, errorCode));
   }

   if (nDslDevMode == DSL_DEV_VDSL2)
   {
      errorCode = DSL_AVX_SendMsgUpboKl0Get (pContext, nLine);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during Upbo Kl0 Get (%d)!" DSL_CRLF, errorCode));
      }

      errorCode = DSL_AVX_SendMsgPboAelemStatusGet (pContext, nLine);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during Pbo Aelem Status Get (%d)!" DSL_CRLF, errorCode));
      }
   }

   if (( nOpDataType != DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS) && (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2)))
   {
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      errorCode = DSL_AVX_SendMsgUpboKl0Get(pContext, nLine);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during Upbo Kl0 Get (%d)!" DSL_CRLF, errorCode));
      }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

      errorCode = DSL_AVX_SendMsgStandardInfoFeVdsl2Get(pContext, nLine);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG (DSL_DBG_ERR, (pContext, ", Error during FE VTSE Get (%d)!" DSL_CRLF, errorCode));
      }
   }

   if (( nOpDataType != DSL_OPDATA_TYPE_SHOWTIME_L0 ) && ( nOpDataType != DSL_OPDATA_TYPE_SHOWTIME_L2 ))
   {
      /* Get FE inventory: ATSECapabilities.
         Data will be stored into pContext->G997.FeLineInventory structure */
      errorCode = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during Fe hs caps. get (%d)!" DSL_CRLF, errorCode));
      }

      /* Get NE inventory: ATSECapabilities, SerialNumber, SystemVendorID,
         VersionNumber (SelfTestResult are not currently receving from FW).
         Data will be stored into pContext->G997.NeLineInventory structure */
      errorCode = DSL_AVX_SendMsgVersionInfoGet(pContext, nLine);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during NE inventory get (%d)!" DSL_CRLF, errorCode));
      }
   }

   if ( nOpDataType != DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS)
   {
      /* Get DS bearier channel parameters: ActualDataRate, ActualInterleaveDelay,
         ActualImpulseNoiseProtection
         Data will be stored into DB */
      if (DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) == (DSL_uint8_t)DSL_RTX_USED)
      {
         errorCode =  DSL_AVX_SendMsgBearerChSRtxGet(pContext, nLine, DSL_DOWNSTREAM);
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during BearerChS Rtx Get (%d)!" DSL_CRLF, errorCode));
         }
      }
      /* FS4 FW provides RTX ACTNDR in ACK_Bearer_Ch_Status_DS_Get (Net Data Rate parameter) 
      - send Bearer_Ch_Status_DS_Get always (in RTX & non-RTX) */
      errorCode = DSL_AVX_SendMsgBearerChSGet(pContext, nLine, DSL_DOWNSTREAM, &sAck);
      if (errorCode == DSL_SUCCESS)
      {
         errorCode = DSL_AVX_OnBearerChsGet (pContext, nLine, DSL_DOWNSTREAM, &sAck);
      }
      else
      {
         DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during DS bearer ch get (%d)!" DSL_CRLF, errorCode));
      }

      /* Get US bearier channel parameters: ActualDataRate, ActualInterleaveDelay,
         ActualImpulseNoiseProtection
         Data will be stored into DB */
      errorCode = DSL_AVX_SendMsgBearerChSGet(pContext, nLine, DSL_UPSTREAM, &sAck);
      if (errorCode == DSL_SUCCESS)
      {
         errorCode = DSL_AVX_OnBearerChsGet (pContext, nLine, DSL_UPSTREAM, &sAck);
      }
      else
      {
         DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during US bearer ch get (%d)!" DSL_CRLF, errorCode));
      }
   }

   /* Update bit loading for the higest frequency calculation on getting line into showtime */
   if (( nOpDataType == DSL_OPDATA_TYPE_INIT )
#if defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1)
        && !((DSL_uint16_t) DSL_UINT16_GET(DSL_DBS_OPDATA_FREEZE) & DSL_OPDATA_TRG_FREEZE_L2)
#endif /* defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1) */
      )
   {
      /* get carrier load for DS/US */
      errorCode = DSL_G997_DEV_BitAllocationNSCGet(pContext, nLine, DSL_DOWNSTREAM, 
                     DSL_AVX_CARRIER_DATA_GET(nLine, BitAllocation, DS));
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier load DS get (%d)!" DSL_CRLF, errorCode));
      }

      /* allow to retrieve this only if carrier data acq mode enabled */
      if ((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF)
      {
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, BitAllocation, DS, DSL_TRUE);
      }

      errorCode = DSL_G997_DEV_BitAllocationNSCGet(pContext, nLine, DSL_UPSTREAM, 
                     DSL_AVX_CARRIER_DATA_GET(nLine, BitAllocation, US));
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier load US get (%d)!" DSL_CRLF, errorCode));
      }

      /* allow to retrieve this only if carrier data acq mode enabled */
      if ((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF)
      {
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, BitAllocation, US, DSL_TRUE);
      }
   }

   if (((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF) || ( nOpDataType == DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS ))
   {
      if (( nOpDataType == DSL_OPDATA_TYPE_INIT )
#if defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1)
           && !((DSL_uint16_t) DSL_UINT16_GET(DSL_DBS_OPDATA_FREEZE) & DSL_OPDATA_TRG_FREEZE_L2)
#endif /* defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1) */
         )
      {
         /* get carrier gain for DS/US */
         errorCode = DSL_G997_DEV_GainNSCGet(pContext, nLine, DSL_DOWNSTREAM, 
                        DSL_AVX_CARRIER_DATA_GET(nLine, GainNSC, DS));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier gain DS get (%d)!" DSL_CRLF, errorCode));
         }
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, GainNSC, DS, DSL_TRUE);

         errorCode = DSL_G997_DEV_GainNSCGet(pContext, nLine, DSL_UPSTREAM, 
                        DSL_AVX_CARRIER_DATA_GET(nLine, GainNSC, US));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier gain US get (%d)!" DSL_CRLF, errorCode));
         }
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, GainNSC, US, DSL_TRUE);
      }

      /* get carrier hlin for DS/US */
      if ( nOpDataType == DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS )
      {
         errorCode = DSL_G997_DEV_DeltHlinGet(pContext, nLine, DSL_DOWNSTREAM, 
                        DSL_AVX_CARRIER_DATA_GET(nLine, DeltHlin, DS));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier hlin DS get (%d)!" DSL_CRLF, errorCode));
         }
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlin, DS, DSL_TRUE);

         errorCode = DSL_G997_DEV_DeltHlinGet(pContext, nLine, DSL_UPSTREAM, 
                        DSL_AVX_CARRIER_DATA_GET(nLine, DeltHlin, US));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier hlin US get (%d)!" DSL_CRLF, errorCode));
         }
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlin, US, DSL_TRUE);
      }

      /* get carrier tssi, hlog, qln for DS/US */
      if (( nOpDataType == DSL_OPDATA_TYPE_INIT ) || ( nOpDataType == DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS ))
      {
         errorCode = DSL_G997_DEV_TransmitSpectrumShapingGet(pContext, nLine, DSL_UPSTREAM, nDslDevMode, 
                        DSL_AVX_CARRIER_DATA_GET(nLine, Tss, US));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier tss US get (%d)!" DSL_CRLF, errorCode));
         }
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, Tss, US, DSL_TRUE);

         if (! bAdsl1)
         {
            errorCode = DSL_G997_DEV_DeltHlogGet(pContext, nLine, DSL_UPSTREAM, 
                           DSL_AVX_CARRIER_DATA_GET(nLine, DeltHlog, US));
            if ( errorCode != DSL_SUCCESS )
            {
               DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier hlog US get (%d)!" DSL_CRLF, errorCode));
            }
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlog, US, DSL_TRUE);

            errorCode = DSL_G997_DEV_DeltQLNGet(pContext, nLine, DSL_UPSTREAM, 
                           DSL_AVX_CARRIER_DATA_GET(nLine, DeltQln, US));
            if ( errorCode != DSL_SUCCESS )
            {
               DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier qln US get (%d)!" DSL_CRLF, errorCode));
            }
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltQln, US, DSL_TRUE);
         }

         if (( nDslDevMode == DSL_DEV_ADSL2 ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_PLUS ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_ANNEX_L ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_ANNEX_J ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_PLUS_ANNEX_J ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_ANNEX_M ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_PLUS_ANNEX_M ) ||
             ( nDslDevMode == DSL_DEV_VDSL2 ) )
         {
            errorCode = DSL_G997_DEV_TransmitSpectrumShapingGet(pContext, nLine, DSL_DOWNSTREAM, nDslDevMode, 
                           DSL_AVX_CARRIER_DATA_GET(nLine, Tss, DS));
            if ( errorCode != DSL_SUCCESS )
            {
               DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier tss DS get (%d)!" DSL_CRLF, errorCode));
            }
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, Tss, DS, DSL_TRUE);

            if ( nOpDataType == DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS )
            {
               errorCode = DSL_G997_DEV_DeltHlogGet(pContext, nLine, DSL_DOWNSTREAM, 
                              DSL_AVX_CARRIER_DATA_GET(nLine, DeltHlog, DS));
               if ( errorCode != DSL_SUCCESS )
               {
                  DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier hlog DS get (%d)!" DSL_CRLF, errorCode));
               }
               DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlog, DS, DSL_TRUE);

               errorCode = DSL_G997_DEV_DeltQLNGet(pContext, nLine, DSL_DOWNSTREAM, 
                              DSL_AVX_CARRIER_DATA_GET(nLine, DeltQln, DS));
               if ( errorCode != DSL_SUCCESS )
               {
                  DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier qln DS get (%d)!" DSL_CRLF, errorCode));
               }
               DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltQln, DS, DSL_TRUE);
            }
         }
      }

      /* get carrier snr for DS/US */
      if (( nOpDataType == DSL_OPDATA_TYPE_INIT ) ||
          ( nOpDataType == DSL_OPDATA_TYPE_SHOWTIME_L0 ) ||
          ( nOpDataType == DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS ))
      {
         errorCode = DSL_G997_DEV_DeltSNRGet(pContext, nLine, DSL_UPSTREAM, 
                        DSL_AVX_CARRIER_DATA_GET(nLine, DeltSnr, US));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier snr US get (%d)!" DSL_CRLF, errorCode));
         }
         DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltSnr, US, DSL_TRUE);

         if ((( nDslDevMode == DSL_DEV_ADSL2 ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_PLUS ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_ANNEX_L ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_ANNEX_J ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_PLUS_ANNEX_J ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_ANNEX_M ) ||
             ( nDslDevMode == DSL_DEV_ADSL2_PLUS_ANNEX_M ) ||
             ( nDslDevMode == DSL_DEV_VDSL2 ) ) &&
             ( nOpDataType == DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS ))
         {
            errorCode = DSL_G997_DEV_DeltSNRGet(pContext, nLine, DSL_DOWNSTREAM, 
                           DSL_AVX_CARRIER_DATA_GET(nLine, DeltSnr, DS));
            if ( errorCode != DSL_SUCCESS )
            {
               DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier snr DS get (%d)!" DSL_CRLF, errorCode));
            }
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltSnr, DS, DSL_TRUE);
         }
      }

      if ((nOpDataType == DSL_OPDATA_TYPE_INIT) || (nOpDataType == DSL_OPDATA_TYPE_LOOP_DIAGNOSTICS))
      {
         /* get carrier Tx PSD for US */
         errorCode = DSL_DEV_MedleyReferencePsdNSCGet(pContext, nLine, DSL_UPSTREAM, 
                        DSL_AVX_CARRIER_DATA_GET(nLine, TxPsd, US));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier Tx Psd US get (%d)!" DSL_CRLF, errorCode));
         }
         else
         {
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, TxPsd, US, DSL_TRUE);
         }

         /* get carrier Tx PSD for DS */
         errorCode = DSL_DEV_MedleyReferencePsdNSCGet(pContext, nLine, DSL_DOWNSTREAM, 
                        DSL_AVX_CARRIER_DATA_GET(nLine, TxPsd, DS));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier Tx Psd DS get (%d)!" DSL_CRLF, errorCode));
         }
         else
         {
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, TxPsd, DS, DSL_TRUE);
         }
      }
   }

   return (errorCode);
}
#endif /* #defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

/**
   This routine handles a DS BearerChannel status update timeout
   after DS SRA event.

   \param pContext DSL library context

   \return
   - DSL_Success Timeout event handled successfully
   - DSL_Error Error during handling of timeout event
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnTimeoutEvent_DsBCStatus(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_G997_ChannelStatus_t  nData;
   DSL_boolean_t bL2EnabledOld = DSL_FALSE, bL2EnabledNew = DSL_FALSE;
   DSL_uint32_t nBitMask = 0;
   static const DSL_uint8_t nChannel = 0;

   if ( DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC )
   {
      
      /* check if L2 was disabled/enabled before*/
      bL2EnabledOld = DSL_IsL2Feasible(pContext, nLine);
      
      nRet = DSL_AVX_AllSraStatusGet(pContext, nLine, DSL_DOWNSTREAM);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

      /* check if L2 could be enabled with updated Lp and ActDataRate*/
      bL2EnabledNew = DSL_IsL2Feasible(pContext, nLine);
      DSL_AVX_dbGetDataRates(pContext, nLine, nChannel, DSL_DOWNSTREAM, &nData);

      if(nData.ActualDataRate > nData.PreviousDataRate)
      {
         nBitMask |= DSL_G997_DATAPATHFAILURE_RAU;
      }
      else if (nData.ActualDataRate < nData.PreviousDataRate)
      {
         nBitMask |= DSL_G997_DATAPATHFAILURE_RAD;
      }
      if (nBitMask)
      {
         DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, DSL_PM_NTU, nBitMask, DSL_TRUE);
      }
      if (bL2EnabledOld != bL2EnabledNew) 
      {
         /* enable/disable L2 in the FW */
         DSL_AVX_SendMsgModemFsmOptionsSet(pContext, nLine);
   
         if (bL2EnabledNew) 
         {
            /* if enabled - send L2 configuration*/
            nRet = DSL_AVX_WriteL2Configuration(pContext, nLine);
            DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
               "Error during L2 Config write!" DSL_CRLF, nLine); 
         }         
      }
   }
   return errorCode;
}

/**
   This routine checks for neccessary recovery.

   \param pContext DSL library context
   \param nDevice  Specifies for which device the function should be applied, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_RecoveryCheck(
   DSL_Context_t *pContext,
   DSL_uint16_t nDevice)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   /* Will be used by data base access macro and has to be set
      fixed to '0' because the configuration settings in this
      function are (bearer) channel independent  */
   static const DSL_uint8_t nChannel = 0;
   DSL_uint16_t nLine = 0, i;
   DSL_boolean_t bAutoRecoverEnabled;
   DSL_boolean_t bFailed = DSL_FALSE;
   DSL_uint16_t j;
   DSL_uint8_t nPeriod, nCurrentCount;
   DSL_uint8_t nRecoveryRetryCount;
   DSL_boolean_t bFailRecoveryRequired;
   DSL_int8_t nMaxAttempts;
#if defined(FIO_MEI3_LINE_HW_PROBE_INFO_GET)
   IOCTL_MEI3_LINE_hwProbeInfo_t sHwProbeInfo;
   IOCTL_MEI3_exchange_t sEx;
#endif /* defined(FIO_MEI3_LINE_HW_PROBE_INFO_GET) */
#if defined(INCLUDE_DSL_DSM) && (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   DSL_uint16_t nTmpLine = 0;
#endif
   if ((DSL_DeviceStatusGet(pContext, nDevice) != DSL_DEVSTATE_RECOVERY) &&
      (DSL_DeviceStatusGet(pContext, nDevice) != DSL_DEVSTATE_REINITIALIZATION))
   {
      for (i = 0; i < DSL_LINES_PER_DEVICE; i++)
      {
         DSL_GET_LINE_PARAM(nDevice, i, nLine);
         if (nLine == 0xFFFF)
            continue;

         if (DSL_LineStatusGet(pContext, nLine) == DSL_DEVSTATE_RECOVERY_REQUIRED)
         {
            DSL_DEBUG_NOLINE(DSL_DBG_MSG,
               (pContext, "DSL: recovery necessary of device %d, because of line %d" DSL_CRLF,
                  nDevice, nLine ));

            bAutoRecoverEnabled = (DSL_boolean_t)DSL_UINT8_GET(DSL_DBI_AUTORECOVER_ENABLE);
            nPeriod = DSL_UINT8_GET(DSL_DBI_AUTORECOVER_PERIOD);
            nMaxAttempts = DSL_INT8_GET(DSL_DBI_AUTORECOVER_MAXATTEMPTS);
            nCurrentCount = DSL_UINT8_GET(DSL_DBDS_AUTORECOVER_COUNT);

            nRecoveryRetryCount = DSL_UINT8_GET(DSL_DBDS_RECOVERY_RETRY_COUNT);
            bFailRecoveryRequired = DSL_UINT8_GET(DSL_DBDS_FAIL_RECOVERY_REQUIRED);
            DSL_UINT8_SET(DSL_DBDS_FAIL_RECOVERY_REQUIRED, DSL_FALSE);

            DSL_TimerDB_Restart(pContext, nLine,
                                DSL_DBDS_AUTORECOVER_TIMEOUT_ID,
                                DSL_TIMEOUTEVENT_NONRECOVERY,
                                nPeriod * 3600 * DSL_TIMEOUT_FACTOR );

            if (! bAutoRecoverEnabled)
               break;
#if defined(INCLUDE_DSL_DSM) && (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
            /* if RECOVERY_REQUIRED is detected on a line and AutoRecovery is enabled,
               trigger a disorderly leaving (IDLE) on all affected lines (device) which
               are in vectoring showtime. */
            nTmpLine = nLine;
            for (j = 0; j < DSL_LINES_PER_DEVICE; j++)
            {
               DSL_GET_LINE_PARAM(nDevice, j, nLine);
               if (nLine == 0xFFFF)
                  continue;

               if ((DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC) &&
                   (DSL_UINT8_GET(DSL_DBS_DSM_SUPPORT_STATUS_DS) != DSL_DSM_SUPPORT_NONE))
               {
                  /* do a forced shutdown here, to avoid long waiting times */
                  DSL_AVX_LineShutdownNoWait(pContext, nLine);
               }
            }
            nLine = nTmpLine;
#endif

            if (nMaxAttempts != -1 && nCurrentCount >= nMaxAttempts && bFailRecoveryRequired == DSL_FALSE)
            {
               if (pContext->pEventCallback != DSL_NULL)
               {
                  if (! DSL_UINT8_GET(DSL_DBL_SEM_RECOVERY_ATTEMPTS_EXPIRED))
                  {
                     DSL_CB_DATA_RecoveryExpired_t nCbData;
                     nCbData.nDevice = nDevice;
                     nCbData.nAttemptsCount = nCurrentCount;

                     (void)(pContext->pEventCallback)((DSL_void_t *) pContext,
                                                 nLine,
                                                 DSL_CHANNEL_NA,
                                                 DSL_ACCESSDIR_NA,
                                                 DSL_ATUDIR_NA,
                                                 DSL_CBS_RECOVERY_ATTEMPTS_EXPIRED,
                                                 (DSL_CB_DATA_Union_t *) &nCbData);
                  }
               }
            }
            else if (bFailRecoveryRequired && nRecoveryRetryCount == DSL_RECOVERY_RETRY_COUNT_MAX)
            {
               DSL_UINT8_SET(DSL_DBDS_RECOVERY_RETRY_COUNT, 0);

               DSL_DeviceStatusSet(pContext, nDevice, DSL_DEVSTATE_RECOVERY_FAILED);
               for (j = 0; j < DSL_LINES_PER_DEVICE; j++)
               {
                  DSL_GET_LINE_PARAM(nDevice, j, nLine);
                  if (nLine == 0xFFFF)
                     continue;
                  DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_FAILED);
                  DSL_UINT32_INC(DSL_DBS_STATISTICS_RECOVER_FAILED);
               }
            }
            else /* recovery for CO devices (more than one line per chip!) */
            {
               DSL_uint32_t nDevMask;
               DSL_uint32_t LineMask[DSL_LINE_MASK_WORDS32];

               if (bFailRecoveryRequired)
               {
                  DSL_UINT8_INC(DSL_DBDS_RECOVERY_RETRY_COUNT);
               }
               else
               {
                  nCurrentCount++;
                  DSL_UINT8_SET(DSL_DBDS_AUTORECOVER_COUNT, nCurrentCount);

                  DSL_UINT32_INC(DSL_DBS_STATISTICS_RECOVER_FAILED);
               }

               DSL_DeviceStatusSet(pContext, nDevice, DSL_DEVSTATE_RECOVERY);
               for (j = 0; j < DSL_LINES_PER_DEVICE; j++)
               {
                  DSL_GET_LINE_PARAM(nDevice, j, nLine);
                  if (nLine == 0xFFFF)
                     continue;
                  DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY);
               }

               nDevMask = (1 << nDevice);
               LineMask[nDevice] = ((DSL_uint32_t)0xFFFFFFFF>>(32-DSL_MIN(DSL_LINES_PER_DEVICE, 32)));
#if defined(FIO_MEI3_LINE_HW_PROBE_INFO_GET)
               memset(&sHwProbeInfo, 0, sizeof(sHwProbeInfo));
               memset(&sEx, 0, sizeof(sEx));
               sEx.pData = &sHwProbeInfo;
               sEx.nLength = sizeof(sHwProbeInfo);
               DSL_GET_LINE_PARAM(nDevice, 0, nLine);
               if (nLine == 0xFFFF)
                  continue;
               if ( DSL_DeviceControl(pContext->DeviceContext.fd[nLine], 
                     FIO_MEI3_LINE_HW_PROBE_INFO_GET, (DSL_ulong_t)&sEx) < 0 )
               {
                  errorCode = DSL_ERROR;
                  DSL_DEBUG( DSL_DBG_ERR, (pContext,
                     "DSL[%02d]: failed to get HW probe info from line" DSL_CRLF, nLine));
               }
               else
               {
                  if (sEx.nError != 0)
                     errorCode = DSL_ERROR;
                  else
                     errorCode = DSL_SUCCESS;
               }

               if ((sHwProbeInfo.deviceHwState == e_MEI3_HW_DEVICE_NOT_AVAILABLE) && (errorCode == DSL_SUCCESS))
               {
                  bFailed = DSL_TRUE;
               }
               else
#endif
               {
                  /* call init without new firmware pointer */
                  errorCode = DSL_DEV_Init(pContext, DSL_NULL, 0, DSL_NULL, 0, DSL_DEVINIT_ALL, &nDevMask, LineMask);
                  if (errorCode < 0 || errorCode == DSL_WRN_FIRMWARE_DOWNLOAD)
                     bFailed = DSL_TRUE;
               }
            }

            if (bFailed)
            {
               DSL_DeviceStatusSet(pContext, nDevice, DSL_DEVSTATE_RECOVERY_REQUIRED);
               DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_REQUIRED);
               DSL_DBG_ExceptionHistoryAddTrigger(pContext, nLine, DSL_AUTORECOVER_TRIGGER_UNDEFINED);
               DSL_UINT8_SET(DSL_DBDS_FAIL_RECOVERY_REQUIRED, DSL_TRUE);
            }

            break;
         }
      }
   }
   return (errorCode);
}



#ifndef DSL_DEBUG_DISABLE
DSL_Error_t DSL_SeltDataPrintStatistics(
   DSL_Context_t *pContext)
{
   DSL_deltLineData_t *pLineData = DSL_NULL;
   DSL_deltDirectionData_t *pDirData = DSL_NULL;
   DSL_uint8_t nDir = DSL_UPSTREAM;
   DSL_uint16_t nLine = 0;
   DSL_uint32_t nSize = 0;
   DSL_int_t i = 0;

   if (pContext->pDeltDataList == DSL_NULL)
   {
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: No DELT data list available!" DSL_CRLF DSL_CRLF));

      return (DSL_SUCCESS);
   }

   pLineData = _DSLAPI DSL_DeltLineDataGetFirst(pContext);

   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      DSL_CRLF "DSL: DELT data statistics:" DSL_CRLF));

   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      "DSL: pFirst = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pContext->pDeltDataList->pFirst));
   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      "DSL: pLast = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pContext->pDeltDataList->pLast));
   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      "DSL: ------------------------------" DSL_CRLF));

   while (pLineData != DSL_NULL)
   {
      i += 1;
      nLine = pLineData->nLine;

      /* Calculate size of used memory */
      nSize = 0;
      nSize += sizeof(DSL_deltLineData_t);

      for (nDir = DSL_UPSTREAM; nDir < DSL_ACCESSDIR_LAST; nDir++)
      {
         pDirData = _DSLAPI DSL_DeltDirectionDataGet(pContext, nLine, (DSL_AccessDir_t)nDir);

         if (pDirData != DSL_NULL)
         {
            nSize += pDirData->rHlin.nSize;
            nSize += pDirData->rHlog.nSize;
            nSize += pDirData->rQLN.nSize;
            nSize += pDirData->rSNR.nSize;
         }
      }

      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: Element-Nr. = %d" DSL_CRLF, i));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: nLine = %d" DSL_CRLF, pLineData->nLine));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: nSize = %u" DSL_CRLF, nSize));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: nLastMsgId = 0x%0X" DSL_CRLF, pLineData->nLastMsgId));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: pLineData = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pLineData));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: pPrevious = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pLineData->pPrevious));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: pNext = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pLineData->pNext));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: ------------------------------" DSL_CRLF));

      pLineData = _DSLAPI DSL_DeltLineDataGetNext(pContext, pLineData);
   }

   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      "DSL: Total number of DELT data elements: %d" DSL_CRLF DSL_CRLF, i));

   return (DSL_SUCCESS);
}
#endif


/**
   This function handles the firmware messages which includes the
   array DELT parameters for Hlog, QLN and SNR far end.

   \param pContext   DSL library context
   \param nLine      Specifies for which line the function will apply, [I]
   \param pMsg       Pointer to received firmware message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_DeltFeUpdate(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   const AVX_EvtOhcStatusGet_t *pMsg)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_deltLineData_t *pLineData = DSL_NULL;
   DSL_deltDirectionData_t *pDirData = DSL_NULL;
#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
   static DSL_uint16_t nChannel = 0;
#endif

   DSL_DEBUG(DSL_DBG_MSG,
      (pContext, "DSL[%02d]: DSL_AVX_DeltFeUpdate" DSL_CRLF, nLine));

   /* we received something, stop the timeout supervision */
   if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID) != DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_WRN,
         (pContext, "DSL[%02d]: DSL_AVX_DeltFeUpdate - could "
         "not remove timeout!" DSL_CRLF , nLine ));
   }

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
   if (  DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) == DSL_CDA_MODE_OFF &&
         DSL_AVX_Eaps2FsmStateGet(pContext, nLine) != DSL_EAPS2_ACTIVATE )
   {
      /* don't need to poll DS DELT data anymore */
      return (DSL_SUCCESS);
   }
#endif /* defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

   /* prepare the DELT DATA buffer */
   pLineData = _DSLAPI DSL_DeltLineDataGet(pContext, nLine);
   pDirData = _DSLAPI DSL_DeltDirectionDataGet(pContext, nLine, DSL_DOWNSTREAM);
   if ((pLineData == DSL_NULL) || (pDirData == DSL_NULL))
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: there is no DELT data element for this line!" DSL_CRLF,
         nLine));
      return (DSL_ERROR);
   }

/*
   example how to simulate missing data,
   if simulate, disable DSL_Timeout_RemoveEvent code above
   switch (pLineData->nLastMsgId & 0xFF)
   {
   case DSL_OHC_TESTPARAM_ID_HLOG:
      return DSL_SUCCESS;
      break;
   case DSL_OHC_TESTPARAM_ID_QLN:
      break;
   case DSL_OHC_TESTPARAM_ID_SNR:
      break;
   default:
      return (DSL_ERROR);
   }

   DSL_GET_DEVICE_NUMBER(nLine, nDev);
   nTimeoutID = DSL_ULONG_GET(DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID);
   if (nTimeoutID > 0)
   {
      if (DSL_Timeout_RemoveEvent(pContext, nDev, nTimeoutID) != DSL_SUCCESS)
      {
         DSL_DEBUG( DSL_DBG_WRN,
            (pContext, "DSL[%02d]: DSL_AVX_DeltFeUpdate - could "
            "not remove timeout!" DSL_CRLF , nLine ));
      }
      DSL_ULONG_SET(DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID, 0);
   }
*/


   pDirData->nNumData = VNX_MAX_SCGROUPS;

   /* check the event, wether data was received */
   if (pMsg->Status != AVX_OHC_SUCCEED)
   {
      /* repeat the request only if the line is in showtime*/
      if (DSL_CHECK_LINE_SHOWTIME(nLine))
      {
         errorCode = DSL_AVX_DeltFeRepeat(pContext, nLine);
      }
      return (DSL_ERROR);
   }

   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
      errorCode = DSL_AVX_DeltVdslFeUpdate(pContext, nLine, pMsg, pLineData, pDirData);
   else
      errorCode = DSL_AVX_DeltAdslFeUpdate(pContext, nLine, pMsg, pLineData, pDirData);

   return errorCode;
}

/**
   This function handles the OHC messages which include the
   array DELT parameters for Hlog, QLN and SNR far end
   in VDSL mode.

   \param pContext   DSL library context
   \param nLine      Specifies for which line the function will apply, [I]
   \param pMsg       Pointer to received firmware message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_DeltVdslFeUpdate(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   const AVX_EvtOhcStatusGet_t *pMsg,
   const DSL_deltLineData_t *pLineData,
   DSL_deltDirectionData_t *pDirData)
{
   DSL_Error_t    errorCode = DSL_SUCCESS;
   DSL_uint16_t   nNumItems = 0, nOffset = 0,
                  nNumItemsGlobal = 0,
                  nNumItemsMax = 0, nOffsetMin = 512,
                  nHlogLen, nSnrLen, nQlnLen;
   DSL_uint8_t nUnitSize = 0;
   static DSL_uint16_t nChannel = 0;
   DSL_uint32_t nDataLen = 0;
   DSL_deltSubcarrierData_t *pDeltData = DSL_NULL;
#ifndef DSL_OHC_QUEUE
   AVX_CmdOhcReceive_t sCmd;
#endif
   AVX_OhcMsg_t sAck;
   DSL_uint16_t *pQln = DSL_NULL, *pSnr = DSL_NULL, *pHlog = DSL_NULL;
   DSL_DeltFeTypes_t nType;

   DSL_DEBUG(DSL_DBG_MSG,
      (pContext, "DSL[%02d]: DSL_AVX_DeltVdslFeUpdate" DSL_CRLF, nLine));
#ifdef DSL_OHC_QUEUE
   errorCode = DSL_AVX_OhcRecvMessage(pContext, nLine, sizeof(sAck), &sAck);
#else
   memset(&sCmd, 0, sizeof(sCmd));
   sCmd.NumRead = sizeof(sAck);
   errorCode =  DSL_AVX_SendMessage(pContext,
                    nLine, AVX_CMD_OHC_RECEIVE,
                    sizeof(sCmd), (DSL_uint8_t*)&sCmd,
                    sizeof(sAck), (DSL_uint8_t*)&sAck);
#endif /* DSL_OHC_QUEUE */

#ifndef AVX_OHC_DATA_START_INDEX
#define AVX_OHC_DATA_START_INDEX 0
#endif

#define AVX_OHC_VDSL_DATA_TYPE_HEADER 1

   if (errorCode ==  DSL_SUCCESS)
   {
      if((sAck.OhcData[AVX_OHC_DATA_START_INDEX] == 0x8081)) /* NACK */
      {
         /* repeat the request */
         errorCode = DSL_AVX_DeltFeRepeat(pContext, nLine);
         return (DSL_ERROR);
      }

      nNumItemsGlobal = (sAck.OhcLength - 2 - 6) / 4; /* (Length - "BlockRead ACK" - 3*2{Block identifiers DSL_DBS_DIAG_XXX}) / 4{2x Hlog, 1x Qln, 1xSnr}
                                                       Exmple: (0x0088 - 2 - 6) / 4 = 32
                                                   For FB7390: (0x0030 - 2 - 6) / 4 = 10 */
      if(((sAck.OhcLength - 8) & 0x3) != 0 )
      {
          /*print out warning*/
         int i = 0;

         DSL_DEBUG( DSL_DBG_WRN, (pContext,
            "DSL[%02d]: Wrong data length: Requested len %d, received len %d" DSL_CRLF ,
            nLine, AVX_MAX_TESTPARAMS_BLOCK, sAck.OhcLength));
         DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: Packet data (len 0x%04X):" DSL_CRLF, nLine, sAck.OhcLength));
         for( i = 0; i < sAck.OhcLength/2; i++)
         {
            DSL_DEBUG(DSL_DBG_MSG, (pContext, "  %04X", sAck.OhcData[i]));
            if((( i+1 ) & 0xf ) == 0)
            {
               DSL_DEBUG(DSL_DBG_MSG, (pContext, "" DSL_CRLF));
            }
         }
         DSL_DEBUG(DSL_DBG_MSG, (pContext, "" DSL_CRLF));
      }

      if( nNumItemsGlobal > AVX_MAX_TESTPARAMS_BLOCK)
      {
          /*Skip this data*/
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: Actual block length greater requested block length: requested len %d,"
            " received len %d. Skip this data" DSL_CRLF, nLine,
            AVX_MAX_TESTPARAMS_BLOCK, sAck.OhcLength));
         return (DSL_ERROR);
      }
      else if( nNumItemsGlobal != AVX_MAX_TESTPARAMS_BLOCK)
      {
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
                  "DSL[%02d]: Actual block length not equal requested block length: "
                  "requested len %d, received len %d" DSL_CRLF, nLine,
                  AVX_MAX_TESTPARAMS_BLOCK, sAck.OhcLength));
      }

      if ((sAck.OhcData[AVX_OHC_DATA_START_INDEX] == 0x8481)) /* BlockRead ACK */
      {
         nHlogLen = 2 + nNumItemsGlobal*2;
         nSnrLen = 2 + nNumItemsGlobal;
         nQlnLen = nSnrLen;

         pHlog = &sAck.OhcData[AVX_OHC_DATA_START_INDEX + 1];
         pQln = &sAck.OhcData[AVX_OHC_DATA_START_INDEX + 1 + nHlogLen/2];
         pSnr = &sAck.OhcData[AVX_OHC_DATA_START_INDEX + 1 + nHlogLen/2 + nQlnLen/2];
      }
      else
      {
         errorCode = DSL_AVX_DeltFeRepeat(pContext, nLine);
         return (DSL_ERROR);
      }
   }
   else
   {
      /* repeat the request */
      errorCode = DSL_AVX_DeltFeRepeat(pContext, nLine);
      return (DSL_ERROR);
   }

   /* loop for all param types, skip if there is no data */
   for (nType=(DSL_DeltFeTypes_t)0; nType<DSL_DELT_FE_LAST; nType++)
   {
      switch (nType)
      {
         case DSL_DELT_FE_SNR:
            if (pSnr == DSL_NULL)
               continue;
            pDeltData = &(pDirData->rSNR);
            nUnitSize = sizeof(DSL_uint8_t);
            break;
         case DSL_DELT_FE_QLN:
            if (pQln == DSL_NULL)
               continue;
            pDeltData = &(pDirData->rQLN);
            nUnitSize = sizeof(DSL_uint8_t);
            break;
         case DSL_DELT_FE_HLOG:
         default:
            if (pHlog == DSL_NULL)
               continue;
            pDeltData = &(pDirData->rHlog);
            nUnitSize = sizeof(DSL_uint16_t);
            break;
      }

      nDataLen = VNX_MAX_SCGROUPS * nUnitSize;

      if( pDeltData->pValues == DSL_NULL )
      {
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: allocate memory for HLOG/QLN/SNR." DSL_CRLF,
            nLine));

         pDeltData->pValues = (DSL_uint16_t *)DSL_Malloc(nDataLen);

         if( pDeltData->pValues == DSL_NULL )
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: failed to allocate memory for HLOG/QLN/SNR!" DSL_CRLF,
                nLine));
            return (DSL_ERROR);
         }
         /* remember allocated bytes */
         pDeltData->nSize = nDataLen;
         memset(pDeltData->pValues, 0, nDataLen);
         pDeltData->nCurrDataSize = 0;
      }
      else if (nDataLen > pDeltData->nSize)
      {
         DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: reallocate memory for HLOG/QLN/SNR." DSL_CRLF, nLine));

         DSL_Free(pDeltData->pValues);
         pDeltData->pValues = (DSL_uint16_t *) DSL_Malloc(nDataLen);

         if (pDeltData->pValues == DSL_NULL)
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: failed to allocate memory for HLOG/QLN/SNR!" DSL_CRLF, nLine));
            return (DSL_ERROR);
         }

         pDeltData->nSize = nDataLen;
         memset(pDeltData->pValues, 0, nDataLen);
         pDeltData->nCurrDataSize = 0;
      }

      nOffset  = pDeltData->nCurrDataSize * 2/nUnitSize;

      /* FIXME: cutoff received data to what fits into the buffer.
         should be replaced by reading the number of received bytes */
      nNumItems = nNumItemsGlobal;
      if (nOffset + nNumItems > VNX_MAX_SCGROUPS)
         nNumItems = VNX_MAX_SCGROUPS - nOffset;

      if ( DSL_DeltMemorySizeCheck(pContext, pDeltData,
            (DSL_uint16_t)((nOffset * nUnitSize) / 2),
            (DSL_uint16_t)((nNumItems * nUnitSize) / 2)) == DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
            "DSL[%02d]: alloced %u, to copy %u, total %u, "
            "size %u-%u" DSL_CRLF, nLine, nDataLen/2,
            nNumItems, nOffset + ((pDeltData->nCurrDataSize * nUnitSize) / 2),
            pDeltData->nCurrDataSize,
            pDeltData->nCurrDataSize + (nNumItems * nUnitSize) / 2));

         /* copy the received data */
         switch (nType)
         {
         case DSL_DELT_FE_HLOG:
            errorCode = DSL_AVX_FeTestParamCopy(pContext, nLine, nType,
                           nNumItems, pHlog+1,
                           &pDeltData->pValues[nOffset]);
            /* nCurrDataSize codes the number of 16bit words */
            pDeltData->nCurrDataSize = nOffset + nNumItems;
            DSL_UINT16_SET(DSL_DBS_DIAG_HLOGMT_DS, DSL_UINT16_SWAP(pHlog[0]));
            break;
         case DSL_DELT_FE_SNR:
            errorCode = DSL_AVX_FeTestParamCopy(pContext, nLine, nType,
                           nNumItems, pSnr+1,
                           &pDeltData->pValues[nOffset/2]);
            /* nCurrDataSize codes the number of 16bit words */
            pDeltData->nCurrDataSize = (nOffset + nNumItems) / 2;
            DSL_UINT16_SET(DSL_DBS_DIAG_SNRMT_DS, DSL_UINT16_SWAP(pSnr[0]));
            break;
         case DSL_DELT_FE_QLN:
            errorCode = DSL_AVX_FeTestParamCopy(pContext, nLine, nType,
                           nNumItems, pQln+1,
                           &pDeltData->pValues[nOffset/2]);
            /* nCurrDataSize codes the number of 16bit words */
            pDeltData->nCurrDataSize = (nOffset + nNumItems) / 2;
            DSL_UINT16_SET(DSL_DBS_DIAG_QLNMT_DS, DSL_UINT16_SWAP(pQln[0]));
            break;
         default:
            break;
         }

         nNumItemsMax = DSL_MAX(nNumItems, nNumItemsMax);
         nOffsetMin = DSL_MIN(nOffset, nOffsetMin);
      }
      else
      {
         /* memory was exceeded, assume data is complete, break the loop */
         nNumItemsMax = 0;
         nOffsetMin = VNX_MAX_SCGROUPS;
      }
   }

   DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
      "DSL[%02d]: nOffsetMin=%d + nNumItemsMax=%d < VNX_MAX_SCGROUPS=%d" DSL_CRLF,
      nLine, nOffsetMin, nNumItemsMax, VNX_MAX_SCGROUPS));

   /* Not all groups were retrieved yet, try to request next DELT data */
   if( (nOffsetMin + nNumItemsMax) < VNX_MAX_SCGROUPS )
   {
#if 0
      /* instead of reading all groups data, just retrieve inband data */
      DSL_Band_t sInterval;
      DSL_uint8_t nGroupSize = DSL_UINT8_GET(DSL_DBS_DIAG_SNRGS_DS);

      /* check how many groups of nGroupSize tones have to be retrieved
         for the next inband area */
      errorCode = DSL_AVX_NextInbandIntervalGet(pContext, nLine,
                     DSL_DOWNSTREAM, (pMsg->EndIndex+1) * nGroupSize,
                     32 * nGroupSize, &sInterval);
      /* if no inband data is available any more, stop here */
      if (errorCode == DSL_SUCCESS)
      {
         errorCode = DSL_AVX_DeltArrayParamsQuery(pContext, nLine,
                        (DSL_uint16_t)(sInterval.nFirstToneIndex/nGroupSize),
                        (DSL_uint16_t)(DSL_MIN((sInterval.nLastToneIndex/nGroupSize),
                        (VNX_MAX_SCGROUPS-1))) );
#else
      {
         errorCode = DSL_AVX_DeltArrayParamsQuery(pContext, nLine,
            (DSL_uint16_t)(nOffsetMin + nNumItemsMax),
            (DSL_uint16_t)(DSL_MIN((nOffsetMin + nNumItemsMax + AVX_MAX_TESTPARAMS_BLOCK - 1),
                                    (VNX_MAX_SCGROUPS-1))) );
#endif
         if(errorCode != DSL_SUCCESS)
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: failed to QueryDeltArrayParams!" DSL_CRLF, nLine));
            return (errorCode);
         }

         /* request was sent, start the timeout supervision */
         DSL_TimerDB_Add(pContext, nLine,
                         DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID,
                         DSL_TIMEOUTEVENT_DELT_FE_STATUS,
                         DSL_DEV_TIMEOUT_DELT_FE_STATUS * DSL_TIMEOUT_FACTOR *
                         (pContext->DeviceContext.LineFlags[nLine].nFeRequestRepetitions + 1));
      }

   }
   else
   {
      /* all data retrieved */
#ifndef DSL_DEBUG_DISABLE
      if (DSL_g_dbgLvl[DSL_DBG_BLOCK].nDbgLvl >= DSL_DBG_MSG)
      {
         _DSLAPI DSL_SeltDataPrintStatistics(pContext);
      }
#endif

      errorCode = DSL_AVX_SendMsgTestParamsAuxGet(pContext, nLine, DSL_DOWNSTREAM);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_DeltVdslFeUpdate: Error during Measurement Time DS Get!" DSL_CRLF, nLine));
      }

      if (DSL_UINT8_GET(DSL_DBS_DELT_INVENTORY_AVAILABLE) == DSL_FALSE)
      {
         DSL_AVX_OnDeltInventoryAvailable(pContext, nLine);
         DSL_UINT8_SET(DSL_DBS_DELT_INVENTORY_AVAILABLE, DSL_TRUE);
      }

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
#if defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1)
      if ( !((DSL_uint16_t) DSL_UINT16_GET(DSL_DBS_OPDATA_FREEZE) &
            (DSL_OPDATA_TRG_FREEZE_ALL | DSL_OPDATA_TRG_FREEZE_L2)) )
#endif /* defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1) */
      {
         errorCode = DSL_G997_DEV_DeltHlogGet(pContext, nLine, DSL_DOWNSTREAM,
                        DSL_AVX_CARRIER_DATA_GET(nLine, DeltHlog, DS));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier hlog DS get (%d)!" DSL_CRLF, errorCode));
         }
         else if (((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF) ||
                  (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE))
         {
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlog, DS, DSL_TRUE);
         }

         errorCode = DSL_G997_DEV_DeltSNRGet(pContext, nLine, DSL_DOWNSTREAM,
                        DSL_AVX_CARRIER_DATA_GET(nLine, DeltSnr, DS));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier snr DS get (%d)!" DSL_CRLF, errorCode));
         }
         else if (((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF) ||
                  (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE))
         {
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltSnr, DS, DSL_TRUE);
         }

         errorCode = DSL_G997_DEV_DeltQLNGet(pContext, nLine, DSL_DOWNSTREAM,
                        DSL_AVX_CARRIER_DATA_GET(nLine, DeltQln, DS));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier qln DS get (%d)!" DSL_CRLF, errorCode));
         }
         else if (((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF) ||
                  (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE))
         {
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltQln, DS, DSL_TRUE);
         }
      }
#endif /* defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

#if (DSL_DEV_TIMEOUT_FE_SNR_UPDATE > 0)
      /* Start 30sec timer to update SNR data */
      DSL_TimerDB_Restart(pContext, nLine,
                          DSL_DBS_FE_SNR_UPDATE_TIMEOUT_ID,
                          DSL_TIMEOUTEVENT_FE_SNR_UPDATE,
                          DSL_DEV_TIMEOUT_FE_SNR_UPDATE * DSL_TIMEOUT_FACTOR );
#endif
   }

   return (DSL_SUCCESS);
}

/**
   This function handles the OHC messages which include the
   array DELT parameters for Hlog, QLN and SNR far end
   in ADSL mode.

   \param pContext   DSL library context
   \param nLine      Specifies for which line the function will apply, [I]
   \param pMsg       Pointer to received firmware message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_DeltAdslFeUpdate(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   const AVX_EvtOhcStatusGet_t *pMsg,
   DSL_deltLineData_t *pLineData,
   DSL_deltDirectionData_t *pDirData)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint16_t nNumItemsReceived = 0, nNumItemsDone = 0,
                  nNumItemsTotal = 0,
                  nFwOffset = 0;
   DSL_uint8_t nUnitSize = 1;
#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
#if defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1)
   static DSL_uint16_t nChannel = 0;
#endif
#endif
   DSL_uint32_t nDataLen = 0;
   DSL_deltSubcarrierData_t *pDeltData = DSL_NULL;
#ifndef DSL_OHC_QUEUE
   AVX_CmdOhcReceive_t sCmd;
#endif
   AVX_OhcMsg_t sAck;
   DSL_uint16_t *pMsgData = DSL_NULL;
   DSL_DeltFeTypes_t nType;

   DSL_DEBUG(DSL_DBG_MSG,
      (pContext, "DSL[%02d]: DSL_AVX_DeltAdslFeUpdate" DSL_CRLF, nLine));

   DSL_CHECK_POINTER(pContext, pLineData);
   DSL_CHECK_POINTER(pContext, pDirData);
   /* read only the header information first */
   nFwOffset = 0;

#define AVX_OHC_HEADER_ID_SIZE 2
#define AVX_OHC_HEADER_MEASUREMENT_TIME_SIZE 2
#define AVX_OHC_HEADER_ID_INDEX 0
#define AVX_OHC_HEADER_MEASUREMENT_TIME_INDEX 1
#define AVX_OHC_HEADER_SIZE (AVX_OHC_HEADER_ID_SIZE + AVX_OHC_HEADER_MEASUREMENT_TIME_SIZE)

#ifdef DSL_OHC_QUEUE
   errorCode = DSL_AVX_OhcRecvMessage(pContext, nLine, AVX_OHC_HEADER_SIZE, &sAck);
#else
   memset(&sCmd, 0, sizeof(sCmd));
   sCmd.NumRead = AVX_OHC_HEADER_SIZE;
   errorCode =  DSL_AVX_SendMessageArrayIndex( pContext,
                    nLine, AVX_CMD_OHC_RECEIVE,
                    sizeof(sCmd), (DSL_uint8_t*)&sCmd,
                    sizeof(sAck), (DSL_uint8_t*)&sAck, 0);
#endif /* DSL_OHC_QUEUE */

   if (errorCode ==  DSL_SUCCESS)
   {
      if(sAck.OhcData[AVX_OHC_HEADER_ID_INDEX] == 0x8081) /* NACK */
      {
         /* repeat the request */
         errorCode = DSL_AVX_DeltFeRepeat(pContext, nLine);
         return (DSL_ERROR);
      }

      if ((sAck.OhcData[AVX_OHC_HEADER_ID_INDEX] == 0x8181)) /* SingleRead ACK */
      {
         /* distinguish single read type according Table 9-30/G.992.3 */
         switch (pLineData->nLastMsgId & 0xFF)
         {
         case DSL_OHC_TESTPARAM_ID_HLOG:
            nType = DSL_DELT_FE_HLOG;
            pDeltData = &(pDirData->rHlog);
            nUnitSize = sizeof(DSL_uint16_t);
            /* todo save measurement time from
            sAck.OhcData[AVX_OHC_HEADER_MEASUREMENT_TIME_INDEX] to nMeasurementTime */
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: DSL_AVX_DeltAdslFeUpdate proceed HLOG OHC nUnitSize=%d." DSL_CRLF,
               nLine, nUnitSize));
            break;
         case DSL_OHC_TESTPARAM_ID_QLN:
            nType = DSL_DELT_FE_QLN;
            pDeltData = &(pDirData->rQLN);
            nUnitSize = sizeof(DSL_uint8_t);
            /* todo save measurement time from
            sAck.OhcData[AVX_OHC_HEADER_MEASUREMENT_TIME_INDEX] to nMeasurementTime */
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: DSL_AVX_DeltAdslFeUpdate proceed QLN OHC nUnitSize=%d." DSL_CRLF,
               nLine, nUnitSize));
            break;
         case DSL_OHC_TESTPARAM_ID_SNR:
            nType = DSL_DELT_FE_SNR;
            pDeltData = &(pDirData->rSNR);
            nUnitSize = sizeof(DSL_uint8_t);
            /* todo save measurement time from
            sAck.OhcData[AVX_OHC_HEADER_MEASUREMENT_TIME_INDEX] to nMeasurementTime */
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: DSL_AVX_DeltAdslFeUpdate proceed SNR OHC nUnitSize=%d." DSL_CRLF,
               nLine, nUnitSize));
            break;
         default:
            /* repeat the request */
            errorCode = DSL_AVX_DeltFeRepeat(pContext, nLine);
            return (DSL_ERROR);
         }
      }
      else
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_DeltAdslFeUpdate - unknown OHC ID 0x%04X." DSL_CRLF,
            nLine, sAck.OhcData[AVX_OHC_HEADER_ID_INDEX]));
         return DSL_ERROR;
      }
   }
   else
   {
      /* repeat the request */
      errorCode = DSL_AVX_DeltFeRepeat(pContext, nLine);
      return (DSL_ERROR);
   }

   DSL_CHECK_POINTER(pContext, pDeltData);
   if ((sAck.OhcLength < AVX_OHC_HEADER_SIZE) ||
       (((sAck.OhcLength - AVX_OHC_HEADER_SIZE) / nUnitSize) > 512))
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_DeltAdslFeUpdate - suspicious OhcLength %d, "
         "repeated." DSL_CRLF,
         nLine, sAck.OhcLength));
      /* repeat the request */
      errorCode = DSL_AVX_DeltFeRepeat(pContext, nLine);
      return (DSL_ERROR);
   }
   else
      nNumItemsTotal = (sAck.OhcLength - AVX_OHC_HEADER_SIZE) / nUnitSize;

   nDataLen = nNumItemsTotal * nUnitSize;

   if( pDeltData->pValues == DSL_NULL )
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: allocate memory for HLOG/QLN/SNR." DSL_CRLF,
         nLine));

      pDeltData->pValues = (DSL_uint16_t *)DSL_Malloc(nDataLen);

      if( pDeltData->pValues == DSL_NULL )
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: failed to allocate memory for HLOG/QLN/SNR!" DSL_CRLF,
             nLine));
         return (DSL_ERROR);
      }
      /* remember allocated bytes */
      pDeltData->nSize = nDataLen;
      memset(pDeltData->pValues, 0, nDataLen);
      pDeltData->nCurrDataSize = 0;
   }
   else if (nDataLen > pDeltData->nSize)
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: reallocate memory for HLOG/QLN/SNR." DSL_CRLF, nLine));

      DSL_Free(pDeltData->pValues);
      pDeltData->pValues = (DSL_uint16_t *) DSL_Malloc(nDataLen);

      if (pDeltData->pValues == DSL_NULL)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: failed to allocate memory for HLOG/QLN/SNR!" DSL_CRLF, nLine));
         return (DSL_ERROR);
      }

      pDeltData->nSize = nDataLen;
      memset(pDeltData->pValues, 0, nDataLen);
      pDeltData->nCurrDataSize = 0;
   }

   while (nNumItemsDone < nNumItemsTotal)
   {
#ifdef DSL_OHC_QUEUE
      AVX_CmdOhcReceive_t sCmd;
#endif
      /* Read next block */
      nFwOffset   = (nNumItemsDone * nUnitSize) + AVX_OHC_HEADER_SIZE;
      /* printf("\r\n bbb (nNumItemsDone=%d + (sizeof(sAck.OhcData)=%d / nUnitSize=%d ))=%d > nNumItemsTotal=%d\r\n",
      nNumItemsDone, sizeof(sAck.OhcData), nUnitSize,
      (nNumItemsDone + (sizeof(sAck.OhcData) / nUnitSize)), nNumItemsTotal); */
      if ((nNumItemsDone + (sizeof(sAck.OhcData) / nUnitSize)) > nNumItemsTotal)
      {
         /* last data block */
         sCmd.NumRead = ((nNumItemsTotal * nUnitSize) - (nNumItemsDone * nUnitSize)) + sizeof(sAck.OhcLength);
         /* printf("\r\n bbb 1 sCmd.NumRead=%d\r\n", sCmd.NumRead); */
      }
      else
      {
         sCmd.NumRead = sizeof(sAck);
         /* printf("\r\n bbb 2 sCmd.NumRead=%d\r\n", sCmd.NumRead); */
      }

      errorCode =  DSL_AVX_SendMessageArrayIndex( pContext,
                       nLine, AVX_CMD_OHC_RECEIVE,
                       sizeof(sCmd), (DSL_uint8_t*)&sCmd,
                       sizeof(sAck), (DSL_uint8_t*)&sAck, nFwOffset);
      if (errorCode !=  DSL_SUCCESS)
      {
         /* repeat the request */
         errorCode = DSL_AVX_DeltFeRepeat(pContext, nLine);
         return (DSL_ERROR);
      }

      nNumItemsReceived = ((sCmd.NumRead - sizeof(sAck.OhcLength)) / nUnitSize);
      /* printf("\r\n bbb nNumItemsReceived=%d\r\n", nNumItemsReceived); */
      pMsgData = &sAck.OhcData[AVX_OHC_DATA_START_INDEX];

      if ( DSL_DeltMemorySizeCheck(pContext, pDeltData,
            (DSL_uint16_t)((nNumItemsDone * nUnitSize) / 2),
            (DSL_uint16_t)((nNumItemsReceived * nUnitSize) / 2)) == DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
            "DSL[%02d]: allocated %u, to copy %u, total %u, "
            "size %u-%u" DSL_CRLF, nLine, pDeltData->nSize,
            nNumItemsReceived, pDeltData->nCurrDataSize,
            pDeltData->nCurrDataSize,
            pDeltData->nCurrDataSize + (nNumItemsReceived * nUnitSize) / 2));

         /* copy the received data */
         switch (nType)
         {
         case DSL_DELT_FE_HLOG:
            errorCode = DSL_AVX_FeTestParamCopy(pContext, nLine, nType,
                           nNumItemsReceived, pMsgData,
                           &pDeltData->pValues[nNumItemsDone]);
            /* nCurrDataSize codes the number of 16bit words */
            pDeltData->nCurrDataSize = (nNumItemsDone) + nNumItemsReceived;
            break;
         case DSL_DELT_FE_SNR:
            errorCode = DSL_AVX_FeTestParamCopy(pContext, nLine, nType,
                           nNumItemsReceived, pMsgData,
                           &pDeltData->pValues[nNumItemsDone/2]);
            /* nCurrDataSize codes the number of 16bit words */
            pDeltData->nCurrDataSize = (nNumItemsDone + nNumItemsReceived) / 2;
            break;
         case DSL_DELT_FE_QLN:
            errorCode = DSL_AVX_FeTestParamCopy(pContext, nLine, nType,
                           nNumItemsReceived, pMsgData,
                           &pDeltData->pValues[nNumItemsDone/2]);
            /* nCurrDataSize codes the number of 16bit words */
            pDeltData->nCurrDataSize = (nNumItemsDone + nNumItemsReceived) / 2;
            break;
         default:
            break;
         }
      }
      nNumItemsDone += nNumItemsReceived;
   }

   if (pLineData->nLastMsgId & DSL_OHC_SINGLE_REQUEST)
   {
#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
#if defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1)
      if ( !((DSL_uint16_t) DSL_UINT16_GET(DSL_DBS_OPDATA_FREEZE) & (DSL_OPDATA_TRG_FREEZE_ALL | DSL_OPDATA_TRG_FREEZE_L2)) )
#endif /* defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1) */
      {
         if (pLineData->nLastMsgId & DSL_OHC_TESTPARAM_ID_SNR)
         {
            errorCode = DSL_G997_DEV_DeltSNRGet(pContext, nLine, DSL_DOWNSTREAM, DSL_AVX_CARRIER_DATA_GET(nLine, DeltSnr, DS));
            if ( errorCode != DSL_SUCCESS )
            {
               DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier snr DS get (%d)!" DSL_CRLF, errorCode));
            }
            else if (((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF) || (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE))
            {
               DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltSnr, DS, DSL_TRUE);
            }
         }
      }
#endif /* defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

      return DSL_SUCCESS;
   }

   switch (pLineData->nLastMsgId)
   {
   case DSL_OHC_TESTPARAM_ID_QLN:
      pLineData->nLastMsgId   =  DSL_OHC_TESTPARAM_ID_SNR;
      break;
   case DSL_OHC_TESTPARAM_ID_SNR:
      pLineData->nLastMsgId   =  DSL_OHC_TESTPARAM_ID_HLOG;
      break;
   case DSL_OHC_TESTPARAM_ID_HLOG:
      pLineData->nLastMsgId   =  DSL_OHC_TESTPARAM_ID_LAST;
      break;
   case DSL_OHC_TESTPARAM_ID_LAST:
   case DSL_OHC_TESTPARAM_ID_NONE:
   default:
      break;
   }

   /* Not all groups were retrieved yet, try to request next DELT data */
   if(pLineData->nLastMsgId != DSL_OHC_TESTPARAM_ID_LAST)
   {
      errorCode = DSL_AVX_DeltArrayParamsQuery(pContext, nLine,
         (DSL_uint16_t)(0), (DSL_uint16_t)(511) );
      if(errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: failed to QueryDeltArrayParams!" DSL_CRLF, nLine));
         return (errorCode);
      }
      /* request was sent, start the timeout supervision */
      DSL_TimerDB_Add(pContext, nLine,
                      DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID,
                      DSL_TIMEOUTEVENT_DELT_FE_STATUS,
                      DSL_DEV_TIMEOUT_DELT_FE_STATUS * DSL_TIMEOUT_FACTOR *
                      (pContext->DeviceContext.LineFlags[nLine].nFeRequestRepetitions + 1));
   }
   else
   {
      /* all data retrieved */
#ifndef DSL_DEBUG_DISABLE
      if (DSL_g_dbgLvl[DSL_DBG_BLOCK].nDbgLvl >= DSL_DBG_MSG)
      {
         _DSLAPI DSL_SeltDataPrintStatistics(pContext);
      }
#endif

      errorCode = DSL_AVX_SendMsgTestParamsAuxGet(pContext, nLine, DSL_DOWNSTREAM);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_DeltVdslFeUpdate: Error during Measurement Time DS Get!" DSL_CRLF, nLine));
      }

#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
#if defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1)
      if ( !((DSL_uint16_t) DSL_UINT16_GET(DSL_DBS_OPDATA_FREEZE) & (DSL_OPDATA_TRG_FREEZE_ALL | DSL_OPDATA_TRG_FREEZE_L2)) )
#endif /* defined(DSL_OPDATA_FREEZING) && (DSL_OPDATA_FREEZING == 1) */
      {
         errorCode = DSL_G997_DEV_DeltHlogGet(pContext, nLine, DSL_DOWNSTREAM, DSL_AVX_CARRIER_DATA_GET(nLine, DeltHlog, DS));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier hlog DS get (%d)!" DSL_CRLF, errorCode));
         }
         else if (((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF) || (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE))
         {
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltHlog, DS, DSL_TRUE);
         }

         errorCode = DSL_G997_DEV_DeltSNRGet(pContext, nLine, DSL_DOWNSTREAM, DSL_AVX_CARRIER_DATA_GET(nLine, DeltSnr, DS));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier snr DS get (%d)!" DSL_CRLF, errorCode));
         }
         else if (((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF) || (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE))
         {
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltSnr, DS, DSL_TRUE);
         }

         errorCode = DSL_G997_DEV_DeltQLNGet(pContext, nLine, DSL_DOWNSTREAM, DSL_AVX_CARRIER_DATA_GET(nLine, DeltQln, DS));
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG (DSL_DBG_MSG, (pContext, ", Error during carrier qln DS get (%d)!" DSL_CRLF, errorCode));
         }
         else if (((DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF) || (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE))
         {
            DSL_AVX_CARRIER_DATA_VALID_SET(nLine, DeltQln, DS, DSL_TRUE);
         }
      }
#endif /* defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */

#if (DSL_DEV_TIMEOUT_FE_SNR_UPDATE > 0)
      /* Start 30sec timer to update SNR data */
      DSL_TimerDB_Restart(pContext, nLine,
                          DSL_DBS_FE_SNR_UPDATE_TIMEOUT_ID,
                          DSL_TIMEOUTEVENT_FE_SNR_UPDATE,
                          DSL_DEV_TIMEOUT_FE_SNR_UPDATE * DSL_TIMEOUT_FACTOR);
#endif /* (DSL_DEV_TIMEOUT_FE_SNR_UPDATE > 0) */
   }

   return (DSL_SUCCESS);
}

DSL_LOCAL DSL_Error_t DSL_AVX_FeTestParamCopy(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_DeltFeTypes_t nType,
   const DSL_uint16_t nNumItems,
   const DSL_uint16_t *pMsg,
   DSL_uint16_t *pValues)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint32_t i;

   switch (nType)
   {
   case DSL_DELT_FE_HLOG:
      for (i = 0; i < nNumItems; i++)
         pValues[i] = DSL_UINT16_SWAP(pMsg[i]);
      break;
   case DSL_DELT_FE_SNR:
   case DSL_DELT_FE_QLN:
      for (i = 0; i < nNumItems; i++)
      {
         if (i%2 == 1)
            pValues[i/2] |= pMsg[i/2] & 0xFF00;
         else
            pValues[i/2] = pMsg[i/2] & 0x00FF;
      }
      break;
   default:
      break;
   }

   return (errorCode);
}

/**
   This function retries to request the
   array DELT parameters for Hlog, QLN and SNR upstream/downstream.

   \param pContext   DSL library context
   \param nLine      Specifies for which line the function will apply, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_DeltFeRepeat(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_deltLineData_t *pLineData = DSL_NULL;
   DSL_deltDirectionData_t *pDirData = DSL_NULL;
   DSL_uint16_t nOffset = 0;

   DSL_DEBUG(DSL_DBG_MSG,
      (pContext, "DSL[%02d]: DSL_AVX_DeltFeRepeat" DSL_CRLF, nLine));

   pLineData = DSL_DeltLineDataGet(pContext, nLine);
   pDirData = DSL_DeltDirectionDataGet(pContext, nLine, DSL_DOWNSTREAM);
   if ((pLineData == DSL_NULL) || (pDirData == DSL_NULL))
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: there is no DELT data element for this line!" DSL_CRLF,
         nLine));
      return (DSL_ERROR);
   }

   nOffset = pDirData->rHlog.nCurrDataSize;
   if (pLineData->nLastMsgId & DSL_OHC_SINGLE_REQUEST)
   {
      DSL_DEBUG(DSL_DBG_MSG,
         (pContext, "DSL[%02d]: DSL_AVX_DeltFeRepeat: skip for single request" DSL_CRLF, nLine));
      return DSL_SUCCESS;
   }
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      DSL_CRLF "DSL[%02d]:DSL_AVX_DeltFeRepeat last data type, pDirData->nLastMsgId=%d" DSL_CRLF,
      nLine, pLineData->nLastMsgId));

   if (pContext->DeviceContext.LineFlags[nLine].nFeRequestRepetitions >= 2)
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         DSL_CRLF "DSL[%02d]:DSL_AVX_DeltFeRepeat tried %d times, still no data type %d, proceed with next data type " DSL_CRLF,
         nLine, pContext->DeviceContext.LineFlags[nLine].nFeRequestRepetitions, pLineData->nLastMsgId));
      pContext->DeviceContext.LineFlags[nLine].nFeRequestRepetitions = 0;
      switch (pLineData->nLastMsgId)
      {
      case DSL_OHC_TESTPARAM_ID_QLN:
         pLineData->nLastMsgId   =  DSL_OHC_TESTPARAM_ID_SNR;
         break;
      case DSL_OHC_TESTPARAM_ID_SNR:
         pLineData->nLastMsgId   =  DSL_OHC_TESTPARAM_ID_HLOG;
         break;
      case DSL_OHC_TESTPARAM_ID_HLOG:
         pLineData->nLastMsgId   =  DSL_OHC_TESTPARAM_ID_LAST;
         break;
      case DSL_OHC_TESTPARAM_ID_LAST:
      case DSL_OHC_TESTPARAM_ID_NONE:
      default:
         break;
      }

      if (pLineData->nLastMsgId == DSL_OHC_TESTPARAM_ID_LAST)
      {
         /* all data retrieved */
#ifndef DSL_DEBUG_DISABLE
         if (DSL_g_dbgLvl[DSL_DBG_BLOCK].nDbgLvl >= DSL_DBG_MSG)
         {
            _DSLAPI DSL_SeltDataPrintStatistics(pContext);
         }
#endif

#if (DSL_DEV_TIMEOUT_FE_SNR_UPDATE > 0)
         /* Start 30sec timer to update SNR data */
         DSL_TimerDB_Restart(pContext, nLine,
                             DSL_DBS_FE_SNR_UPDATE_TIMEOUT_ID,
                             DSL_TIMEOUTEVENT_FE_SNR_UPDATE,
                             DSL_DEV_TIMEOUT_FE_SNR_UPDATE * DSL_TIMEOUT_FACTOR);
#endif /* (DSL_DEV_TIMEOUT_FE_SNR_UPDATE > 0) */

         return (DSL_SUCCESS);
      }
   }

   /* Request next DELT data */
   if( nOffset < (VNX_MAX_SCGROUPS) )
   {
      /* To protect from an endless loop increment the retry counter
         even if \ref DSL_AVX_DeltArrayParamsQuery below will fail. */
      pContext->DeviceContext.LineFlags[nLine].nFeRequestRepetitions++;

      errorCode = DSL_AVX_DeltArrayParamsQuery(pContext, nLine,
         (DSL_uint16_t)(nOffset),
         (DSL_uint16_t)(DSL_MIN((nOffset + AVX_MAX_TESTPARAMS_BLOCK - 1),
                        (VNX_MAX_SCGROUPS-1))) );
      if(errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: failed to re-QueryDeltArrayParams!" DSL_CRLF, nLine));
         return (errorCode);
      }
      /* request was sent, start the timeout supervision,
         but give more time for this repetition */
      DSL_TimerDB_Add(pContext, nLine,
                      DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID,
                      DSL_TIMEOUTEVENT_DELT_FE_STATUS,
                      DSL_DEV_TIMEOUT_DELT_FE_STATUS * DSL_TIMEOUT_FACTOR *
                      (pContext->DeviceContext.LineFlags[nLine].nFeRequestRepetitions + 1));

   }
   return (DSL_SUCCESS);
}

/**
   This function requests a set of up to 60 entries of the DELT data.

   \param pContext   DSL library context
   \param nLine      Specifies for which line the function will apply, [I]
   \param nStartIndex Specifies the first tone group index to retrieve. [I]
   \param nStopIndex Specifies the last tone group index to retrieve. [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_DeltArrayParamsQuery(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint16_t nStartIndex,
   const DSL_uint16_t nStopIndex)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   AVX_CmdOhcTransmit_t sCmd;
   DSL_uint16_t nMsgLength = 0;
   const DSL_uint8_t nChannel = 0;

   DSL_CHECK_CTX_POINTER(pContext);
   DSL_CHECK_LINERANGE(nLine);

   /* for ADSL start and stop is ignored as always a single read is issued */

   memset(&sCmd, 0, sizeof(sCmd));

   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      DSL_uint16_t nStopIndexNew = 0, nMaxBlockSize = 0;

      if ((nStopIndex < nStartIndex) ||
         (nStopIndex > 511))
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_DeltArrayParamsQuery illegal params start %d stop %d"
            DSL_CRLF, nLine, nStartIndex, nStopIndex));
         return (DSL_ERROR);
      }

      /* check Vendor ID */
      if (memcmp(&pContext->G997.FeLineInventory[nLine].G994VendorID[2], DSL_VENDOR_ID_IKNS, 4) == 0)
         nMaxBlockSize = 10;
      else
         nMaxBlockSize = AVX_MAX_TESTPARAMS_BLOCK;

      nStopIndexNew = DSL_MIN(nStartIndex + nMaxBlockSize -1, nStopIndex);

      sCmd.DesReqType = 0x81;
      sCmd.DesReqType |= 5 << AVX_REQTYPE_POS; /* block read */
      DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
         DSL_CRLF "DSL[%02d]:DSL_AVX_DeltArrayParamsQuery request data block nStartIndex=%d, nStopIndex=%d" DSL_CRLF, nLine, nStartIndex, nStopIndexNew));
      sCmd.Data[0]   = DSL_UINT16_SWAP(nStartIndex);
      sCmd.Data[1]   = DSL_UINT16_SWAP(nStopIndexNew);
      nMsgLength = 6;
   }
   else
   {
      DSL_deltLineData_t *pLineData = DSL_NULL;

      pLineData = _DSLAPI DSL_DeltLineDataGet(pContext, nLine);
      if (pLineData == DSL_NULL)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: there is no DELT data element for this line!" DSL_CRLF,
            nLine));
         return (DSL_ERROR);
      }

      /* single reads:
         sequentially request all types, stop after the last request */
      sCmd.DesReqType = 0x0181;
      switch (pLineData->nLastMsgId & 0x00FF)
      {
      case DSL_OHC_TESTPARAM_ID_QLN:
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            DSL_CRLF "DSL[%02d]:DSL_AVX_DeltArrayParamsQuery request QLN data via OHC" DSL_CRLF, nLine));
         break;
      case DSL_OHC_TESTPARAM_ID_SNR:
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            DSL_CRLF "DSL[%02d]:DSL_AVX_DeltArrayParamsQuery request SNR data via OHC" DSL_CRLF, nLine));
         break;
      case DSL_OHC_TESTPARAM_ID_HLOG:
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            DSL_CRLF "DSL[%02d]:DSL_AVX_DeltArrayParamsQuery request HLOG data via OHC" DSL_CRLF, nLine));
         break;
      case DSL_OHC_TESTPARAM_ID_LAST:
      case DSL_OHC_TESTPARAM_ID_NONE:
      default:
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            DSL_CRLF "DSL[%02d]:DSL_AVX_DeltArrayParamsQuery invalid data type = %d" DSL_CRLF, nLine, pLineData->nLastMsgId));
         return DSL_ERROR;
      }
      sCmd.Data[0] = (DSL_uint16_t)pLineData->nLastMsgId & 0x00FF;
      nMsgLength = 3;
   }

   if (DSL_INT8_GET(DSL_DBL_MFS_OHC_ENABLE) != 0)
   {
#ifdef DSL_OHC_QUEUE
      nRet = DSL_AVX_OhcSendAsyncMessage(pContext,
               nLine,
               nMsgLength, &sCmd,
               (DSL_AVX_OhcCallback_t) DSL_AVX_DeltFeUpdate, DSL_NULL);
#else
      nRet = _DSLAPI DSL_AVX_SendMessage( pContext,
               nLine, MSGID_EXT(AVX_CMD_OHC_TRANSMIT),
               nMsgLength, (DSL_uint8_t*)&sCmd,
               0, DSL_NULL);
#endif
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
   }
   else
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DELT request skipped!" DSL_CRLF,
         nLine));
   }

   return (errorCode);
}

#ifndef DSL_DEBUG_DISABLE
DSL_LOCAL DSL_Error_t DSL_AVX_SeltDataPrintStatistics(
   DSL_Context_t *pContext)
{
   DSL_SELT_LineData_t *pLineData = DSL_NULL;
   DSL_uint32_t nSize = 0;
   DSL_int_t i = 0;

   if (pContext->pSeltDataList == DSL_NULL)
   {
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: No SELT data list available!" DSL_CRLF DSL_CRLF));

      return (DSL_SUCCESS);
   }

   pLineData = _DSLAPI DSL_SeltLineDataGetFirst(pContext);

   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      DSL_CRLF "DSL: SELT data statistics:" DSL_CRLF));

   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      "DSL: pFirst = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pContext->pSeltDataList->pFirst));
   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      "DSL: pLast = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pContext->pSeltDataList->pLast));
   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      "DSL: ------------------------------" DSL_CRLF));

   while (pLineData != DSL_NULL)
   {
      i += 1;

      /* Calculate size of used memory */
      nSize = 0;
      nSize += sizeof(DSL_SELT_LineData_t);

      if (pLineData->rFDR.pValues != DSL_NULL)
      {
         nSize += ((pLineData->nFDR_last - pLineData->nFDR_first) + 1)
                   *4*sizeof(DSL_uint16_t);
      }
      if (pLineData->rICN.pValues != DSL_NULL)
      {
         nSize += ((pLineData->nICN_last - pLineData->nICN_first) + 1)
                   *sizeof(DSL_uint16_t);
      }

      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: Element-Nr. = %d" DSL_CRLF, i));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: nLine = %d" DSL_CRLF, pLineData->nLine));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: nSize = %u" DSL_CRLF, nSize));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: nFDR_first = %u" DSL_CRLF, pLineData->nFDR_first));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: nFDR_last = %u" DSL_CRLF, pLineData->nFDR_last));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: nICN_first = %u" DSL_CRLF, pLineData->nICN_first));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: nICN_last = %u" DSL_CRLF, pLineData->nICN_last));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: pLineData = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pLineData));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: pPrevious = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pLineData->pPrevious));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: pNext = 0x%0lX" DSL_CRLF, (DSL_ulong_t)pLineData->pNext));
      DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
         "DSL: ------------------------------" DSL_CRLF));

      pLineData = _DSLAPI DSL_SeltLineDataGetNext(pContext, pLineData);
   }

   DSL_DEBUG_NOLINE(DSL_DBG_ERR, (pContext,
      "DSL: Total number of SELT data elements: %d" DSL_CRLF DSL_CRLF, i));

   return (DSL_SUCCESS);
}
#endif

/**
   This function verifies whether the given Message ID is applicable to the
   current FW and its specific state. The Applcability information has to be
   coded into the upper 16 bits of the 32bit message ID.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message has to be send, [I]
   \param nMsgId   Specifies the message ID as defined in the AVINAX firmware
                   message specification plus the applicability information
                   in the upper 16 bits, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_ApplicabilityCheck(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint32_t nMsgId)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint32_t   nAppblt = (nMsgId & DSL_VNX_PROPERTY_MASK);
   DSL_uint8_t nChannel = 0;
   DSL_uint32_t nLineState = 0;

   DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
      "DSL[%02d]: DSL_AVX_ApplicabilityCheck applicability 0x%04X"
      DSL_CRLF, nLine, nAppblt));

   if (nAppblt == 0)
   {
      DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
         "DSL[%02d]: DSL_AVX_ApplicabilityCheck empty applicability ignored"
         DSL_CRLF, nLine));
      return(errorCode);
   }

   /* check for ADSL/VDSL FW type */
   if (nAppblt & PROP_DSL_MASK)
   {
      if (((nAppblt & PROP_VDSL) == 0) &&
         (DSL_AVX_FwFeatureCheck(pContext, nLine, DSL_AVX_FW_ADSLA) == DSL_FALSE) &&
         (DSL_AVX_FwFeatureCheck(pContext, nLine, DSL_AVX_FW_ADSLB) == DSL_FALSE))
            errorCode = DSL_ERR_NOT_SUPPORTED_BY_FIRMWARE;
   }

   /* check for modem state only
      if a property different to "all states" is set */
   if ((nAppblt & PROP_STATE_MASK) &&
       ((nAppblt & PROP_ALL) == 0))
   {
      nLineState = DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE);
      switch (nLineState)
      {
      case DSL_LINESTATUS_IDLE:
         if ((nAppblt & AVX_PROP_IDLE) == 0)
            errorCode = DSL_ERR_MSG_ILLEGAL_STATE;
         break;
      case DSL_LINESTATUS_SHOWTIME_TC_SYNC:
      case DSL_LINESTATUS_SHOWTIME_NO_SYNC:
      case DSL_LINESTATUS_MELT_PARK:
         if ((nAppblt & AVX_PROP_SHOWTIME) == 0)
            errorCode = DSL_ERR_MSG_ILLEGAL_STATE;
         break;
      case DSL_LINESTATUS_EXCEPTION:
         if ((nAppblt & AVX_PROP_FAIL) == 0)
            errorCode = DSL_ERR_MSG_ILLEGAL_STATE;
         break;
      case DSL_LINESTATUS_LOOPDIAGNOSTIC_COMPLETE:
         if ((nAppblt & AVX_PROP_DELT_COMPLETE) == 0)
            errorCode = DSL_ERR_MSG_ILLEGAL_STATE;
         break;
      case DSL_LINESTATUS_SILENT:
      case DSL_LINESTATUS_HANDSHAKE:
      case DSL_LINESTATUS_FULL_INIT:
         if ((nAppblt & AVX_PROP_ACTIVATION) == 0)
            errorCode = DSL_ERR_MSG_ILLEGAL_STATE;
         break;
      case DSL_LINESTATUS_TEST:
      case DSL_LINESTATUS_TEST_LOOP:
      case DSL_LINESTATUS_TEST_MEDLEY:
      case DSL_LINESTATUS_TEST_REVERB:
         if ((nAppblt & AVX_PROP_TEST) == 0)
            errorCode = DSL_ERR_MSG_ILLEGAL_STATE;
         break;
      case DSL_LINESTATUS_SELT_COMPLETE:
      case DSL_LINESTATUS_SELT_DATA_REQUEST:
         if ((nAppblt & AVX_PROP_SELT_COMPLETE) == 0)
            errorCode = DSL_ERR_MSG_ILLEGAL_STATE;
         break;

      default:
         /* in any intermediate state no message shall be
            applied which is specific to any state handled above  */
         errorCode = DSL_ERR_MSG_ILLEGAL_STATE;
         break;
      }
   }

   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_ApplicabilityCheck applicability 0x%08X on MsgId 0x%04X ",
         nLine, nAppblt, (nMsgId & 0xFFFF)));
      switch(errorCode)
      {
      case DSL_ERR_MSG_ILLEGAL_STATE:
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "not suitable for current state 0x%X!" DSL_CRLF,
            nLineState));
         break;
      case DSL_ERR_NOT_SUPPORTED_BY_FIRMWARE:
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "not suitable for current FW type!" DSL_CRLF));
         break;
      default:
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "not suitable for current state or FW!" DSL_CRLF));
         break;
      }
   }

   return(errorCode);
}

DSL_LOCAL DSL_Error_t DSL_AVX_InitReadyCheck(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_DeviceContext_t *pDevCtx = &pContext->DeviceContext;
   DSL_uint32_t nDeviceLineMaskBit = 0, nDevMask = 0;
   DSL_uint16_t nAvxDev = 0;
   DSL_uint8_t nChRel = 0;
   DSL_boolean_t bSemMask = DSL_FALSE;
   /* Will be used by data base access macro and has to be set fixed to '0'
      because the configuration settings in this function are (bearer) channel
      independent  */
   static const DSL_uint8_t nChannel = 0;

   DSL_CHECK_CTX_POINTER(pContext);

   DSL_GET_DEVICE_NUMBER(nLine, nAvxDev);
   DSL_DEV_GET_CHANNEL_NUMBER(nLine, nChRel);

   nDeviceLineMaskBit = 1 << (nChRel);

   DSL_DEBUG( DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_InitReadyCheck dev %d: AttemptMask=0x%08X SuccessMask=0x%08X, nDeviceLineMaskBit=0x%08X" DSL_CRLF ,
      nLine, nAvxDev,
      pDevCtx->Init.nLineInitAttemptMask[nAvxDev], pDevCtx->Init.nLineInitSuccessMask[nAvxDev], nDeviceLineMaskBit));

   /* Processing for initialization ready handling has to be done only once
      for each line */
   if (  (pDevCtx->Init.nLineInitAttemptMask[nAvxDev] & nDeviceLineMaskBit) &&
        !(pDevCtx->Init.nLineInitSuccessMask[nAvxDev] & nDeviceLineMaskBit) )
   {
      DSL_SemaphoreGet(&pDevCtx->Init.LineInitSemaphore, 0xFFFFFFFF);

      /* Line initialization succeeded. */
      pDevCtx->Init.nLineInitSuccessMask[nAvxDev] |= nDeviceLineMaskBit;

      /* Check if initialization succeeded for all lines of the according device*/
      if ( (pDevCtx->Init.nRefLineInitMask & pDevCtx->Init.nLineInitAttemptMask[nAvxDev])
           == pDevCtx->Init.nLineInitSuccessMask[nAvxDev] )
      {
         switch(DSL_DeviceStatusGet(pContext, nAvxDev))
         {
         /* In case of initialization ready event processing the system status for
            the according device is still uninitilized (DSL_DEVSTATE_NOT_USED) */
         /*case DSL_DEVSTATE_NOT_USED:*/
         case DSL_DEVSTATE_INIT:
         case DSL_DEVSTATE_REINITIALIZATION:
            pDevCtx->Init.nDeviceInitMask |= (1 << nAvxDev);
            DSL_DeviceStatusSet(pContext, nAvxDev, DSL_DEVSTATE_NORMAL_OPERATION);

            /* remove the current device from the list of recovering devices */
            pDevCtx->Init.nDeviceRecoveryMask &= ~ (1 << nAvxDev);
               
            /* Check if all devices are handled for initialization procedure */
            if ( ( pDevCtx->Init.nRefDeviceInitMask &
                   pDevCtx->Init.nDeviceInitMask ) ==
                 pDevCtx->Init.nRefDeviceInitMask )
            {
               /* Initialization handling procedure finished here:
                  + Remove timeout event handler
                  + Execute additional initialization procedures if necessary
                  + Send initialization ready event if wanted */
               DSL_Timeout_RemoveEvent(pContext, 0, pDevCtx->Init.nTimeoutID[0]);
               pDevCtx->Init.nTimeoutID[0] = 0;

               /* Set new device mask in common device context for later usage */
               nDevMask = pDevCtx->Init.nDeviceInitMask;
               DSL_DeviceMaskSet(pContext, nDevMask);

               /* check if all devices are recovered */
               if ( pDevCtx->Init.nDeviceRecoveryMask == 0 )
               {
                  DSL_DEBUG( DSL_DBG_WRN, (pContext,
                     "DSL[%02d]: Initialization ready event (nDevMask="
                     "0x%08X)" DSL_CRLF , nLine, nDevMask));

                  if (pContext->pEventCallback != DSL_NULL)
                  {
                     bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBI_SEM_INIT_READY));
                     if (bSemMask == DSL_FALSE)
                     {
                        DSL_CB_DATA_InitReadyStatus_t nCbData;

                        memset(&nCbData, 0, sizeof(nCbData));

                        nCbData.nInitReadyStatus.nDeviceMask = nDevMask;
                        nCbData.nInitReadyStatus.nDeviceMaskLast = pDevCtx->Init.nDeviceRecoveryMaskLast;
                        memcpy(nCbData.nInitReadyStatus.nLineMask,
                              pDevCtx->Init.nLineInitSuccessMask,
                              sizeof(pDevCtx->Init.nLineInitSuccessMask));

                        (void)(pContext->pEventCallback)( pContext,
                                                    nLine,
                                                    DSL_CHANNEL_NA,
                                                    DSL_ACCESSDIR_NA,
                                                    DSL_ATUDIR_NA,
                                                    DSL_CBS_INIT_READY,
                                                    (DSL_CB_DATA_Union_t *)&nCbData );
                     }
                  }
                  pDevCtx->Init.nDeviceRecoveryMaskLast = 0;
               }
            }
            else
            {
               DSL_DEBUG( DSL_DBG_WRN, (pContext,
                  "DSL[%02d]: DSL_AVX_InitReadyCheck - Mask mismatch (nRefDeviceInitMask= %02X, "
                   "nDeviceInitMask = %02X) " DSL_CRLF , nLine,
                   pDevCtx->Init.nRefDeviceInitMask,
                   pDevCtx->Init.nDeviceInitMask ));
            }
            break;
         case DSL_DEVSTATE_NORMAL_OPERATION:
            DSL_DEBUG( DSL_DBG_WRN, (pContext,
               "DSL[%02d]: DSL_AVX_InitReadyCheck: Device status (%d) not "
               "intended to be handled for device %u" DSL_CRLF , nLine,
               DSL_DeviceStatusGet(pContext, nAvxDev), nAvxDev));
            break;
         case DSL_DEVSTATE_INIT_FAILED:
            /* The DSL_DEVSTATE_INIT_FAILED is intended to be for the failed device,
               but fail indication will be reported via DSL_AVX_OnTimeoutEvent_ApiInit */
            break;
         default:
            DSL_DEBUG( DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_InitReadyCheck: Device status (%d) not handled "
               "for device %u" DSL_CRLF , nLine,
               DSL_DeviceStatusGet(pContext, nAvxDev), nAvxDev));
            errorCode = DSL_ERROR;
            break;
         }
      }
      DSL_SemaphoreSet(&pDevCtx->Init.LineInitSemaphore);
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_SeltFDRUpdate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t        errorCode = DSL_SUCCESS;
   DSL_uint16_t       nCopyLen = 0, nOffset = 0;
   DSL_SELT_LineData_t *pLineData = DSL_NULL;
   DSL_uint16_t       szMem = 0;
   DSL_uint16_t       idx=0, nChannel=0;
   const DSL_uint16_t chunk_size = 32; /* 32 elements in the array AVX_VnxUer_t UerPs[32]; */
   DSL_SELT_DataCollectionMethod_t nDataCollectMethod = DSL_SELT_FDR_AND_ICN;

   AVX_CmdSeltUer4kGet_t sCmd;
   AVX_AckSeltUer4kGet_t sAck;

   DSL_CHECK_CTX_POINTER(pContext);
   DSL_CHECK_LINERANGE(nLine);

   DSL_DEBUG(DSL_DBG_MSG,
      (pContext, "DSL[%02d]: DSL_AVX_SeltFDRUpdate" DSL_CRLF, nLine));

   nDataCollectMethod =
      (DSL_SELT_DataCollectionMethod_t)DSL_UINT16_GET(DSL_DBL_SELTCONFIG_DATA_COLLECT_METHOD);
   switch (nDataCollectMethod)
   {
   case DSL_SELT_FDR_AND_ICN:
   case DSL_SELT_FDR_ONLY:
      break;
   default:
      return (DSL_SUCCESS);
   }

   pLineData = _DSLAPI DSL_SeltLineDataGet(pContext, nLine);
   if ((pLineData == DSL_NULL))
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext, "DSL[%02d]: there is no SELT params entry for this line!"
          DSL_CRLF, nLine));
      return (DSL_ERROR);
   }

   pLineData->nFDR_first = DSL_UINT16_GET(DSL_DBL_SELTCONFIG_FDR_START_TONE);
   pLineData->nFDR_last = DSL_UINT16_GET(DSL_DBL_SELTCONFIG_FDR_STOP_TONE);

   if (pLineData->rFDR.pValues != DSL_NULL)
   {
      DSL_Free(pLineData->rFDR.pValues);
      pLineData->rFDR.pValues = DSL_NULL;
   }
   /* 8 Bytes values per tone */
   szMem = ((pLineData->nFDR_last - pLineData->nFDR_first) + 1)
            *sizeof(sAck.UerPs[0]);
   if( pLineData->rFDR.pValues == DSL_NULL )
   {
      DSL_DEBUG(DSL_DBG_MSG,
                  (pContext, "DSL[%02d]: FDR update - allocate memory for FDR(first=0x%x "
                  "last=0x%x)." DSL_CRLF, nLine, pLineData->nFDR_first,
                  pLineData->nFDR_last));
      pLineData->rFDR.pValues = (DSL_uint16_t*)DSL_Malloc(szMem);
      if( pLineData->rFDR.pValues == DSL_NULL )
      {
         DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: failed to allocate memory for "
                     "FDR(first=0x%x last=0x%x)!" DSL_CRLF,
                     nLine, pLineData->nFDR_first, pLineData->nFDR_last));
         return (DSL_ERROR);
      }
      memset(pLineData->rFDR.pValues, 0, szMem);
   }

   for(idx = pLineData->nFDR_first; idx < pLineData->nFDR_last; idx += chunk_size)
   {
      /* request data */
      memset(&sCmd, 0, sizeof(sCmd));
      memset(&sAck, 0, sizeof(sAck));

      if( (idx+chunk_size) > (pLineData->nFDR_last+1))
      {
         sCmd.NumRead = sizeof(sAck.UerPs[0])*(((pLineData->nFDR_last + 1) - pLineData->nFDR_first) % chunk_size);
      }
      else
      {
         sCmd.NumRead = sizeof(sAck.UerPs[0])*chunk_size;
      }
      errorCode = DSL_AVX_SendMessageArrayIndex (pContext, nLine, MSGID_EXT(AVX_CMD_SELT_UER_4K_GET),
         sizeof(sCmd), (DSL_uint8_t*)&sCmd,
         sizeof(sAck), (DSL_uint8_t*)&sAck, sizeof(sAck.UerPs[0]) * (idx));

      if(errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: failed to allocate memory for "
                     "AVX_CMD_SELT_UER_GET failed" DSL_CRLF, nLine));
         return errorCode;
      }

      /* store data */
      nCopyLen = sCmd.NumRead;
      nOffset = pLineData->rFDR.nCurrDataSize;
      if (((sizeof(DSL_uint16_t)*nOffset) + nCopyLen) > szMem)
      {
            DSL_DEBUG(DSL_DBG_ERR,
                        (pContext, "DSL[%02d]: FDR update - attempt to write too much data "
                        "(first=%d last=%d nOffset=%d, nCopyLen=%d length=%d)!" DSL_CRLF,
                        nLine, pLineData->nFDR_first, pLineData->nFDR_last, nOffset, nCopyLen,
                        szMem));
            return (DSL_ERROR);
      }

      memcpy(&(pLineData->rFDR.pValues[nOffset]), &sAck.UerPs[0], nCopyLen);

      pLineData->rFDR.nCurrDataSize += nCopyLen / sizeof(DSL_uint16_t);
   }

   pLineData->nError = AVX_SELT_COMPLETE;

#ifndef DSL_DEBUG_DISABLE
   if (DSL_g_dbgLvl[DSL_DBG_BLOCK].nDbgLvl >= DSL_DBG_MSG)
   {
      _DSLAPI DSL_AVX_SeltDataPrintStatistics(pContext);
   }
#endif
   return (DSL_SUCCESS);
}

DSL_LOCAL DSL_Error_t DSL_AVX_SeltFDRVarUpdate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t        errorCode = DSL_SUCCESS;
   DSL_uint16_t       nCopyLen = 0, nOffset = 0;
   DSL_SELT_LineData_t *pLineData = DSL_NULL;
   DSL_uint16_t       szMem = 0;
   DSL_uint16_t       idx=0;
   const DSL_uint16_t chunk_size = 128; /* 128 elements in the array uint16 UerVariance[128]; */
   const DSL_uint8_t nChannel = 0;
   DSL_SELT_DataCollectionMethod_t nDataCollectMethod = DSL_SELT_FDR_AND_ICN;

   AVX_CmdSeltUerVar4kGet_t sCmd;
   AVX_AckSeltUerVar4kGet_t sAck;

   DSL_CHECK_CTX_POINTER(pContext);
   DSL_CHECK_LINERANGE(nLine);

   DSL_DEBUG(DSL_DBG_MSG,
      (pContext, "DSL[%02d]: DSL_GMXD_SeltFDRVarUpdate" DSL_CRLF, nLine));

   nDataCollectMethod =
      (DSL_SELT_DataCollectionMethod_t)DSL_UINT16_GET(DSL_DBL_SELTCONFIG_DATA_COLLECT_METHOD);
   switch (nDataCollectMethod)
   {
   case DSL_SELT_FDR_AND_ICN:
   case DSL_SELT_FDR_ONLY:
      break;
   default:
      return (DSL_SUCCESS);
   }

   pLineData = _DSLAPI DSL_SeltLineDataGet(pContext, nLine);
   if ((pLineData == DSL_NULL))
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext, "DSL[%02d]: there is no SELT params entry for this line!"
          DSL_CRLF, nLine));
      return (DSL_ERROR);
   }

   pLineData->nFDRVar_first = DSL_UINT16_GET(DSL_DBL_SELTCONFIG_FDR_START_TONE);
   pLineData->nFDRVar_last = DSL_UINT16_GET(DSL_DBL_SELTCONFIG_FDR_STOP_TONE);

   if (pLineData->rFDRVar.pValues != DSL_NULL)
   {
      DSL_Free(pLineData->rFDRVar.pValues);
      pLineData->rFDRVar.pValues = DSL_NULL;
   }
   szMem = ((pLineData->nFDRVar_last - pLineData->nFDRVar_first) + 1) * sizeof(DSL_uint16_t);
   if( pLineData->rFDRVar.pValues == DSL_NULL )
   {
      DSL_DEBUG(DSL_DBG_MSG,
                  (pContext, "DSL[%02d]: FDR Var update - allocate memory for FDR Var(first=0x%x "
                  "last=0x%x, szMem=0x%x)." DSL_CRLF, nLine, pLineData->nFDRVar_first,
                  pLineData->nFDRVar_last, szMem));
      pLineData->rFDRVar.pValues = (DSL_uint16_t*)DSL_Malloc(szMem);
      if( pLineData->rFDRVar.pValues == DSL_NULL )
      {
         DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: failed to allocate memory for "
                     "FDR Var(first=0x%x last=0x%x)!" DSL_CRLF,
                     nLine, pLineData->nFDRVar_first, pLineData->nFDRVar_last));
         return (DSL_ERROR);
      }
      memset(pLineData->rFDRVar.pValues, 0, szMem);
   }

   for(idx = pLineData->nFDRVar_first; idx < pLineData->nFDRVar_last; idx += chunk_size)
   {
      /* request data */
      memset(&sCmd, 0, sizeof(sCmd));
      memset(&sAck, 0, sizeof(sAck));

      if((idx + chunk_size)  > (pLineData->nFDRVar_last + 1))
      {
         /* request last block */
         sCmd.NumRead = (((pLineData->nFDRVar_last - pLineData->nFDRVar_first) + 1)% chunk_size)* sizeof(sAck.UerVariance[0]);
      }
      else
      {
         sCmd.NumRead = chunk_size * sizeof(sAck.UerVariance[0]);
      }
      errorCode = DSL_AVX_SendMessageArrayIndex (pContext, nLine, MSGID_EXT(AVX_CMD_SELT_UER_VAR_4K_GET),
         sizeof(sCmd), (DSL_uint8_t*)&sCmd,
         sizeof(sAck), (DSL_uint8_t*)&sAck, sizeof(sAck.UerVariance[0]) * idx);

      if(errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: failed to allocate memory for "
                     "CMD_SELT_UER_VAR_GET failed" DSL_CRLF, nLine));
         return errorCode;
      }

      /* store data */
      nCopyLen = sCmd.NumRead;
      nOffset = pLineData->rFDRVar.nCurrDataSize;

      if ((sizeof(DSL_uint16_t)*nOffset + nCopyLen) > szMem)
      {
            DSL_DEBUG(DSL_DBG_ERR,
                        (pContext, "DSL[%02d]: ICN update - attempt to write too much data "
                        "(start=0x%x last=0x%x nOffset=0x%x length=0x%x)!" DSL_CRLF,
                        nLine, idx, pLineData->nFDRVar_last, nOffset,
                        szMem));
            return (DSL_ERROR);
      }

      pLineData->rFDRVar.nCurrDataSize += nCopyLen / sizeof(DSL_uint16_t);

      memcpy(&(pLineData->rFDRVar.pValues[nOffset]), &sAck.UerVariance[0], nCopyLen);
   }

#ifndef DSL_DEBUG_DISABLE
   if (DSL_g_dbgLvl[DSL_DBG_BLOCK].nDbgLvl >= DSL_DBG_MSG)
   {
      _DSLAPI DSL_AVX_SeltDataPrintStatistics(pContext);
   }
#endif
   return (DSL_SUCCESS);
}

DSL_LOCAL DSL_Error_t DSL_AVX_SeltCpeDetect(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   AVX_AckSeltStatusGet_t sAck;
   AVX_CmdSeltStatusGet_t sCmd;
   DSL_SELT_LineData_t *pLineData = DSL_NULL;
   static const DSL_uint8_t nChannel = 0;

   DSL_CHECK_CTX_POINTER(pContext);
   DSL_CHECK_LINERANGE(nLine);

   DSL_DEBUG( DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_SendMsgSeltStatusGet()" DSL_CRLF, nLine));

   pLineData = _DSLAPI DSL_SeltLineDataGet(pContext, nLine);
   if ((pLineData == DSL_NULL))
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext, "DSL[%02d]: there is no SELT params entry for this line!"
          DSL_CRLF, nLine));
      return (DSL_ERROR);
   }
   pLineData->bCpeDetected = DSL_FALSE;

   if (DSL_INT8_GET(DSL_DBL_MFS_SELT_CPE_DETECTION_DISABLE) == 1)
      return DSL_SUCCESS;

   memset(&sCmd, 0, sizeof(sCmd));
   memset(&sAck, 0, sizeof(sAck));


   sCmd.NumRead = sizeof(sAck);
   errorCode = DSL_AVX_SendMessage( pContext,
                     nLine, MSGID_EXT(AVX_CMD_SELT_STATUS_GET),
                     sizeof(sCmd), (DSL_uint8_t *)&sCmd,
                     sizeof(sAck), (DSL_uint8_t *)&sAck);

   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during DSL_AVX_SendMsgSeltStatusGet!" DSL_CRLF, nLine);

   pLineData->bCpeDetected = (DSL_boolean_t) DSL_BIT_GET(sAck.SeltStatus0, AVX_2002_CPE_DETECTED_POS);

   return (errorCode);
}

DSL_LOCAL DSL_Error_t DSL_AVX_SeltICNUpdate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t        errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_uint16_t       nCopyLen = 0, nOffset = 0;
   DSL_SELT_LineData_t *pLineData = DSL_NULL;
   DSL_uint16_t       szMem = 0;
   DSL_uint16_t       idx=0;
   const DSL_uint16_t chunk_size = 128; /* 128 elements in the array uint16 QlnPs[128]; */
   const DSL_uint8_t nChannel = 0;
   DSL_SELT_DataCollectionMethod_t nDataCollectMethod = DSL_SELT_FDR_AND_ICN;
   AVX_CmdSeltQln4kGet_t sCmd;
   AVX_AckSeltQln4kGet_t sAck;
   DSL_SELT_PsdType_t nPsdType;
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1) 
   AVX_CmdSeltQln8kGet_t sCmd8k;
   AVX_AckSeltQln8kGet_t sAck8k;
#endif

   DSL_CHECK_CTX_POINTER(pContext);
   DSL_CHECK_LINERANGE(nLine);

   DSL_DEBUG(DSL_DBG_MSG,
      (pContext, "DSL[%02d]: DSL_AVX_SeltICNUpdate" DSL_CRLF, nLine));

   nDataCollectMethod =
      (DSL_SELT_DataCollectionMethod_t)DSL_UINT16_GET(DSL_DBL_SELTCONFIG_DATA_COLLECT_METHOD);
   switch (nDataCollectMethod)
   {
   case DSL_SELT_FDR_AND_ICN:
   case DSL_SELT_ICN_ONLY:
      break;
   default:
      return (DSL_SUCCESS);
   }

   pLineData = _DSLAPI DSL_SeltLineDataGet(pContext, nLine);
   if ((pLineData == DSL_NULL))
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext, "DSL[%02d]: there is no SELT params entry for this line!"
          DSL_CRLF, nLine));
      return (DSL_ERROR);
   }

   pLineData->nICN_first = DSL_UINT16_GET(DSL_DBL_SELTCONFIG_ICN_START_TONE);
   pLineData->nICN_last  = DSL_UINT16_GET(DSL_DBL_SELTCONFIG_ICN_STOP_TONE);

   if (pLineData->rICN.pValues != DSL_NULL)
   {
      DSL_Free(pLineData->rICN.pValues);
      pLineData->rICN.pValues = DSL_NULL;
   }
   szMem = ((pLineData->nICN_last - pLineData->nICN_first) + 1) * sizeof(DSL_uint16_t);
   if( pLineData->rICN.pValues == DSL_NULL )
   {
      DSL_DEBUG(DSL_DBG_MSG,
                  (pContext, "DSL[%02d]: ICN update - allocate memory for ICN(first=0x%x "
                  "last=0x%x, szMem=0x%x)." DSL_CRLF, nLine, pLineData->nICN_first,
                  pLineData->nICN_last, szMem));
      pLineData->rICN.pValues = (DSL_uint16_t*)DSL_Malloc(szMem);
      if( pLineData->rICN.pValues == DSL_NULL )
      {
         DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: failed to allocate memory for "
                     "ICN(first=0x%x last=0x%x)!" DSL_CRLF,
                     nLine, pLineData->nICN_first, pLineData->nICN_last));
         return (DSL_ERROR);
      }
      memset(pLineData->rICN.pValues, 0, szMem);
   }

   for(idx = pLineData->nICN_first; idx < pLineData->nICN_last; idx += chunk_size)
   {
      /* request data */
      memset(&sCmd, 0, sizeof(sCmd));
      memset(&sAck, 0, sizeof(sAck));

      if((idx + chunk_size)  > (pLineData->nICN_last + 1))
      {
         /* request last block */
         sCmd.NumRead = (((pLineData->nICN_last - pLineData->nICN_first) + 1)% chunk_size)* sizeof(sAck.QlnPs[0]);
      }
      else
      {
         sCmd.NumRead = chunk_size * sizeof(sAck.QlnPs[0]);
      }
      
      nPsdType = (DSL_SELT_PsdType_t)DSL_UINT16_GET(DSL_DBL_SELTCONFIG_PSD_TYPE);
      
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1) 
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A) && (
         (nPsdType == DSL_SELT_DEFAULT  ) || (nPsdType == DSL_SELT_CURRENT) || (nPsdType == DSL_SELT_CURRENT_VDSL2)))
      {
         errorCode = DSL_AVX_SendMessageArrayIndex (pContext, nLine, MSGID_EXT(AVX_CMD_SELT_QLN_8K_GET),
            sizeof(sCmd8k), (DSL_uint8_t*)&sCmd8k,
            sizeof(sAck8k), (DSL_uint8_t*)&sAck8k, sizeof(sAck8k.QlnPs[0]) * idx);
      }
      else
#endif /* #if (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
      {
         errorCode = DSL_AVX_SendMessageArrayIndex (pContext, nLine, MSGID_EXT(AVX_CMD_SELT_QLN_4K_GET),
            sizeof(sCmd), (DSL_uint8_t*)&sCmd,
            sizeof(sAck), (DSL_uint8_t*)&sAck, sizeof(sAck.QlnPs[0]) * idx);
      }
      if(errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: failed to allocate memory for "
                     "CMD_SELT_QLN_GET failed" DSL_CRLF, nLine));
         return errorCode;
      }

      /* store data */
      nCopyLen = sCmd.NumRead;
      nOffset = pLineData->rICN.nCurrDataSize;

      if ((sizeof(DSL_uint16_t)*nOffset + nCopyLen) > szMem)
      {
         DSL_DEBUG(DSL_DBG_ERR,
                     (pContext, "DSL[%02d]: ICN update - attempt to write too much data "
                     "(start=0x%x last=0x%x nOffset=0x%x length=0x%x)!" DSL_CRLF,
                     nLine, idx, pLineData->nICN_last, nOffset,
                     szMem));
         return (DSL_ERROR);
      }

      pLineData->rICN.nCurrDataSize += nCopyLen / sizeof(DSL_uint16_t);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1) 
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A) && (
         (nPsdType == DSL_SELT_DEFAULT  ) || (nPsdType == DSL_SELT_CURRENT) || (nPsdType == DSL_SELT_CURRENT_VDSL2)))
      {
         memcpy(&(pLineData->rICN.pValues[nOffset]), &sAck8k.QlnPs[0], nCopyLen);
      }
      else
#endif /* #if (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
      {
         memcpy(&(pLineData->rICN.pValues[nOffset]), &sAck.QlnPs[0], nCopyLen);
      }
   }

   if (pLineData->nError & AVX_SELT_ICN_REQUEST)
   {
      pLineData->nError &= ~AVX_SELT_ICN_REQUEST;
      pLineData->nError |= AVX_SELT_ICN_COMPLETE;
   }
   else
   {
      DSL_DEBUG(DSL_DBG_ERR,
                  (pContext, "DSL[%02d]: ICN update - line in wrong SELT state 0x%04X!" DSL_CRLF,
                  nLine, pLineData->nError));
      return (DSL_ERROR);
   }

   switch (nDataCollectMethod)
   {
   case DSL_SELT_FDR_AND_ICN:
      nRet = DSL_AVX_SeltAbort(pContext, nLine);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode, "OUT - ERROR DSL_AVX_SeltICNUpdate() - Cannot stop prev measurement" , nLine );

      if (nRet == DSL_WRN_DSM_IDLE_REQUEST_PENDING)
      {
         nRet = DSL_AVX_PollDevForModemState(pContext, nLine, AVX_IDLE_MASK, 20);
         DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode, "DSL_AVX_PollDevForModemState failed!" DSL_CRLF, nLine);
      }

      nRet = DSL_AVX_SendMsgSeltConfigure(pContext, nLine, DSL_FALSE);
      if (nRet != DSL_SUCCESS)
      {
         DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_FALSE, errorCode,
            "OUT - ERROR DSL_AVX_SeltICNUpdate() - Cannot send configuration "
            "parameters for SELT" , nLine );
      }
      nRet = DSL_AVX_SendMsgModemStateSet(pContext, nLine, AVX_SELT_MASK);
      if (nRet != DSL_SUCCESS)
      {
         /* Set LINIT value to 'LINIT_UNKNOWN' in case of an error */
         DSL_AVX_HandleLinitValue(pContext, nLine, LINIT_UNKNOWN, LINIT_SUB_NONE, DSL_FALSE);
      }
      DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
      break;
   case DSL_SELT_ICN_ONLY:
      pLineData->nError = AVX_SELT_COMPLETE;
      break;
   default:
      break;
   }

#ifndef DSL_DEBUG_DISABLE
   if (DSL_g_dbgLvl[DSL_DBG_BLOCK].nDbgLvl >= DSL_DBG_MSG)
   {
      _DSLAPI DSL_AVX_SeltDataPrintStatistics(pContext);
   }
#endif
   return (errorCode);
}

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_ApsFsmStateSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_ApsStates_t nApsStateNew)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_ApsStates_t *pApsStateCurr = &(pContext->DeviceContext.LineFlags[nLine].nApsState);

   /* no change */
   if (*pApsStateCurr == nApsStateNew)
      return errorCode;

   switch (*pApsStateCurr)
   {
   case DSL_APS_DISABLED:
      /* from disabled only the enableing is allowed */
      switch (nApsStateNew)
      {
      case DSL_APS_ENABLED:
         *pApsStateCurr = DSL_APS_ACTIVE;
         break;
      default:
         errorCode = DSL_ERROR;
      }
      break;

   case DSL_APS_ENABLED:
      /* this state should never occur */
      switch (nApsStateNew)
      {
      case DSL_APS_DISABLED:
      case DSL_APS_ACTIVE:
         *pApsStateCurr = nApsStateNew;
         break;
      default:
         errorCode = DSL_ERROR;
      }
      break;

   case DSL_APS_ACTIVE:
      switch (nApsStateNew)
      {
      case DSL_APS_ENABLED:
         *pApsStateCurr = DSL_APS_ACTIVE;
         break;
      case DSL_APS_DISABLED:
      case DSL_APS_RECONFIG:
      case DSL_APS_FINISHED:
         *pApsStateCurr = nApsStateNew;
         break;
      default:
         errorCode = DSL_ERROR;
      }
      break;

   case DSL_APS_RECONFIG:
      switch (nApsStateNew)
      {
      case DSL_APS_ENABLED:
         *pApsStateCurr = DSL_APS_ACTIVE;
         break;
      case DSL_APS_DISABLED:
      case DSL_APS_ACTIVE:
         *pApsStateCurr = nApsStateNew;
         break;
      default:
         errorCode = DSL_ERROR;
      }
      break;

   case DSL_APS_FINISHED:
      switch (nApsStateNew)
      {
      case DSL_APS_ENABLED:
         *pApsStateCurr = DSL_APS_ACTIVE;
         break;
      case DSL_APS_DISABLED:
      case DSL_APS_ACTIVE:
         *pApsStateCurr = nApsStateNew;
         break;
      default:
         errorCode = DSL_ERROR;
      }
      break;
   }

   if (errorCode == DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_ApsFsmStateSet %d done" DSL_CRLF ,
         nLine, nApsStateNew));
   }
   else
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_ApsFsmStateSet %d not set" DSL_CRLF ,
         nLine, nApsStateNew));
   }

   return(errorCode);
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_ApsStates_t DSL_AVX_ApsFsmStateGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   return (pContext->DeviceContext.LineFlags[nLine].nApsState);
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   Do the Auto Profile Selection.
   This is possible in two different ways:
   1) selection from a look-up table using the current kl0 value
   2) measurement of current line rate and estimation for alternative
      configurations
   Each method may result in a reconfiguration and retrain of the line.
   The APS States are used to handle the flow.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_ApsDecision(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   const DSL_uint16_t nChannel = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_ApsDecision" DSL_CRLF , nLine));

   switch (DSL_UINT8_GET(DSL_DBL_APS_MODE))
   {
   case DSL_APS_MODE_LENGTH:
      nRet = DSL_AVX_ApsTableLookup(pContext, nLine);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
      break;

   case DSL_APS_MODE_AUTO:
      nRet = DSL_AVX_ApsAutoModeProcess(pContext, nLine);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
      break;

   case DSL_APS_MODE_OFF:
   default:
      break;
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_ApsDecision" DSL_CRLF , nLine));

   return(errorCode);
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   Decide from a look-up table using the current kl0 value which
   configuration to use.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_ApsTableLookup(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_ApsTable_t sApsTable;
   DSL_G997_UsPowerBackOffStatus_t sUpboStatus;
   const DSL_uint16_t nChannel = 0;
   DSL_uint16_t i;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_ApsTableLookup" DSL_CRLF , nLine));

   nRet = DSL_DEV_APS_TableGet(pContext, nLine, &sApsTable);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   /* get the estimated electrical length */
   nRet = DSL_G997_DEV_UsPowerBackOffStatusGet(pContext, nLine, &sUpboStatus);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   /* find the shortest loop including the current measured one,
      Table entries are assumed to be sorted in descending order */
   for (i = 0; i < DSL_APS_TABLE_LENGTH - 1; i++)
   {
      if (sUpboStatus.nElectricalLength >=
            sApsTable.ApsTableEntry[i + 1].nMaxElLength)
         break;
   }

   /* check if the config to be used is the one currently used,
      or if a retrain is needed */
   if (DSL_UINT8_GET(DSL_DBL_CONFIG_PROFILE) ==
         sApsTable.ApsTableEntry[i].nUserSlotId)
   {
      /* config is ok, stay in showtime */
      nRet = _DSLAPI DSL_AVX_ApsFsmStateSet(pContext, nLine, DSL_APS_FINISHED);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
   }
   else
   {
      /* change the config and change the APS state
         to apply the new config later and trigger the restart*/
      DSL_CHECK_PROFILERANGE(sApsTable.ApsTableEntry[i].nUserSlotId);
      DSL_UINT8_SET(DSL_DBL_CONFIG_PROFILE, sApsTable.ApsTableEntry[i].nUserSlotId);

      nRet = _DSLAPI DSL_AVX_ApsFsmStateSet(pContext, nLine, DSL_APS_RECONFIG);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_ApsTableLookup" DSL_CRLF , nLine));

   return(errorCode);
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   Decide on a line rate calculation which
   configuration to use.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_ApsAutoModeProcess(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
#if 0
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
/* FIXME: not complete! */
   DSL_ApsTable_t sApsTable;
   const DSL_uint16_t nChannel = 0;
   DSL_uint16_t i=0, nMaxUsedToneDs = 0;
   DSL_G997_NSCData8_t  *pSnr30ds = DSL_NULL,
                        *pSnr17ds = DSL_NULL,
                        *pSnr8ds  = DSL_NULL;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_ApsAutoModeProcess" DSL_CRLF , nLine));

   /* find the maximum frequency DS to use */
   nRet = DSL_AVX_MaxUsedToneGet(pContext, nLine, DSL_DOWNSTREAM, &nMaxUsedToneDs);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   /* get the current SNR DS*/
   /* FIXME: pSnr30ds is DSL_NULL here !!! */
   nRet = DSL_G997_DEV_SNRNSCGet(pContext, nLine, DSL_DOWNSTREAM, pSnr30ds);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   nRet = DSL_APS_TableGet(pContext, nLine, &sApsTable);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   /* for x in [17, 8] */

   /* calculate SNRx = SNR30 + PSDx - PSD30 */
   pSnr17ds = pSnr30ds;
   pSnr8ds = pSnr30ds;

   /* calculate AttLinRate_x from SNRx */

   /* if AttLRx > AttLR_current change config and retrain */


   /* check if the config to be used is the one currently used,
      or if a retrain is needed */
   /* FIXME: this is not a clean solution, because the current config might
      have been changed since it was synchronized with one of the user
      configs. But this will be solved by using real profiles instead */
   if (DSL_UINT8_GET(DSL_DBL_APS_PROFILE_IDX) ==
         sApsTable.ApsTableEntry[i].nUserSlotId)
   {
      /* config is ok, stay in showtime */
      nRet = DSL_AVX_ApsFsmStateSet(pContext, nLine, DSL_APS_FINISHED);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
   }
   else
   {
      /* change the config and change the APS state
         to apply the new config later and trigger the restart*/
      nRet = DSL_DEV_UserConfigRestore(pContext, nLine,
               sApsTable.ApsTableEntry[i].nUserSlotId);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

      nRet = DSL_AVX_ApsFsmStateSet(pContext, nLine, DSL_APS_RECONFIG);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_ApsAutoModeProcess" DSL_CRLF , nLine));
   return(errorCode);
#endif
   return DSL_SUCCESS;
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if 0
DSL_LOCAL DSL_Error_t DSL_AVX_MaxUsedToneGet (
   DSL_Context_t * pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint16_t   * pData )
{
   DSL_Error_t    nRet = DSL_SUCCESS, errorCode = DSL_SUCCESS;
   DSL_uint32_t   nMsgId = 0, nTonesMax = 0;
   DSL_uint16_t   i = 0, nTonesLeft = 0, nTonesCurrent = 0,
                  nToneDivisor = 1,
                  nAckSize = 0, nAckIndex = 0, nAckLength = 0;
   DSL_uint32_t   nCurrentState;
   DSL_uint8_t    nChannel = 0;
   /* assume US/DS ADSL/VDSL to have the same CMD Structures */
   CMD_BAT_TableEntriesGet_t  sCmd;
   union
   {
      ACK_BAT_TableEntriesGet_t  Vdsl;
   }sAck;
   DSL_BandList_t  sBandList;
   DSL_Band_t     *pBand = DSL_NULL;
   DSL_uint16_t   nBand = 0;
   DSL_uint8_t    nMaxNumOfEntries = 0;

   DSL_CHECK_POINTER(pContext, pData);

   DSL_DEBUG (DSL_DBG_MSG,
      (pContext, "IN - DSL_AVX_MaxUsedToneGet(nLine=%d, nDirection=%d)" DSL_CRLF ,
      nLine, nDirection));

   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_ADSLA))
   {
      if (nDirection == DSL_UPSTREAM)
      {
         nMsgId = MSGID_EXT(CMD_ADSL_BAT_US_GET);
         nMaxNumOfEntries = DSL_ARRAY_LENGTH(sAck.AdslUs.BAT);
         nAckSize = sizeof(sAck.AdslUs);
      }
      else
      {
         nMsgId = MSGID_EXT(CMD_ADSL_BAT_DS_GET);
         nMaxNumOfEntries = DSL_ARRAY_LENGTH(sAck.AdslDs.BAT);
         nAckSize = sizeof(sAck.AdslDs);
      }
   }
   else
   {
      /* assume VDSL */
      nMsgId = MSGID_EXT(CMD_BAT_TABLEENTRIESGET);
      nMaxNumOfEntries = DSL_ARRAY_LENGTH(sAck.Vdsl.BAT);
      nAckSize = sizeof(sAck.Vdsl);
      if (DSL_UINT8_GET(DSL_DBS_PROFILES) == DSL_G997_PROFILES_30A)
      {
         /* for 30A the tones are defined in 4kHz steps,
            but here we need the numbers in the 8kHz spacing! */
         nToneDivisor = 2;
      }
   }

   /* the maximum number of tone data retreivable with one message */
   nTonesMax = 2 * nMaxNumOfEntries;

   /* Only proceed if the specified line is in SHOWTIME state.
      In other cases set number of used data elements to zero. */
   nCurrentState = DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE);
   if ((nCurrentState == DSL_LINESTATUS_SHOWTIME_TC_SYNC) ||
       (nCurrentState == DSL_LINESTATUS_SHOWTIME_NO_SYNC) ||
       (nCurrentState == DSL_LINESTATUS_MELT_PARK))
   {
      /* get number uf currently used bands */
      nRet = DSL_AVX_CurrentBandListGet(pContext, nLine, nDirection, &sBandList);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error getting current band config!\r\n", nLine);

      /* init the return structure */
      *pData = 0;

      /* retrieve data only for the appropriate bands
         in sBandList */
      nBand = sBandList.nNumData;
      do
      {
         nBand--;
         pBand = &sBandList.nBand[nBand];
         /*  several messages for max 128*2 values
            have to be sent
            Start from the highest tones */
         nTonesLeft = (pBand->nLastToneIndex - pBand->nFirstToneIndex)/nToneDivisor;
         while (nTonesLeft && (*pData == 0))
         {
            if (nTonesLeft > nTonesMax) nTonesCurrent = nTonesMax;
            else nTonesCurrent = nTonesLeft;

            /* the Msg structure allows retreival in pairs only */
            sCmd.Index = ((pBand->nFirstToneIndex/nToneDivisor) + nTonesLeft - nTonesCurrent) / 2;
            sCmd.Length = nTonesCurrent / 2;
            nRet = DSL_AVX_SendMessage (pContext, nLine, nMsgId,
               sizeof(sCmd), (DSL_uint8_t*)&sCmd,
               nAckSize, (DSL_uint8_t*)&sAck);
            nAckIndex = sAck.Vdsl.Index;
            nAckLength = sAck.Vdsl.Length;

            /* Copy data only if successful and valid */
            if ((nRet == DSL_SUCCESS) && (nAckIndex <= DSL_MAX_NSC - nAckLength))
            {
               /* Copy received data to structure */
               DSL_DEBUG(DSL_DBG_MSG,(pContext,
                  "DSL[%02d]: Bit Allocation data received (idx %d - %d):" DSL_CRLF,
                  nLine, nAckIndex, nAckIndex + nAckLength));

               /* The indexed words contain 2 values each */
               for (i = 0;
                     (i < nAckLength) && (i < nTonesMax/2) && (i < nMaxNumOfEntries);
                     i++)
                  i = nAckLength;
               do
               {
                  i--;

                  if (sAck.Vdsl.BAT[i].data_01 > 0)
                  {
                     *pData = i * 2 + 1;
                     break;
                  }
                  if (sAck.Vdsl.BAT[i].data_00 > 0)
                  {
                     *pData = i * 2;
                     break;
                  }
               } while (i > 0);
            }
            else
            {
               DSL_DEBUG (DSL_DBG_ERR, (pContext,
                  DSL_CRLF "Failed to retrieve BAT %d to %d" DSL_CRLF ,
                  sCmd.Index * 2, (sCmd.Index + sCmd.Length) * 2));

               errorCode = DSL_ERR_FUNCTION_WAITING_TIMEOUT;
               pContext->nErrno = errorCode;
               return errorCode;
            }

            nTonesLeft -= nTonesCurrent;
         }
      } while (nBand  && (*pData == 0));
   }
   else
   {
      DSL_DEBUG(DSL_DBG_ERR,
         (pContext,
         "DSL[%02d]: Function is only available if line is in showtime." DSL_CRLF ,
         nLine));

      errorCode = DSL_ERR_ONLY_AVAILABLE_IN_SHOWTIME;
      pContext->nErrno = errorCode;
   }

   DSL_DEBUG (DSL_DBG_MSG, (pContext, "Highest used tone: %d" DSL_CRLF, *pData));

   DSL_DEBUG (DSL_DBG_MSG, (pContext, "OUT - DSL_AVX_MaxUsedToneGet" DSL_CRLF ));

   return (errorCode);
}
#endif


#if (defined(ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_) && (ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_ == 1))
/*
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_HandleDriverMessage(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   IOCTL_MEI3_LINE_message_t *pMsg)
{
   AVINAX_DRV_MSG_all_t *pDrvMsg = (AVINAX_DRV_MSG_all_t *)((IFX_void_t *)pMsg->pPayload);
   DSL_uint32_t nTriggerMask;
   /* Will be used by data base access macro and has to be set
      fixed to '0' because the configuration settings in this
      function are (bearer) channel independent  */
   static const DSL_uint8_t nChannel = 0;

   if (pMsg->msgCtrl != AVINAX_MSG_CTRL_DRIVER_MSG)
   {
      /* unknown message type received */
      DSL_DEBUG( DSL_DBG_ERR, (pContext, "DSL[%02d]: DrvMsg Ctrl %x unknown" DSL_CRLF ,
         nLine, pMsg->msgCtrl));
      return DSL_ERROR;
   }

   if ( pDrvMsg )
   {
   /* now decoding the messages within the buffer ... */
   switch(pDrvMsg->hdr.id)
   {
      case AVINAX_DRV_MSG_IF_ROM_START_EVT:
      case AVINAX_DRV_MSG_IF_ROM_START_ALM:
      DSL_DEBUG( DSL_DBG_ERR, (pContext, "DSL[%02d]: Device Start %s - %s, DrvState %d --> %d" DSL_CRLF ,
         nLine,
            (pDrvMsg->romStart.hdr.id & AVINAX_DRV_MSG_IF_FLAG_TYPE_ALARM) ? "ALM" : "EVT",
            ((pDrvMsg->romStart.reason == AVINAX_DRV_MSG_IF_ROM_START_REASON_STARTUP) ? "Startup" :
             ((pDrvMsg->romStart.reason == AVINAX_DRV_MSG_IF_ROM_START_REASON_USR_RESET) ? "UsrRst" :
              ((pDrvMsg->romStart.reason == AVINAX_DRV_MSG_IF_ROM_START_REASON_DEV_RESET) ? "DevRst" : "unknown"))),
         pDrvMsg->romStart.prevDrvState, pDrvMsg->romStart.newDrvState));

      DSL_DEBUG(DSL_DBG_ERR,(pContext,
         "DSL[%02d]: Line in reset - block!"
         DSL_CRLF, nLine));
      nTriggerMask = DSL_UINT32_GET(DSL_DBI_AUTORECOVER_TRIGGERMASK);
      if (nTriggerMask & DSL_AUTORECOVER_TRIGGER_DEFAULT)
      {
         DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_REQUIRED);
         DSL_DBG_ExceptionHistoryAddTrigger(pContext, nLine, DSL_AUTORECOVER_TRIGGER_DEFAULT);
      }
      break;

#if defined(ADRV_MEI3_IF_HAVE_PARALLEL_FW_DL) && (ADRV_MEI3_IF_HAVE_PARALLEL_FW_DL==1)
#if defined(INCLUDE_DSL_API_CO_ONLY)
      case AVINAX_DRV_MSG_IF_REM_DL_DONE_EVT:
      case AVINAX_DRV_MSG_IF_REM_DL_DONE_ALM:
         DSL_AVX_OnDrvRmtFileWriteEvt(pContext, nLine, pDrvMsg);
         break;
#endif
#endif

   default:
      DSL_DEBUG( DSL_DBG_ERR, (pContext, "DSL[%02d]: DrvMsg ID 0x%X unknown" DSL_CRLF ,
         nLine, pDrvMsg->hdr.id));
      break;
   }
   }

   return DSL_SUCCESS;
}

#if defined(ADRV_MEI3_IF_HAVE_PARALLEL_FW_DL) && (ADRV_MEI3_IF_HAVE_PARALLEL_FW_DL==1)
#if defined(INCLUDE_DSL_API_CO_ONLY)
/**
   This function handles the AVINAX Driver Messages generated by the driver.

   \param pContext  Pointer to dsl library context structure, [I]
   \param nLine     Specifies on which line the message was received, [I]
   \param pDrvMsg   Pointer to received AVINAX Driver message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnDrvRmtFileWriteEvt(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVINAX_DRV_MSG_all_t *pDrvMsg)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint32_t  nSessionId = 0;
   DSL_boolean_t bEventCallback = DSL_TRUE;

   /* Will be used by data base access macro and has to be set fixed to '0'
      because the configuration settings in this function are (bearer) channel
      independent  */
   static const DSL_uint8_t nChannel = 0;
   AVINAX_DRV_MSG_RemFwDownload_t *pRmtDlMsg = (AVINAX_DRV_MSG_RemFwDownload_t *)pDrvMsg;


   if(pDrvMsg->hdr.id == AVINAX_DRV_MSG_IF_REM_DL_DONE_ALM)
   {
      DSL_DEBUG( DSL_DBG_ERR,
         (pContext, "DSL[%02d]: DrvMsg - Rmt File Wr ALM - op failed" DSL_CRLF , nLine));
   }
   else
   {
      DSL_DEBUG( DSL_DBG_MSG,
         (pContext, "DSL[%02d]: DrvMsg - Rmt File Wr Evt" DSL_CRLF , nLine));
   }

   /* check session ID */
   nSessionId = DSL_UINT32_GET(DSL_DBL_RMT_WR_SESSION_ID);
   if ( (nSessionId != 0) && (nSessionId != pRmtDlMsg->sessionId))
   {
      DSL_DEBUG( DSL_DBG_ERR,
         (pContext, "DSL[%02d]: DrvMsg - Rmt File Wr - Session ID missmatch (0x%X != 0x%X)" DSL_CRLF ,
          nLine, nSessionId, pRmtDlMsg->sessionId));
   }
   else
   {
      DSL_UINT32_SET(DSL_DBL_RMT_WR_SESSION_ID, 0);
   }

   if ( (pContext->pEventCallback != DSL_NULL) && (bEventCallback == DSL_TRUE) )
   {
      DSL_boolean_t              bSemMask = DSL_FALSE;
      DSL_CB_DATA_RmtFileWrite_t nCbData;

      bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_RMT_FILE_WRITE));
      if (bSemMask == DSL_FALSE)
      {
         memset(&nCbData, 0x00, sizeof(DSL_CB_DATA_RmtFileWrite_t));

         /* check the incoming event */
         switch (pRmtDlMsg->opResult)
         {
            case AVINAX_DRV_MSG_IF_REM_DL_DONE_OP_RESULT_SUCCESS:
               nCbData.nRmtFileWrEvt.nOpResult =
                  ((nSessionId != 0) && (nSessionId != pRmtDlMsg->sessionId)) ?
                        DSL_RMT_OP_DONE_ERR_SESSION_ID : DSL_RMT_OP_DONE;
               break;
            case AVINAX_DRV_MSG_IF_REM_DL_DONE_OP_RESULT_ERR_INVAL_STATE:
               nCbData.nRmtFileWrEvt.nOpResult = DSL_RMT_OP_ERR_INVAL_STATE;
               break;
            case AVINAX_DRV_MSG_IF_REM_DL_DONE_OP_RESULT_ERR_SETUP:
               nCbData.nRmtFileWrEvt.nOpResult = DSL_RMT_OP_ERR_SETUP;
               break;
            case AVINAX_DRV_MSG_IF_REM_DL_DONE_OP_RESULT_ERR_BUSY:
               nCbData.nRmtFileWrEvt.nOpResult = DSL_RMT_OP_ERR_BUSY;
               break;
            case AVINAX_DRV_MSG_IF_REM_DL_DONE_OP_RESULT_ERR_TFTP_OP:
               nCbData.nRmtFileWrEvt.nOpResult = DSL_RMT_OP_ERR_TFTP_OP;
               break;
            default:
               nCbData.nRmtFileWrEvt.nOpResult = DSL_RMT_OP_ERR_UNKNOWN;
         }

         if (nCbData.nRmtFileWrEvt.nOpResult != DSL_RMT_OP_DONE)
         {
            DSL_DEBUG( DSL_DBG_ERR,
               (pContext, "DSL[%02d]: DrvrMsg - Rmt File Wr failed, result=%d" DSL_CRLF ,
                nLine, nCbData.nRmtFileWrEvt.nOpResult));
         }

         nCbData.nRmtFileWrEvt.nOpTime_ms = pRmtDlMsg->elapsedTime_ms;
         nCbData.nRmtFileWrEvt.nSendBytes = pRmtDlMsg->sendBytes;
         nCbData.nRmtFileWrEvt.nSessionId = pRmtDlMsg->sessionId;

         (void)(pContext->pEventCallback)( (DSL_void_t *)pContext,
                                     nLine,
                                     DSL_CHANNEL_NA,
                                     DSL_ACCESSDIR_NA,
                                     DSL_ATUDIR_NA,
                                     DSL_CBS_RMT_FILE_WRITE,
                                     (DSL_CB_DATA_Union_t *)&nCbData );
      }
   }

   return (errorCode);
}
#endif
#endif /* defined(ADRV_MEI3_IF_HAVE_PARALLEL_FW_DL) && (ADRV_MEI3_IF_HAVE_PARALLEL_FW_DL==1) */

#endif /* #if (defined(ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_) && (ADRV_MEI3_IF_HAVE_DRV_EVT_MSG__NOT_SUPP_YET_ == 1)) */

/*
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_OnModemReady(
   DSL_Context_t *pContext,
   const DSL_uint16_t line)
{
   DSL_uint16_t nLine = line;
   DSL_Error_t errorCode = DSL_SUCCESS,
               nRet = DSL_SUCCESS;
   static const DSL_uint16_t nChannel = 0;
   DSL_uint16_t nAvxDev = 0;
   DSL_DeviceStatus_t prevDevStatus, devStatus;
   DSL_AVX_FwVersion_t *pFwVersion;

   pFwVersion = &pContext->DeviceContext.Ver[nLine].nFwVer;

   DSL_GET_DEVICE_NUMBER(nLine, nAvxDev);

   /* request now the full version info from the FW */
   errorCode = DSL_AVX_SendMsgVersionInfoGet(pContext, nLine);
   if (errorCode < DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_ERR, (pContext, "DSL[%02d]: Version Info Get failed" DSL_CRLF , nLine));
      /* block the line and try a recovery later */
      DSL_DeviceStatusSet(pContext, nAvxDev, DSL_DEVSTATE_RECOVERY_REQUIRED);
      DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_REQUIRED);
      DSL_DBG_ExceptionHistoryAddTrigger(pContext, nLine, DSL_AUTORECOVER_TRIGGER_UNDEFINED);
      DSL_UINT8_SET(DSL_DBDS_FAIL_RECOVERY_REQUIRED, DSL_TRUE);
      return(DSL_ERROR);
   }
   else
   {
      DSL_DeviceStatus_t nPrevLineStatus = DSL_LineStatusGet(pContext, nLine);

      DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: AVINAX Firmware "
            "V %02d.%02d.%02d.%02d.%02d.%02d" DSL_CRLF, nLine,
            pFwVersion->nPlatform, pFwVersion->nFeatureSet,
            pFwVersion->nMajor, pFwVersion->nMinor,
            pFwVersion->nReleaseStatus, pFwVersion->nApplication));

      DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_NORMAL_OPERATION);
      if( nPrevLineStatus == DSL_DEVSTATE_RECOVERY)
      {
         DSL_uint32_t nRecovFailed = DSL_UINT32_GET(DSL_DBS_STATISTICS_RECOVER_FAILED);
         if( nRecovFailed > 0)
         {
            DSL_UINT32_SET(DSL_DBS_STATISTICS_RECOVER_FAILED, nRecovFailed - 1 );
         }
      }
   }
   DSL_UINT8_SET(DSL_DBS_RTX_MINEFTR_AVAILABLE, 0);
#if defined(INCLUDE_DSL_API_CO_ONLY)
   /* Set defaults only if the Car Mask was empty before */
   {
      DSL_uint16_t nArrayIdx = 0;

      if (DSL_UINT32_AGET(DSL_DBLA_CARRIER_MASK_DS) == 0)
      {
         nRet = DSL_DB_SetDefault_CarrierMask(pContext, DSL_FALSE, nLine, DSL_DOWNSTREAM);
         DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
      }

      if (DSL_UINT32_AGET(DSL_DBLA_CARRIER_MASK_US) == 0)
      {
         nRet = DSL_DB_SetDefault_CarrierMask(pContext, DSL_FALSE, nLine, DSL_UPSTREAM);
         DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
      }
   }

   nRet = DSL_AVX_HsTonesDefaultsSet(pContext, nLine);
   DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
#endif

   /* reset some status variables */
   DSL_UINT16_SET(DSL_DBC_ACTLOOP, 0);
   pContext->DeviceContext.DeviceFlags[nAvxDev].bCifLocked = DSL_FALSE;

   DSL_DEV_PSD_MASK_OFFSET = DSL_G997_ADSL_LIMIT_RESERVE;

   nRet = DSL_AVX_CurrentStateGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

   if (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_IDLE)
   {
      nRet = DSL_AVX_ConfigureCommonSettings (pContext, nLine);
      DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
   }

   prevDevStatus = DSL_DeviceStatusGet(pContext, nAvxDev);

   if (_DSLAPI DSL_AVX_InitReadyCheck(pContext, nLine) != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_WRN,
         (pContext, "Init Ready Check failed." DSL_CRLF ));
   }

   /* Save FW version data from the deviece memory for soft recovery procedure */
   errorCode = DSL_AVX_SendMsgDebugMultipleRead(pContext, 
                                                nLine, 
                                                DSL_SOFT_RECOVERY_FW_VERSION_ADDR, 
                                                DSL_SOFT_RECOVERY_FW_VERSION_SIZE_IN_BYTES,
                                                AVX_IFX_BYTE,
                                                (DSL_uint8_t*)&(pContext->DeviceContext.nFwVersion[nAvxDev][0]));
   if (errorCode < DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_ERR, (pContext, "DSL[%02d]: Could not get FW version for software recovery" DSL_CRLF , nLine));
   }

   devStatus = DSL_DeviceStatusGet(pContext, nAvxDev);
   
   if (devStatus == DSL_DEVSTATE_NORMAL_OPERATION &&
       (prevDevStatus == DSL_DEVSTATE_RECOVERY || prevDevStatus == DSL_DEVSTATE_REINITIALIZATION))
   {
      DSL_DeviceContext_t *pDevCtx = &pContext->DeviceContext;
      DSL_uint16_t nOriginalLine = nLine;
      DSL_uint32_t i;

      DSL_UINT8_SET(DSL_DBDS_RECOVERY_RETRY_COUNT, 0);

      for (i = 0; i < 32 && i < DSL_LINES_PER_DEVICE; i++)
      {
         if (pDevCtx->Init.nLineInitAttemptMask[nAvxDev] & (1 << i))
         {
            DSL_DEV_GET_LINE_PARAM(nAvxDev, i, nLine);
            if (nLine >= DSL_MAX_LINE_NUMBER) continue;

            DSL_UINT32_INC(DSL_DBS_STATISTICS_RECOVER_FULL);

            if ((DSL_boolean_t)DSL_UINT8_GET(DSL_DBI_AUTORECOVER_AUTOREACTIVATE) == DSL_TRUE)
            {
               switch ((DSL_DEV_LineState_t)(DSL_UINT32_GET(DSL_DBS_RECOVERY_LINESTATE)))
               {
               case DSL_LINESTATUS_NOT_INITIALIZED:
               case DSL_LINESTATUS_IDLE:
               case DSL_LINESTATUS_UNKNOWN:
                  break;
               default:
                  DSL_DEV_LineActivate(pContext, nLine);
                  break;
               }
            }
         }
      }

      nLine = nOriginalLine;
   }

#ifdef INCLUDE_DSL_API_AVINAX_MELT
   /* reset MELT related states (on the startup or after recovery)
     Note: during the first startup MELT context may not be
     initialized at this point -> ResetStates will return immediately and
     initialization will be done inside \ref DSL_Init  */
   MELT_LTC_ResetStates (pContext, nLine);
#endif

   return (errorCode);
}

DSL_Error_t DSL_AVX_DeltFePollingStart(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_deltLineData_t *pLineData = DSL_NULL;

   if(DSL_DeltLineDataAlloc(pContext, nLine) == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: failed to allocate/reset DELT line data!" DSL_CRLF, nLine));
      return (DSL_ERROR);
   }

   pLineData = _DSLAPI DSL_DeltLineDataGet(pContext, nLine);
   if (pLineData == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: there is no DELT data element for this line!" DSL_CRLF,
         nLine));
      return (DSL_ERROR);
   }

   pContext->DeviceContext.LineFlags[nLine].nFeRequestRepetitions = 0;
   pLineData->nLastMsgId = DSL_OHC_TESTPARAM_ID_QLN;

   nRet = DSL_AVX_DeltArrayParamsQuery(pContext, nLine, 0, AVX_MAX_TESTPARAMS_BLOCK-1);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during FE DELT data get!" DSL_CRLF, nLine);

   /* request was sent, start the timeout supervision */
   DSL_TimerDB_Add(pContext, nLine,
                   DSL_DBS_DELT_FE_STATUS_TIMEOUT_ID,
                   DSL_TIMEOUTEVENT_DELT_FE_STATUS,
                   DSL_DEV_TIMEOUT_DELT_FE_STATUS * DSL_TIMEOUT_FACTOR);

   return errorCode;
}

DSL_LOCAL DSL_void_t DSL_AVX_InmConfigure(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_G997_LineINMConfig_t inmConfig;

   inmConfig.nINMMode = DSL_UINT8_GET(DSL_DBL_INM_MODE_DS);
   inmConfig.nINMIATO = DSL_UINT16_GET(DSL_DBL_INM_IATO);
   inmConfig.nINMIATS = DSL_UINT8_GET(DSL_DBL_INM_IATS);
   inmConfig.nINMCC = DSL_UINT8_GET(DSL_DBL_INM_CC);
   inmConfig.nINPEQMode = DSL_UINT8_GET(DSL_DBL_INM_INPEQ_MODE);

   DSL_G997_DEV_LineINMConfigSetAsync(pContext, nLine, DSL_DOWNSTREAM, &inmConfig);
}

/**
   This function handles activities to be done when showtime was reached
   first time after training.
   Status has to be polled, several flags to be set...

   \param pContext  Pointer to dsl library context structure, [I]
   \param nLine     Specifies on which line the message was received, [I]
   \param bEventCallback Pointer to the callback flag, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_ShowtimeReached(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bEventCallback)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   /* Will be used by data base access macro and has to be set fixed to '0'
      because the configuration settings in this function are (bearer) channel
      independent  */
   static const DSL_uint8_t nChannel = 0;
   DSL_boolean_t bLineRetrain = DSL_FALSE;

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   if (DSL_UINT8_GET(DSL_DBL_APS_MODE) != DSL_APS_MODE_OFF)
   {
      if (_DSLAPI DSL_AVX_ApsFsmStateGet(pContext, nLine) == DSL_APS_ACTIVE)
      {
         /* APS mode:
            - do not indicate showtime
            - get some status info and
            - decide between different profiles
            - reconfigure and activate the line if config changed */

         /* do not indicate this showtime state by default */
         *bEventCallback = DSL_FALSE;

         /* get status and make decision */
         nRet = DSL_AVX_ApsDecision(pContext, nLine);
         DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

         if (_DSLAPI DSL_AVX_ApsFsmStateGet(pContext, nLine) == DSL_APS_RECONFIG)
         {
            /* current config needs to be changed, stop the line */

            bLineRetrain = DSL_TRUE;
         }
      }

#if (DSL_ENABLE_EAPS == 1)
      if (_DSLAPI DSL_AVX_EapsFsmStateGet(pContext, nLine) != DSL_EAPS_DISABLED)
      {
         DSL_boolean_t bRestart = DSL_FALSE;

         /* get status and make decision */
         nRet = DSL_AVX_EapsShowtimeDecision(pContext, nLine, &bRestart);
         DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

         if (bRestart)
         {
            /* do not indicate this showtime state, but exit*/
            *bEventCallback = DSL_FALSE;

            /* restart the line.
               EAPS states were already changed, the reconfiguration will be
               triggered by modem state RESET */

            bLineRetrain = DSL_TRUE;

            return(errorCode);
         }
      }
#endif /* #if (DSL_ENABLE_EAPS == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      if ((DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC) ||
          (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_MELT_PARK))
      {
         DSL_uint16_t nDsMemPortionRtx = 0, nDsMemPortionRtxDsUs = 0, nDsMemPortionIfec = 0;
         DSL_uint8_t nLastProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);

         nDsMemPortionRtx = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION);
         nDsMemPortionRtxDsUs = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION);
         nDsMemPortionIfec = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION);

         if (DSL_AVX_Eaps2FsmStateGet(pContext, nLine) == DSL_EAPS2_ACTIVATE)
         {
            DSL_boolean_t bRestart = DSL_FALSE;

            nRet = DSL_AVX_Eaps2ShowtimeDecision(pContext, nLine, &bRestart);
            DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

            if (bRestart)
            {
               *bEventCallback = DSL_FALSE;

               /* Store last successful profile and MemSplit due to D4 */
               DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_LAST, nLastProfile);

               DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION_LAST, nDsMemPortionRtx);
               DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION_LAST, nDsMemPortionRtxDsUs);
               DSL_UINT16_SET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION_LAST, nDsMemPortionIfec); 

               nRet = DSL_AVX_Eaps2Retrain(pContext, nLine, &bLineRetrain);
               DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

               return(errorCode);
            }
         }
      }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

      /* showtime resets the retry counter of APS P1*/
      DSL_UINT8_SET(DSL_DBS_APSP1_REINITS, 0);
   }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

   if (bLineRetrain 
#ifdef INCLUDE_DSL_BND
         && !DSL_BND_IsLineBonded(pContext, nLine)
#endif
      )
   {
      return DSL_AVX_RequestIdle(pContext, nLine, DSL_FALSE);
   }

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   if ((_DSLAPI DSL_AVX_ApsFsmStateGet(pContext, nLine) == DSL_APS_DISABLED) ||
      (_DSLAPI DSL_AVX_ApsFsmStateGet(pContext, nLine) == DSL_APS_FINISHED))
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
   {
      /*union
      {
         AVX_EvtLineFailureNeGet_t LineNe;
         AVX_EvtLineFailureFeGet_t LineFe;
         AVX_EvtDataPathFailureNeGet_t DPNe;
         AVX_EvtDataPathFailureFeGet_t DPFe;
      } sFailureEvt;*/

      /* normal operation: change the line state and get status informations */
      *bEventCallback = DSL_TRUE;

      /* Reset last exception value of line in database */
      DSL_UINT8_SET(DSL_DBS_DEV_LAST_EXCEPTION, 0);

      /* FIXME: this workaround shall not longer be necessary as soon as the FW
               reports also the cleanup of failures, especially when entering
               showtime */
      DSL_UINT32_SET(DSL_DBS_LF_NE, 0);
      DSL_UINT32_SET(DSL_DBS_LF_FE, 0);
      DSL_UINT32_SET(DSL_DBSC_DPF_FE, 0);
      DSL_UINT32_SET(DSL_DBSC_DPF_NE, 0);

      /* check once again if LINIT-timer needs to be deleted
         just in case one of the previous events was missed */
      if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_LINIT_TIMEOUT_ID) != DSL_SUCCESS)
      {
         DSL_DEBUG( DSL_DBG_WRN,
            (pContext, "DSL[%02d]: DSL_AVX_ShowtimeReached - could "
            "not remove timeout!" DSL_CRLF , nLine ));
      }

      /* request all the status only if coming directly from activation.
         Avoid it for Sync losses. Therefore check for current Data rate. */
      if (DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_US) == 0)
      {
         DSL_boolean_t bAdsl1 = DSL_FALSE, bRtxUsed = DSL_FALSE;


         /* start the timer for the far end Status */
         /* the timeout event has to be removed if still active. */
         DSL_TimerDB_Restart(pContext, nLine,
                             DSL_DBS_FE_STATUS_TIMEOUT_ID,
                             DSL_TIMEOUTEVENT_FE_STATUS,
                             DSL_DEV_TIMEOUT_FE_STATUS * DSL_TIMEOUT_FACTOR);

         DSL_AVX_AllStatusGet(pContext, nLine);
         DSL_INT16_SET(DSL_DBS_PCB_L0_DS, DSL_INT16_GET(DSL_DBS_PCB_DS));

         if ( DSL_UINT8_GET(DSL_DBS_ATSE_1) || DSL_UINT8_GET(DSL_DBS_ATSE_2) )
            bAdsl1 = DSL_TRUE;

         if ( DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) == (DSL_uint8_t)DSL_RTX_USED )
            bRtxUsed = DSL_TRUE;

         if ((DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC ) ||
             (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_MELT_PARK ))
         {
            if ( bAdsl1 )
            {
               if ( DSL_UINT8_GET(DSL_DBL_RA_MODE_US) == (DSL_uint8_t)DSL_G997_RA_MODE_DYNAMIC )
               {
                  /* Fallback to ACT-RA-MODE-US = 2 */
                  DSL_UINT8_SET(DSL_DBS_RA_MODE_US, DSL_G997_RA_MODE_AT_INIT);
               }

               if ( DSL_UINT8_GET(DSL_DBL_RA_MODE_DS) == (DSL_uint8_t)DSL_G997_RA_MODE_DYNAMIC )
               {
                  /* Fallback to ACT-RA-MODE-DS = 2 */
                  DSL_UINT8_SET(DSL_DBS_RA_MODE_DS, DSL_G997_RA_MODE_AT_INIT);
               }
            }
            else if (( bRtxUsed ) && ( DSL_UINT8_GET(DSL_DBL_RA_MODE_DS) == (DSL_uint8_t)DSL_G997_RA_MODE_DYNAMIC ))
            {
               /* Fallback to ACT-RA-MODE-DS = 2 */
               DSL_UINT8_SET(DSL_DBS_RA_MODE_DS, DSL_G997_RA_MODE_AT_INIT);
            }
         }
         
#ifdef INCLUDE_DSL_BND
         /* handle the PAF state machine after all status data was retrieved */
         /* don't use bRestart pointer here, because restart is required on the whole group
            and will be handled inside the called function */
         nRet = DSL_AVX_BND_FsmOnShowtime(pContext, nLine, DSL_NULL);
         DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
#endif


#if defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1)
         if ( (DSL_CDA_Mode_t)DSL_UINT32_GET(DSL_DBS_CARRIER_DATA_ACQ_MODE) != DSL_CDA_MODE_OFF ||
               DSL_AVX_Eaps2FsmStateGet(pContext, nLine) == DSL_EAPS2_ACTIVATE )
#endif /* defined(DSL_OPDATA_POLLING) && (DSL_OPDATA_POLLING == 1) */
         {
            if ( bAdsl1 == DSL_FALSE &&
             (( DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_NO_SYNC ) ||
              ( DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_MELT_PARK )))
            {
               errorCode = DSL_AVX_DeltFePollingStart(pContext, nLine);
               if (errorCode != DSL_SUCCESS)
               {
                  DSL_DEBUG(DSL_DBG_ERR, (pContext,
                     "DSL[%02d]: DSL_AVX_DeltFePollingStart failed: %d!" DSL_CRLF, nLine, errorCode));
               }
            }
         }

         if (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC)
         {
            if (DSL_UINT8_GET(DSL_DBL_INM_MODE_DS))
            {
               DSL_AVX_InmConfigure(pContext, nLine);
            }
         }
      }

      DSL_AVX_RtxAggAchNdrCalculate(pContext, nLine, DSL_UPSTREAM);
      DSL_AVX_RtxAggAchNdrCalculate(pContext, nLine, DSL_DOWNSTREAM);

#ifdef INCLUDE_DSL_BND
      /* handle the PAF state machine after all status data was retrieved */
      /* don't use bRestart pointer here, because restart is required on the whole group
         and will be handled inside the called function */
      nRet = DSL_AVX_BND_FsmOnShowtime(pContext, nLine, DSL_NULL);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
#endif
   }

   if (DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) != DSL_RTX_USED &&
       ((DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC) ||
        (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_MELT_PARK)))
   {
      DSL_TimerDB_Restart(pContext, nLine,
                          DSL_DBS_L2_CONFIGURATION_DELAY_TIMEOUT_ID,
                          DSL_TIMEOUTEVENT_L2_CONFIGURATION_DELAY,
                          DSL_DEV_TIMEOUT_L2_CONFIGURATION_DELAY * DSL_TIMEOUT_FACTOR);

   }
   
   nRet = DSL_AVX_SendMsgTxErrorControl(pContext, nLine, nChannel, DSL_FALSE, DSL_FALSE);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   if (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC)
   {
      DSL_AVX_SNR_WOVN_DATA_CLEAR(nLine);
      DSL_AVX_SnrWoVnUsQuery(pContext, nLine);
      DSL_AVX_SnrWoVnUsQueryRestartTimer(pContext, nLine);
   }

   return(errorCode);
}

#if (DSL_ENABLE_EAPS == 1)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_EapsFsmStateSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_EapsStates_t nEapsStateNew)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_EapsStates_t nEapsStateCurr = (DSL_EapsStates_t)DSL_UINT8_GET(DSL_DBS_EAPS_STATE);

   if (nEapsStateCurr == DSL_EAPS_DISABLED)
   {
      DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
         "DSL[%02d]: DSL_AVX_EapsFsmStateSet EAPS off" DSL_CRLF ,
         nLine));
      return DSL_SUCCESS;
   }

   if (nEapsStateNew > DSL_EAPS_LAST)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_EapsFsmStateSet illegal state %d" DSL_CRLF ,
         nLine, nEapsStateNew));
      return DSL_ERROR;
   }

   /* no change */
   if (nEapsStateCurr == nEapsStateNew)
      return errorCode;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_EapsFsmStateSet %d" DSL_CRLF ,
      nLine, nEapsStateNew));

   DSL_UINT8_SET(DSL_DBS_EAPS_STATE, nEapsStateNew);
   /* any transition into a new state does a reset of the retry counter */
   DSL_UINT8_SET(DSL_DBS_EAPS_REINITS, 0);

   return(errorCode);
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_EapsFsmEnable(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_boolean_t bEnable)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;

   if (bEnable)
   {
      /* if already enabled, this causes not a reset of the state machine
      because it might be currently running */
      if (_DSLAPI DSL_AVX_EapsFsmStateGet(pContext, nLine) == DSL_EAPS_DISABLED)
      {
         DSL_AVX_EapsFsmReset(pContext, nLine);
      }
   }
   else
   {
      DSL_UINT8_SET(DSL_DBS_EAPS_STATE, DSL_EAPS_DISABLED);
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_EapsFsmEnable %s" DSL_CRLF ,
      nLine, (bEnable?"true":"false")));

   return(errorCode);
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_EapsFsmReset(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint16_t nChannel = 0;

   DSL_UINT8_SET(DSL_DBS_EAPS_STATE, DSL_EAPS_ENABLED);
   DSL_UINT32_SET(DSL_DBS_EAPS_DATARATE_ADSL,  0);
   DSL_UINT32_SET(DSL_DBS_EAPS_DATARATE_VDSL2_8X, 0);

   return(errorCode);
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_EapsStates_t DSL_AVX_EapsFsmStateGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static const DSL_uint8_t nChannel = 0;

   return ((DSL_EapsStates_t)DSL_UINT8_GET(DSL_DBS_EAPS_STATE));
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_EapsProfileChangeCheck(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;
   DSL_uint8_t  nProfile = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_EapsProfileChangeCheck - In" DSL_CRLF ,
      nLine));

   switch (_DSLAPI DSL_AVX_EapsFsmStateGet(pContext, nLine))
   {
   case DSL_EAPS_DISABLED:
   case DSL_EAPS_ENABLED:
   case DSL_EAPS_FINISHED:
      /* nothing to do */
      return(DSL_SUCCESS);
   case DSL_EAPS_ADSL_TRIAL_CONFIG:
   case DSL_EAPS_ADSL_FIXED_CONFIG:
   case DSL_EAPS_ADSL_TRIAL:
   case DSL_EAPS_ADSL_FIXED:
      nProfile = DSL_UINT8_GET(DSL_DBL_EAPS_PROFILE_ADSL);
      nRet = DSL_ProfileConfigChange(pContext, nLine, nProfile);
      break;
   case DSL_EAPS_8A_TRIAL_CONFIG:
   case DSL_EAPS_8A_FIXED_CONFIG:
   case DSL_EAPS_8A_TRIAL:
   case DSL_EAPS_8A_FIXED:
      nProfile = DSL_UINT8_GET(DSL_DBL_EAPS_PROFILE_VDSL2_8X);
      nRet = DSL_ProfileConfigChange(pContext, nLine, nProfile);
      break;
   case DSL_EAPS_12A_TRIAL_CONFIG:
   case DSL_EAPS_12A_TRIAL:
      nProfile = DSL_UINT8_GET(DSL_DBL_EAPS_PROFILE_VDSL2_12X);
      nRet = DSL_ProfileConfigChange(pContext, nLine, nProfile);
      break;
   }
   DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_EapsProfileChangeCheck - Out" DSL_CRLF ,
      nLine));

   return(errorCode);
}

/**
   Do the Enhanced Auto Profile Selection when SHOWTIME was entered.
   Based on some status parameters the line is reconfigured or not.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]
   \param bRetrain   Returns the decision to retrain or not, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_EapsShowtimeDecision(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   static const DSL_uint16_t nChannel = 0,
               /* kl0 [0.1dB] limit constants */
               /* test values : nKl0EShort = 50, nKl0Short = 150; */
               nKl0EShort = 190, nKl0Short = 310;
   static const DSL_int32_t nSlopeRequired = -4260; /* -4259,84 = -0.065 * 0x10000; */
   DSL_int32_t nSlope = 0;
#if 0 /* not defined yet */
   ACK_BearerChsUS_Get_t sAck;
#endif
   DSL_G997_UsPowerBackOffStatus_t sUpboStatus;
   DSL_uint32_t nActualDataRate = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_EapsShowtimeDecision" DSL_CRLF , nLine));

   switch (_DSLAPI DSL_AVX_EapsFsmStateGet(pContext, nLine))
   {
   case DSL_EAPS_FINISHED:
   case DSL_EAPS_ADSL_TRIAL_CONFIG:
   case DSL_EAPS_ADSL_FIXED_CONFIG:
   case DSL_EAPS_8A_TRIAL_CONFIG:
   case DSL_EAPS_8A_FIXED_CONFIG:
   case DSL_EAPS_12A_TRIAL_CONFIG:
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_EapsShowtimeDecision called in state %d, "
         "ignored!" DSL_CRLF ,
         nLine, _DSLAPI DSL_AVX_EapsFsmStateGet(pContext, nLine)));
      /*lint -fallthrough */
   case DSL_EAPS_ENABLED:
   case DSL_EAPS_DISABLED:
   case DSL_EAPS_ADSL_FIXED:
   case DSL_EAPS_8A_FIXED:
      /* nothing to do */
      *bRetrain = DSL_FALSE;
      break;
   case DSL_EAPS_ADSL_TRIAL:
      /* get Hs FE Caps and decide */
      nRet = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
      /* check for VDSL2 support */
      if ((DSL_UINT8_GET(DSL_DBS_SPAR1_5) & 0x20) == 0x00)
      {
         /* far end supports ADSL only, stay here */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
            "Hs FE Caps does not support VDSl2" DSL_CRLF ,
            nLine));
         *bRetrain = DSL_FALSE;
         break;
      }

      /* far end supports VDSL2 also,
         calculate slope from BAT and decide */
      nRet = DSL_AVX_EapsBatSlopeCalculate(pContext, nLine, &nSlope);
      if (nSlope <= nSlopeRequired)
      {
         /* slope is fine, stay here */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
            "BAT slope is ok for ADSL" DSL_CRLF ,
            nLine));
         *bRetrain = DSL_FALSE;
         break;
      }

      /* get and store Data rate
         and reconfigure with VDSL */
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
         "BAT slope flat, try VDSL" DSL_CRLF ,
         nLine));

#if 0 /* not defined yet */
      errorCode =  DSL_AVX_SendMsgBearerChSGet(pContext, nLine, DSL_DOWNSTREAM, &sAck);
      if (errorCode >= 0)
      {
         nActualDataRate = ((DSL_uint32_t)sAck.DRusLP0_MSW<<16)
                              | (DSL_uint32_t)sAck.DRusLP0_LSW;
         nActualDataRate *= 4000;
         DSL_UINT32_SET(DSL_DBS_EAPS_DATARATE_ADSL, nActualDataRate);
      }
#endif
      *bRetrain = DSL_TRUE;
      _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_8A_TRIAL_CONFIG);
      break;
   case DSL_EAPS_8A_TRIAL:
#if 0 /* tbd */
      /* get and store Data rate */
      nRet =  DSL_AVX_SendMsgBearerChSGet(pContext, nLine, DSL_DOWNSTREAM, &sAck);
      if (nRet >= 0)
      {
         nActualDataRate = ((DSL_uint32_t)sAck.DRusLP0_MSW<<16)
                              | (DSL_uint32_t)sAck.DRusLP0_LSW;
         nActualDataRate *= 4000;
         DSL_UINT32_SET(DSL_DBS_EAPS_DATARATE_VDSL2_8X, nActualDataRate);
      }
      else
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
            "failed to get data rate!" DSL_CRLF , nLine));
         break;
      }
#endif
      /* get SPAR1 and decide */
      nRet = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
      /* get and decide on kl0 */
      /* get the estimated electrical length */
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      nRet = DSL_G997_DEV_UsPowerBackOffStatusGet(pContext, nLine, &sUpboStatus);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
      if (sUpboStatus.nElectricalLength <= nKl0EShort)
      {
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
            "kl0 is below e-short limit." DSL_CRLF ,
            nLine));
         *bRetrain = DSL_TRUE;
         _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_12A_TRIAL_CONFIG);
      }
      else if (sUpboStatus.nElectricalLength <= nKl0Short)
      {
         /* check for ADSL support */
         if ((DSL_UINT8_GET(DSL_DBS_SPAR1_1) & 0x7F) ||
             (DSL_UINT8_GET(DSL_DBS_SPAR1_2) & 0x03) ||
             (DSL_UINT8_GET(DSL_DBS_SPAR1_3) & 0x7F) ||
             (DSL_UINT8_GET(DSL_DBS_SPAR1_4) & 0x1F) ||
             (DSL_UINT8_GET(DSL_DBS_SPAR1_5) & 0x15))
         {
            /* decide on data rate */
            if (nActualDataRate <= DSL_UINT32_GET(DSL_DBS_EAPS_DATARATE_ADSL))
            {
               DSL_DEBUG(DSL_DBG_MSG, (pContext,
                  "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
                  "8x rate smaller than ADSL rate." DSL_CRLF ,
                  nLine));
               *bRetrain = DSL_TRUE;
               _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_ADSL_FIXED_CONFIG);
            }
            else
            {
               /* 8x is best choice for the current line, stay here */
               DSL_DEBUG(DSL_DBG_MSG, (pContext,
                  "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
                  "8x rate is ok." DSL_CRLF ,
                  nLine));
               *bRetrain = DSL_FALSE;
               _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_FINISHED);
            }
         }
         else
         {
            /* far end supports VDSL only */
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
               "SPAR1 FE supports VDSl2 only" DSL_CRLF ,
               nLine));
            *bRetrain = DSL_FALSE;
            _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_FINISHED);
         }
      }
      else
      {
         /* check for ADSL support */
         if ((DSL_UINT8_GET(DSL_DBS_SPAR1_1) & 0x7F) ||
             (DSL_UINT8_GET(DSL_DBS_SPAR1_2) & 0x03) ||
             (DSL_UINT8_GET(DSL_DBS_SPAR1_3) & 0x7F) ||
             (DSL_UINT8_GET(DSL_DBS_SPAR1_4) & 0x1F) ||
             (DSL_UINT8_GET(DSL_DBS_SPAR1_5) & 0x15))
         {
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
               "kl0 is over short limit, try ADSL." DSL_CRLF ,
               nLine));
            *bRetrain = DSL_TRUE;
            _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_ADSL_FIXED_CONFIG);
         }
         else
         {
            /* far end supports VDSL only */
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
               "kl0 is over short limit but "
               "SPAR1 FE supports VDSl2 only." DSL_CRLF ,
               nLine));
            *bRetrain = DSL_FALSE;
            _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_FINISHED);
         }
      }
      break;
   case DSL_EAPS_12A_TRIAL:
#if 0 /* tbd */
      /* get Data rate */
      nRet =  DSL_AVX_SendMsgBearerChSGet(pContext, nLine, DSL_DOWNSTREAM, &sAck);
      if (nRet >= 0)
      {
         nActualDataRate = ((DSL_uint32_t)sAck.DRusLP0_MSW<<16)
                              | (DSL_uint32_t)sAck.DRusLP0_LSW;
         nActualDataRate *= 4000;
         /* decide on data rate */
         if (DSL_UINT32_GET(DSL_DBS_EAPS_DATARATE_VDSL2_8X) > nActualDataRate)
         {
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
               "8x rate was higher than current 12x." DSL_CRLF ,
               nLine));
            *bRetrain = DSL_TRUE;
            _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_8A_FIXED_CONFIG);
         }
         else
         {
            /* 12x is best choice for the current line, stay here */
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
               "12x rate is ok." DSL_CRLF ,
               nLine));
            *bRetrain = DSL_FALSE;
            _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_FINISHED);
         }
      }
      else
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_EapsShowtimeDecision - "
            "failed to get data rate!" DSL_CRLF , nLine));
         break;
      }
#endif
      break;
   }
   DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_EapsShowtimeDecision" DSL_CRLF , nLine));

   return(errorCode);
}

/**
   Do the Enhanced Auto Profile Selection when FAIL_STATE was entered
   AND Fail Reason was reported.
   Based on some status parameters the line is reconfigured or not.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]
   \param bRetrain   Returns the decision to retrain or not, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_EapsFailDecision(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   static const DSL_uint16_t nChannel = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_EapsFailDecision" DSL_CRLF , nLine));

   switch (_DSLAPI DSL_AVX_EapsFsmStateGet(pContext, nLine))
   {
   case DSL_EAPS_ADSL_TRIAL_CONFIG:
   case DSL_EAPS_ADSL_FIXED_CONFIG:
   case DSL_EAPS_8A_TRIAL_CONFIG:
   case DSL_EAPS_8A_FIXED_CONFIG:
   case DSL_EAPS_12A_TRIAL_CONFIG:
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_EapsFailDecision called in state %d, "
         "ignored!" DSL_CRLF ,
         nLine, _DSLAPI DSL_AVX_EapsFsmStateGet(pContext, nLine)));
      /*lint -fallthrough */
   case DSL_EAPS_ENABLED:
   case DSL_EAPS_DISABLED:
      /* nothing to do, FW restarts freely */
      *bRetrain = DSL_FALSE;
      break;
   case DSL_EAPS_ADSL_FIXED:
      /* state change but FW restarts freely */
      *bRetrain = DSL_FALSE;
      _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_ADSL_TRIAL);
      break;
   case DSL_EAPS_FINISHED:
      /* Restart the EAPS FSM */
      *bRetrain = DSL_TRUE;
      _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_ADSL_TRIAL_CONFIG);
      break;
   case DSL_EAPS_12A_TRIAL:
   case DSL_EAPS_8A_FIXED:
      if (DSL_UINT8_GET(DSL_DBS_EAPS_REINITS) >= DSL_EAPS_MAX_REINITS)
      {
         /* Restart the EAPS FSM */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_EapsFaiDecision retries exceeded" DSL_CRLF , nLine));
         *bRetrain = DSL_TRUE;
         _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_ADSL_TRIAL_CONFIG);
      }
      else
      {
         /* retry once more */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_EapsFaiDecision retry" DSL_CRLF , nLine));
         DSL_UINT8_INC(DSL_DBS_EAPS_REINITS);
         *bRetrain = DSL_FALSE;
      }
      break;
   case DSL_EAPS_ADSL_TRIAL:
      /* get SPAR1 and decide */
      nRet = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
      /* check for ADSL support */
      if ((DSL_UINT8_GET(DSL_DBS_SPAR1_1) & 0x7F) ||
            (DSL_UINT8_GET(DSL_DBS_SPAR1_2) & 0x03) ||
            (DSL_UINT8_GET(DSL_DBS_SPAR1_3) & 0x7F) ||
            (DSL_UINT8_GET(DSL_DBS_SPAR1_4) & 0x1F) ||
            (DSL_UINT8_GET(DSL_DBS_SPAR1_5) & 0x15))
      {
         /* far end supports ADSL, try again */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_EapsFaiDecision FE supports ADSL, "
            "try again" DSL_CRLF , nLine));
         *bRetrain = DSL_FALSE;
         break;
      }
      else if ((DSL_UINT8_GET(DSL_DBS_SPAR1_5) & 0x20) == 0x00)
      {
         nRet = DSL_ERR_UNSUPPORTED_ATSE_MODES;
         DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_FALSE, errorCode,
            "DSL_AVX_EapsFailDecision - "
            "no SPAR1 bit set!" DSL_CRLF , nLine);
         break;
      }

      /* far end supports VDSL2 only,
         try with VDSL2 8x */
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_EapsFaiDecision FE supports VDSL2 only"
         DSL_CRLF , nLine));
      *bRetrain = DSL_TRUE;
      _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_8A_TRIAL_CONFIG);
      break;
   case DSL_EAPS_8A_TRIAL:
      /* get SPAR1 and decide */
      nRet = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
      /* check for ADSL support */
      if ((DSL_UINT8_GET(DSL_DBS_SPAR1_1) & 0x7F) ||
            (DSL_UINT8_GET(DSL_DBS_SPAR1_2) & 0x03) ||
            (DSL_UINT8_GET(DSL_DBS_SPAR1_3) & 0x7F) ||
            (DSL_UINT8_GET(DSL_DBS_SPAR1_4) & 0x1F) ||
            (DSL_UINT8_GET(DSL_DBS_SPAR1_5) & 0x15))
      {
         /* VDSL2 activation failed, do ADSL */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_EapsFaiDecision FE supports ADSL, "
            "try this" DSL_CRLF , nLine));
         *bRetrain = DSL_TRUE;
         _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_ADSL_FIXED_CONFIG);
      }
      else if (DSL_UINT8_GET(DSL_DBS_EAPS_REINITS) >= DSL_EAPS_MAX_REINITS)
      {
         /* Restart the EAPS FSM */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_EapsFaiDecision retries exceeded" DSL_CRLF , nLine));
         *bRetrain = DSL_TRUE;
         _DSLAPI DSL_AVX_EapsFsmStateSet(pContext, nLine, DSL_EAPS_ADSL_TRIAL_CONFIG);
      }
      else
      {
         /* no ADSL on the FE, retry once more */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_EapsFaiDecision retry" DSL_CRLF , nLine));
         DSL_UINT8_INC(DSL_DBS_EAPS_REINITS);
         *bRetrain = DSL_FALSE;
      }
      break;
   }
   DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_EapsFaiDecision" DSL_CRLF , nLine));

   return(errorCode);
}

/**
   This function uses the bit allocation table to calculate a represenative
   median slope of the bit allocation between two base tones.
   The result is used for the decision within the EAPS.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies on which line the message was received, [I]
   \param nSlope     returns the signed slope value in Q16.16 format, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_EapsBatSlopeCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_int32_t *nSlope)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   /* DSL_G997_NSCData8_t sBat; */
   /* start and stop tones for the BAT slope calculation */
   const DSL_uint16_t   nStart = 100, nStop = 150,
                        nIntLength = 1+nStop-nStart;
   DSL_uint8_t  nBat[1+150-100];
   DSL_AVX_BatIntervalData_t sBatInterval;

   sBatInterval.pNscData = &nBat[0];
   sBatInterval.pBitsPerSymbol = DSL_NULL;
   sBatInterval.pNscUsed = DSL_NULL;
   sBatInterval.nFirstTone = nStart;
   sBatInterval.nLastTone = nStop;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_EapsBatSlopeCalculate (nStart= %d, nStop=%d)" DSL_CRLF ,
      nLine, nStart, nStop));

   if ((nStart >= nStop) || (nIntLength > DSL_ARRAY_LENGTH(nBat)))
      return(DSL_ERROR);

   memset(&nBat[0], 0, sizeof(nBat));

   nRet = DSL_AVX_BitAllocationIntervalGet (pContext, nLine, DSL_DOWNSTREAM,
            FWMODE_ADSL, &sBatInterval);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   /* for the decision (BAT * 3dB - FineGain) should be taken,
      but the fine gains are not available yet.
      Therefore use simply BAT * 3dB */
   *nSlope = ((nBat[nIntLength-1] - nBat[0]) * 3 * 0x10000)/
               (nIntLength - 1);

   if (nStart + 10 < nStop -10)
   {
      DSL_int32_t nSlope2 = 0;
      /* do a second slope and report the Maximum of both */
      nSlope2 = ((nBat[nIntLength-11] - nBat[10]) * 3 * 0x10000)/
                  ((nIntLength - 21));

      *nSlope = DSL_MAX(*nSlope, nSlope2);
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_EapsBatSlopeCalculate nSlope=%.4f" DSL_CRLF ,
      nLine, *nSlope/(DSL_float_t)0x10000));

   return(errorCode);
}
#endif /* (DSL_ENABLE_EAPS == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_ApsP1FsmStateSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_ApsP1States_t nApsP1StateNew)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_ApsP1States_t nApsP1StateCurr = (DSL_ApsP1States_t)DSL_UINT8_GET(DSL_DBS_APSP1_STATE);

   if (nApsP1StateCurr == DSL_APSP1_DISABLED)
   {
      DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
         "DSL[%02d]: DSL_AVX_ApsP1FsmStateSet APSP1 off" DSL_CRLF ,
         nLine));
      return DSL_SUCCESS;
   }

   if (nApsP1StateNew > DSL_APSP1_LAST)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_ApsP1FsmStateSet illegal state %d" DSL_CRLF ,
         nLine, nApsP1StateNew));
      return DSL_ERROR;
   }

   /* no change */
   if (nApsP1StateCurr == nApsP1StateNew)
      return errorCode;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_ApsP1FsmStateSet %d" DSL_CRLF ,
      nLine, nApsP1StateNew));

   DSL_UINT8_SET(DSL_DBS_APSP1_STATE, nApsP1StateNew);
   /* any transition into a new state does a reset of the retry counter */
   DSL_UINT8_SET(DSL_DBS_APSP1_REINITS, 0);

   return(errorCode);
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_ApsP1FsmEnable(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_boolean_t bEnable)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;

   if (bEnable)
   {
      /* if already enabled, this causes not a reset of the state machine
      because it might be currently running */
      if (_DSLAPI DSL_AVX_ApsP1FsmStateGet(pContext, nLine) == DSL_APSP1_DISABLED)
      {
         DSL_UINT8_SET(DSL_DBS_APSP1_STATE, DSL_APSP1_ENABLED);
         DSL_AVX_ApsP1FsmReset(pContext, nLine);
      }
   }
   else
   {
      DSL_AVX_ApsP1FsmStateSet(pContext, nLine, DSL_APSP1_DISABLED);
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_ApsP1FsmEnable %s" DSL_CRLF ,
      nLine, (bEnable?"true":"false")));

   return(errorCode);
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_ApsP1FsmReset(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint16_t nChannel = 0;

   DSL_AVX_ApsP1FsmStateSet(pContext, nLine, DSL_APSP1_ENABLED);
   DSL_UINT8_SET(DSL_DBS_APSP1_REINITS,  0);
   /* set current Profile to the end of the list, as lwc will increase it */
   DSL_UINT8_SET(DSL_DBS_APSP1_CURR_PROFILE_IDX, DSL_APSP1_MAX_LIST_LENGTH-1);

   return(errorCode);
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_ApsP1States_t DSL_AVX_ApsP1FsmStateGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static const DSL_uint8_t nChannel = 0;

   return ((DSL_ApsP1States_t)DSL_UINT8_GET(DSL_DBS_APSP1_STATE));
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   Do the Priority Based Profile Switching (APS P1) check after a
   Fail state was reported.
   Based on some status parameters the line is reconfigured or not.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]
   \param bRetrain   Returns the decision to retrain or not, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_ApsP1FailDecision(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_boolean_t bFeTimerActive,
   DSL_boolean_t *bRetrain)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   static const DSL_uint16_t nChannel = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_ApsP1FailDecision" DSL_CRLF , nLine));

   switch (_DSLAPI DSL_AVX_ApsP1FsmStateGet(pContext, nLine))
   {
   case DSL_APSP1_ENABLED:
   case DSL_APSP1_DISABLED:
   case DSL_APSP1_CONFIG:
      /* nothing to do, FW restarts freely */
      *bRetrain = DSL_FALSE;
      break;
   case DSL_APSP1_ACTIVE:
      if (  (!bFeTimerActive) &&
            ((DSL_UINT32_GET(DSL_DBS_PRE_LINESTATE) ==
               DSL_LINESTATUS_SHOWTIME_TC_SYNC     ) ||
            (DSL_UINT32_GET(DSL_DBS_PRE_LINESTATE) ==
               DSL_LINESTATUS_SHOWTIME_NO_SYNC     ) ||
            (DSL_UINT32_GET(DSL_DBS_PRE_LINESTATE) ==
               DSL_LINESTATUS_MELT_PARK     )))
      {
         /* Showtime loss and FE timer was not running
            (showtime was satble at least 12 sec), restart the FSM */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_ApsP1FailDecision loss of stable showtime, "
            "restart FSM" DSL_CRLF , nLine));
         /* set current Profile to the end of the list, as lwc will increase it */
         DSL_UINT8_SET(DSL_DBS_APSP1_CURR_PROFILE_IDX, DSL_APSP1_MAX_LIST_LENGTH-1);
         *bRetrain = DSL_TRUE;
      }
      else if (DSL_UINT8_GET(DSL_DBS_APSP1_REINITS) >= DSL_APSP1_MAX_REINITS)
      {
         /* next config */
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_ApsP1FailDecision retries exceeded" DSL_CRLF , nLine));
         *bRetrain = DSL_TRUE;
      }
      else
      {
         /* check for no common mode manually, FW indication is not reliable.
            The FE inventory is updated before from the SPAR1 bits.
            Some HS errors can cause the SPAR1 bits to be empty,
            treat this like a common mode. */
         DSL_uint8_t *pFeXtse = &pContext->G997.FeLineInventory[nLine].ATSECapabilities[0];

         if (  (DSL_UINT8_GET(DSL_DBL_ATSE_1) & pFeXtse[0]) ||
               (DSL_UINT8_GET(DSL_DBL_ATSE_2) & pFeXtse[1]) ||
               (DSL_UINT8_GET(DSL_DBL_ATSE_3) & pFeXtse[2]) ||
               (DSL_UINT8_GET(DSL_DBL_ATSE_4) & pFeXtse[3]) ||
               (DSL_UINT8_GET(DSL_DBL_ATSE_5) & pFeXtse[4]) ||
               (DSL_UINT8_GET(DSL_DBL_ATSE_6) & pFeXtse[5]) ||
               (DSL_UINT8_GET(DSL_DBL_ATSE_7) & pFeXtse[6]) ||
               (DSL_UINT8_GET(DSL_DBL_ATSE_8) & pFeXtse[7])  )
         {
            /* common mode exists, try again */
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: DSL_AVX_ApsP1FailDecision common mode detected, "
               "try again" DSL_CRLF , nLine));
            DSL_UINT8_INC(DSL_DBS_APSP1_REINITS);
            *bRetrain = DSL_FALSE;
            break;
         }
         else
         {
            DSL_uint8_t i, nXtseOr = 0;

            for (i=0; i<8; i++)
               nXtseOr |= pFeXtse[i];

            if (nXtseOr == 0x00)
            {
               /* FE cpabilities unknown, try again */
               DSL_DEBUG(DSL_DBG_MSG, (pContext,
                  "DSL[%02d]: DSL_AVX_ApsP1FailDecision SPAR1 empty, "
                  "try again" DSL_CRLF , nLine));
               DSL_UINT8_INC(DSL_DBS_APSP1_REINITS);
               *bRetrain = DSL_FALSE;
               break;
            }
            else
            {
               DSL_DEBUG(DSL_DBG_MSG, (pContext,
                  "DSL[%02d]: DSL_AVX_ApsP1FailDecision no common mode detected, "
                  "try next profile" DSL_CRLF , nLine));
               *bRetrain = DSL_TRUE;
               break;
            }
         }
      }
      break;
   }
   DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_ApsP1FailDecision" DSL_CRLF , nLine));

   return(errorCode);
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   Do the Priority Based Profile Switching (APS P1) configuration change.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_Error_t DSL_AVX_ApsP1ProfileChange(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;
   DSL_uint8_t  nProfile;
   DSL_uint16_t nArrayIdx = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_ApsP1ProfileChange - In" DSL_CRLF ,
      nLine));


   /* search the prio list for the next profile to set */

   nArrayIdx = DSL_UINT8_GET(DSL_DBS_APSP1_CURR_PROFILE_IDX);
   nArrayIdx++;
   if (nArrayIdx == DSL_APSP1_MAX_LIST_LENGTH)
   {
      /* restart the list from the first entry */
      nArrayIdx = 0;
   }
   else
   {
      if (0xFF == DSL_UINT8_AGET(DSL_DBLA_APSP1_PROFILES))
         /* restart the list from the first entry */
         nArrayIdx = 0;
   }

   nProfile = DSL_UINT8_AGET(DSL_DBLA_APSP1_PROFILES);
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_ApsP1ProfileChange setting profile %d" DSL_CRLF ,
      nLine, nProfile));
   nRet = DSL_ProfileConfigChange(pContext, nLine, nProfile);
   DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

   if (nRet == DSL_SUCCESS)
      DSL_UINT8_SET(DSL_DBS_APSP1_CURR_PROFILE_IDX, (DSL_uint8_t)nArrayIdx);
   else
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_ApsP1ProfileChange: "
         "unable to set requested profile %d" DSL_CRLF,
         nLine, nProfile));
   }

   /* reset the retry counter */
   DSL_UINT8_SET(DSL_DBS_APSP1_REINITS,  0);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_ApsP1ProfileChange - Out" DSL_CRLF ,
      nLine));

   return(errorCode);
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

/**
   This helping function searches and returns the next tone interval which is
   completely inband.
   The search starts from nFirstTone and returns a maximum interval
   length of nMaxLength, dependent on the band borders.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies for which line the function will apply, [I]
   \param nDirection Specifies the direction (upstream/downstream) to which
                     the function will apply. [I]
   \param nFirstTone First tone to start the next inband Interval from. If
                     this tone is already out of band the interval will start
                     from the next higher inband tone, [I]
   \param nMaxLength Maximal length of the interval to be retrieved. If the
                     difference from the first inband tone (>= nFirstTone)
                     to the band end is less, the returned interval will be
                     shortened, [I]
   \param pBand      Pointer returning the inband interval.
                     First tone will be >= nFirstTone and
                     last tone will be < nFirstTone + nMaxLength, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
   - or any other defined specific error code
*/
#if 0
DSL_LOCAL DSL_Error_t DSL_AVX_NextInbandIntervalGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint16_t nFirstTone,
   DSL_uint16_t nMaxLength,
   DSL_Band_t *pBand)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_BandList_t sBandList;
   DSL_Band_t *pCurrentBand;
   DSL_uint16_t i = 0;

   /* get the current band borders */
   nRet = DSL_AVX_CurrentBandListGet(pContext, nLine, nDirection, &sBandList);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   errorCode = DSL_ERROR;
   /* iterate over the bands */
   for (pCurrentBand=&sBandList.nBand[0], i=0;
         i<sBandList.nNumData;
         i++, pCurrentBand++)
   {
      if (pCurrentBand->nLastToneIndex < nFirstTone)
         /* this band is already below the focus, try next */
         continue;
      else
      {
         /* last tone of the current band is higher than thew search index,
            we can use this band */

         if (pCurrentBand->nFirstToneIndex < nFirstTone)
         {
            /* nFirstTone is inband, start right here */
            pBand->nFirstToneIndex = nFirstTone;
         }
         else
         {
            /* nFirstTone is still outside the band, start at the beginning of it */
            pBand->nFirstToneIndex = pCurrentBand->nFirstToneIndex;
         }
         /* Interval is limited by its max length or
            by the end of the current band */
         pBand->nLastToneIndex  =
            DSL_MIN(pBand->nFirstToneIndex + nMaxLength - 1,
                     pCurrentBand->nLastToneIndex);
         errorCode = DSL_SUCCESS;
         break;
      }
   }

   return(errorCode);
}
#endif

/**
   This helper function checks wether a new line state was achieved,
   changes the state in the DB and passes state information to PM.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies for which line the function will apply, [I]
   \param G997_Status   new line status to be applied, [I]
   \param bResetValues  Resets showtime values or not, [I]
   \param nPMStatus  New status to be reported to PM, [I]
   \param sText      State string to be pronted, [I]
   \param nActLineState    Current and modified line state, [IO]
   \param bEventCallback   Returns wether a statechange callback shall be
                     issued or not, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
   - or any other defined specific error code
*/
DSL_LOCAL DSL_Error_t DSL_AVX_LineStateChange(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint32_t G997_Status,
   const DSL_boolean_t bResetValues,
   const DSL_int32_t nPMStatus,
   const DSL_char_t *sText,
   DSL_uint32_t *nActLineState,
   DSL_boolean_t *bEventCallback)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   const DSL_uint8_t nChannel = 0;

   DSL_DEBUG( DSL_DBG_WRN, (pContext, "DSL[%02d]: %s" DSL_CRLF , nLine, sText )); \

   if (G997_Status != *nActLineState)
   {
      if (DSL_ActLineStateSetAndRecoveryTimerStart(pContext, nLine, (DSL_DEV_LineState_t)G997_Status) != DSL_SUCCESS)
         return DSL_SUCCESS;
      DSL_UINT32_SET(DSL_DBS_PRE_LINESTATE, (DSL_uint32_t)*nActLineState);
      *nActLineState = G997_Status;
   }
   else
   {
      *bEventCallback = DSL_FALSE;
   }
   if (bResetValues == DSL_TRUE)
   {
      DSL_AVX_ResetShowtimeValues(pContext, nLine, nChannel);
   }
   if (nPMStatus >= 0)
   {
      DSL_AVX_dbSetPMMode(pContext, nLine, (DSL_G997_PowerManagementState_t)nPMStatus);
   }

   return(errorCode);
}


/**
   This function sets default GHS tones to the database dependent on the FW Annex.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies for which line the function will apply, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
   - or any other defined specific error code
*/
DSL_LOCAL DSL_Error_t DSL_AVX_HsTonesDefaultsSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   const DSL_uint8_t nChannel = 0;

   /* change only if empty (after startup or DB reset) */
   if (DSL_UINT16_GET(DSL_DBL_HS_TONES) == 0)
   {
      /* note: add a logic for Annex B defaults */
      DSL_UINT16_SET(DSL_DBL_HS_TONES, DSL_HS_TONES_VDSL2_A43);

      DSL_DEBUG( DSL_DBG_WRN, (pContext,
        "DSL_AVX_HsTonesDefaultsSet: new DSL_DBL_HS_TONES setting %d" DSL_CRLF,
        DSL_UINT16_GET(DSL_DBL_HS_TONES)) );
   }

   return(errorCode);
}

/**
   This function calculates the net data rate in case of retransmission usage
   from the framing parameters (LP1).

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies for which line the function will apply, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
   - or any other defined specific error code
*/
DSL_LOCAL DSL_Error_t DSL_AVX_RtxNdrCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection)
{
   const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_DEV_OpProfileMode_t nMode = DSL_DEV_MODE_ADSL;
   DSL_boolean_t bRtxUsed = DSL_FALSE;

   if (nDirection == DSL_DOWNSTREAM)
   {
      bRtxUsed = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) == (DSL_uint8_t)DSL_RTX_USED);
   }
   else
   {
      bRtxUsed = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_US) == (DSL_uint8_t)DSL_RTX_USED);
   }

   if (bRtxUsed)
   {
      DSL_uint16_t nNFEC, nRFEC, nLSYMB;
      DSL_uint8_t nV, nQ, nFT, nW;
      DSL_float_t ACTNDR = 0;
      DSL_float_t nFS = 0;

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
      {
         if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
            nMode = DSL_DEV_MODE_VDSL_30A;
         else
            nMode = DSL_DEV_MODE_VDSL;
      }
#endif

      if (nDirection == DSL_DOWNSTREAM)
      {
         nNFEC  = DSL_UINT16_GET(DSL_DBS_FRAMING_NFEC_DS);
         nRFEC  = DSL_UINT16_GET(DSL_DBS_FRAMING_RP_DS);
         nLSYMB = DSL_UINT16_GET(DSL_DBS_FRAMING_LP_DS);
         nFT    = DSL_UINT8_GET(DSL_DBS_FRAMING_RETX_FT_DS);
         nV     = DSL_UINT8_GET(DSL_DBS_FRAMING_RETX_V_DS);
         nQ     = DSL_UINT8_GET(DSL_DBS_FRAMING_RETX_Q_DS);
      }
      else
      {
         nNFEC  = DSL_UINT16_GET(DSL_DBS_FRAMING_NFEC_US);
         nRFEC  = DSL_UINT16_GET(DSL_DBS_FRAMING_RP_US);
         nLSYMB = DSL_UINT16_GET(DSL_DBS_FRAMING_LP_US);
         nFT    = DSL_UINT8_GET(DSL_DBS_FRAMING_RETX_FT_US);
         nV     = DSL_UINT8_GET(DSL_DBS_FRAMING_RETX_V_US);
         nQ     = DSL_UINT8_GET(DSL_DBS_FRAMING_RETX_Q_US);
      }

      if ((nFT <= 1) || (nFT > 4))
      {
         nW = 0;
      }
      else if ( nFT == 4 )
      {
         switch (nMode)
         {
            case DSL_DEV_MODE_VDSL:
            case DSL_DEV_MODE_VDSL_30A:
               nW = 8;
               break;
            case DSL_DEV_MODE_ADSL:
            default:
               nW = 2;
               break;
         }
      }
      else
      {
         nW = 1;
      }

      switch (nMode)
      {
         case DSL_DEV_MODE_VDSL:
            nFS = (DSL_float_t)((4000. * 256.) / 257.);
            break;
         case DSL_DEV_MODE_VDSL_30A:
            nFS = (DSL_float_t)((8000. * 256.) / 257.);
            break;
         case DSL_DEV_MODE_ADSL:
         default:
            nFS = 4000.;
            break;
      }

      if (nQ * nNFEC)
         ACTNDR = (DSL_float_t)(nFS * nLSYMB * (1 - ((DSL_float_t)(2 + nV + nW + nQ*nRFEC))/(nQ * nNFEC)));

      if (nDirection == DSL_DOWNSTREAM)
      {
         DSL_UINT32_SET(DSL_DBSC_RETX_ACTNDR_DS, (DSL_uint32_t)ACTNDR);
      }
      else
      {
         DSL_UINT32_SET(DSL_DBSC_RETX_ACTNDR_US, (DSL_uint32_t)ACTNDR);
      }
   }

   return (errorCode);
}

/**
   This function calculates the INP REIN and SHINE in case of retransmission usage
   from the framing parameters (LP1).

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies for which line the function will apply, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
   - or any other defined specific error code
*/
DSL_LOCAL DSL_Error_t DSL_AVX_RtxInpDsCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection)
{
   const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_DEV_OpProfileMode_t nMode = DSL_DEV_MODE_ADSL;
   DSL_dbi_t nDbiRtxUsed;

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
         nMode = DSL_DEV_MODE_VDSL_30A;
      else
         nMode = DSL_DEV_MODE_VDSL;
   }
#endif

   if (nDirection == DSL_DOWNSTREAM)
      nDbiRtxUsed = DSL_DBS_RTX_USED_DS;
   else
      nDbiRtxUsed = DSL_DBS_RTX_USED_US;

   if (DSL_UINT8_GET(nDbiRtxUsed) == (DSL_uint8_t)DSL_RTX_USED)
   {
      DSL_uint16_t B10, R1, L1, M1, T1, nInp;
      DSL_uint8_t V, Q, Qtx, FT;
      DSL_dbEntry_t *pDb;
      DSL_uint32_t ETR;
      DSL_dbi_t  nDbiRtxB10, nDbiRtxR1, nDbiRtxL1,
                  nDbiRtxM1, nDbiRtxT1, nDbiRtxV, nDbiRtxQ,
                  nDbiRtxQtx, nDbiRtxFT, nDbiRtxDelayMax,
                  nDbiInpMin, nDbiInpMin8, nDbiIatRein,
                  nDbiShineRatio, nDbiActInpRein, nDbiActInpShine,
                  nDbiInpMinRein, nDbiInpMin8Rein;
      DSL_uint32_t nDelayMax = 0;
      DSL_int32_t nInpMin = 0, nInpMinRein = 0;
      DSL_float_t fShineRatio = 0.0;
      DSL_uint8_t nIatRein = 0;

      if (nDirection == DSL_DOWNSTREAM)
      {
         nDbiRtxB10 = DSL_DBS_FRAMING_BP_DS;
         nDbiRtxR1 = DSL_DBS_FRAMING_RP_DS;
         nDbiRtxL1 = DSL_DBS_FRAMING_LP_DS;
         nDbiRtxM1 = DSL_DBS_FRAMING_MP_DS;
         nDbiRtxT1 = DSL_DBS_FRAMING_TP_DS;
         nDbiRtxV = DSL_DBS_FRAMING_RETX_V_DS;
         nDbiRtxQ = DSL_DBS_FRAMING_RETX_Q_DS;
         nDbiRtxQtx = DSL_DBS_FRAMING_RETX_QTX_DS;
         nDbiRtxFT = DSL_DBS_FRAMING_RETX_FT_DS;
         nDbiRtxDelayMax = DSL_DBC_RETX_DELAYMAX_DS;
         nDbiInpMin = DSL_DBC_RETX_INPMIN_SHINE_DS;
         nDbiInpMin8 = DSL_DBC_RETX_INPMIN8_SHINE_DS;
         nDbiInpMinRein = DSL_DBC_RETX_INPMIN_REIN_DS;
         nDbiInpMin8Rein = DSL_DBC_RETX_INPMIN8_REIN_DS;
         nDbiIatRein = DSL_DBC_RETX_IAT_REIN_DS;
         nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_DS;
         nDbiActInpRein = DSL_DBSC_RETX_ACTINP_REIN_DS;
         nDbiActInpShine = DSL_DBSC_ACT_INP_DS;

      }
      else
      {
         nDbiRtxB10 = DSL_DBS_FRAMING_BP_US;
         nDbiRtxR1 = DSL_DBS_FRAMING_RP_US;
         nDbiRtxL1 = DSL_DBS_FRAMING_LP_US;
         nDbiRtxM1 = DSL_DBS_FRAMING_MP_US;
         nDbiRtxT1 = DSL_DBS_FRAMING_TP_US;
         nDbiRtxV = DSL_DBS_FRAMING_RETX_V_US;
         nDbiRtxQ = DSL_DBS_FRAMING_RETX_Q_US;
         nDbiRtxQtx = DSL_DBS_FRAMING_RETX_QTX_US;
         nDbiRtxFT = DSL_DBS_FRAMING_RETX_FT_US;
         nDbiRtxDelayMax = DSL_DBC_RETX_DELAYMAX_US;
         nDbiInpMin = DSL_DBC_RETX_INPMIN_SHINE_US;
         nDbiInpMin8 = DSL_DBC_RETX_INPMIN8_SHINE_US;
         nDbiInpMinRein = DSL_DBC_RETX_INPMIN_REIN_US;
         nDbiInpMin8Rein = DSL_DBC_RETX_INPMIN8_REIN_US;
         nDbiIatRein = DSL_DBC_RETX_IAT_REIN_DS; /* use DS only */
         nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_US;
         nDbiActInpRein = DSL_DBSC_RETX_ACTINP_REIN_US;
         nDbiActInpShine = DSL_DBSC_ACT_INP_US;
      }

      B10   = DSL_UINT16_GET(nDbiRtxB10);
      R1    = DSL_UINT16_GET(nDbiRtxR1);
      L1    = DSL_UINT16_GET(nDbiRtxL1);
      M1    = DSL_UINT16_GET(nDbiRtxM1);
      T1    = DSL_UINT16_GET(nDbiRtxT1);
      V     = DSL_UINT8_GET(nDbiRtxV);
      Q     = DSL_UINT8_GET(nDbiRtxQ);
      Qtx   = DSL_UINT8_GET(nDbiRtxQtx);
      FT    = DSL_UINT8_GET(nDbiRtxFT);

      /* If FE data is not yet available - RTX ACTDR (ETR) should be
          calculated from framing parameters. This should be already 
          calculated before. */
      if (nDirection == DSL_DOWNSTREAM)
      {
         if (DSL_ULONG_GET(DSL_DBS_FE_STATUS_TIMEOUT_ID) != 0)
         {
            ETR = DSL_UINT32_GET(DSL_DBSC_RETX_EST_ETR_DS);
         }
         else
         {
            ETR = DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_DS);
         }
      }
      else
      {
         ETR = DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_US);
      }

      nDelayMax = (DSL_uint32_t)DSL_UINT8_GET(nDbiRtxDelayMax);
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
      {
         nInpMin = (DSL_int32_t)DSL_UINT8_GET(nDbiInpMin8);
      }
      else
#endif
      {
         nInpMin = (DSL_int32_t)DSL_UINT8_GET(nDbiInpMin);
      }
      fShineRatio = (DSL_float_t)DSL_UINT8_GET(nDbiShineRatio);
      nIatRein = DSL_UINT8_GET(nDbiIatRein);

      /* Actual impulse noise protection against REIN (ACTINP_REIN): */
      nInp = (DSL_uint16_t)(DSL_CalcActINPREIN(pContext,
                                                nLine,
                                                Qtx,
                                                M1,
                                                B10,
                                                R1,
                                                Q,
                                                L1,
                                                V,
                                                FT,
                                                T1,
                                                ETR,
                                                nMode,
                                                0,
                                                0,
                                                nDelayMax,
                                                nInpMin,
                                                fShineRatio,
                                                nIatRein) * 10);

      pDb = DSL_DB_GetPtrCfgData(pContext, nDbiActInpRein);
      DSL_CHECK_DB_CFG_PTR_RETURN(pDb);
      CHECKSETSPECIAL_PARAM_RANGE(nInp, pDb->nMin, pDb->nMax,
         DSL_G997_SPECIAL_VALUE_ACTINP_LEVEL, pDb->pcName);
      DSL_UINT16_SET(nDbiActInpRein, nInp);


#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
      {
         nInpMinRein = (DSL_int32_t)DSL_UINT8_GET(nDbiInpMin8Rein);
      }
      else
#endif
      {
         nInpMinRein = (DSL_int32_t)DSL_UINT8_GET(nDbiInpMinRein);
      }


      /* ActINP is defined in fraction of 0.1 symbols.
         Always return the next lower quantized value  */
      nInp = (DSL_uint16_t)(DSL_CalcActINPSHINE(pContext,
                                   nLine,
                                   Qtx,
                                   M1,
                                   B10,
                                   R1,
                                   Q,
                                   L1,
                                   nMode,
                                   0,
                                   nDelayMax,
                                   nInpMinRein,
                                   nIatRein) * 10);
      pDb = DSL_DB_GetPtrCfgData(pContext, nDbiActInpShine);
      DSL_CHECK_DB_CFG_PTR_RETURN(pDb);
      CHECKSETSPECIAL_PARAM_RANGE(nInp, pDb->nMin, pDb->nMax,
         DSL_G997_SPECIAL_VALUE_ACTINP_LEVEL, pDb->pcName);
      DSL_UINT16_SET(nDbiActInpShine, nInp);
   }

   return (errorCode);
}

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   This function calculates the actual expected throughput unlimited
   in case of retransmission usage from the framing parameters (LP1).

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies for which line the function will apply, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
   - or any other defined specific error code
*/
DSL_LOCAL DSL_Error_t DSL_AVX_RtxActEtruCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection)
{
   const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_DEV_OpProfileMode_t nMode = DSL_DEV_MODE_ADSL;
   DSL_dbi_t nDbiRtxUsed, nDbiEtru, nDbiB10, nDbiR1, nDbiL1, nDbiM1, nDbiQ, nDbiAttNdr,
                           nDbiInpMinRein, nDbiInpMin8Rein, nDbiIatRein, nDbiShineRatio;
   DSL_float_t fShineRatio = 0.0;
   DSL_uint32_t nInpMinRein = 0, nAttNdr = 0;
   DSL_uint8_t nIatRein = 0;

   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
         nMode = DSL_DEV_MODE_VDSL_30A;
      else
#endif
         nMode = DSL_DEV_MODE_VDSL;
   }
   if ( nDirection == DSL_DOWNSTREAM )
   {
      nDbiRtxUsed = DSL_DBS_RTX_USED_DS;
      nDbiEtru = DSL_DBSC_RETX_ATTETRU_DS;
      nDbiB10 = DSL_DBS_FRAMING_BP_DS;
      nDbiR1 = DSL_DBS_FRAMING_RP_DS;
      nDbiL1 = DSL_DBS_FRAMING_LP_DS;
      nDbiM1 = DSL_DBS_FRAMING_MP_DS;
      nDbiQ = DSL_DBS_FRAMING_RETX_Q_DS;
      nDbiAttNdr = DSL_DBS_ATTNDR_DS;
      nDbiInpMinRein = DSL_DBC_RETX_INPMIN_REIN_DS;
      nDbiInpMin8Rein = DSL_DBC_RETX_INPMIN8_REIN_DS;
      nDbiIatRein = DSL_DBC_RETX_IAT_REIN_DS;
      nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_DS;
   }
   else
   {
      nDbiRtxUsed = DSL_DBS_RTX_USED_US;
      nDbiEtru = DSL_DBSC_RETX_ATTETRU_US;
      nDbiB10 = DSL_DBS_FRAMING_BP_US;
      nDbiR1 = DSL_DBS_FRAMING_RP_US;
      nDbiL1 = DSL_DBS_FRAMING_LP_US;
      nDbiM1 = DSL_DBS_FRAMING_MP_US;
      nDbiQ = DSL_DBS_FRAMING_RETX_Q_US;
      nDbiAttNdr = DSL_DBS_ATTNDR_US;
      nDbiInpMinRein = DSL_DBC_RETX_INPMIN_REIN_US;
      nDbiInpMin8Rein = DSL_DBC_RETX_INPMIN8_REIN_US;
      nDbiIatRein = DSL_DBC_RETX_IAT_REIN_DS; /* use DS only */
      nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_US;
   }

   if (DSL_UINT8_GET(nDbiRtxUsed) == (DSL_uint8_t)DSL_RTX_USED)
   {
      DSL_uint32_t nEtru;
      DSL_uint16_t B10, R1, L1, M1;
      DSL_uint8_t Q;

      B10   = DSL_UINT16_GET(nDbiB10);
      R1    = DSL_UINT16_GET(nDbiR1);
      L1    = DSL_UINT16_GET(nDbiL1);
      M1    = DSL_UINT16_GET(nDbiM1);
      Q     = DSL_UINT8_GET(nDbiQ);

      nAttNdr = (DSL_uint32_t)DSL_UINT32_GET(nDbiAttNdr);

      fShineRatio = (DSL_float_t)DSL_UINT8_GET(nDbiShineRatio);
      nIatRein = DSL_UINT8_GET(nDbiIatRein);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
      {
         nInpMinRein = (DSL_int32_t)DSL_UINT8_GET(nDbiInpMin8Rein);
      }
      else
#endif
      {
         nInpMinRein = (DSL_int32_t)DSL_UINT8_GET(nDbiInpMinRein);
      }

      /* Actual impulse noise protection against REIN (ACTINP_REIN): */
      nEtru = (DSL_uint32_t)(DSL_CalcAttETRU( pContext, nLine,
                               M1, B10, R1, Q, L1, nMode, nInpMinRein, fShineRatio,
                               nIatRein, nAttNdr));

      DSL_UINT32_SET(nDbiEtru, nEtru);
   }

   return (errorCode);
}

/**
   This function calculates the actual expected throughput 
   in case of retransmission usage from the framing parameters (LP1).

   \param pContext   Pointer to dsl library context structure, [I]
   \param nLine      Specifies for which line the function will apply, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
   - or any other defined specific error code
*/
DSL_LOCAL DSL_Error_t DSL_AVX_RtxETRCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection
)
{
   const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_DEV_OpProfileMode_t nMode = DSL_DEV_MODE_ADSL;
   DSL_uint32_t nInpMinRein = 0, nActNdr = 0, nMaxEtrRtx = 0;
   DSL_float_t fShineRatio = 0.0;
   DSL_uint8_t nIatRein = 0;

   DSL_dbi_t nDbiRtxUsed, nDbiB10, nDbiR1, nDbiL1, nDbiM1, nDbiQ;
   DSL_dbi_t nDbiInpMinRein, nDbiShineRatio, nDbiActNdr, nDbiMaxEtr, nDbiEtr;

   /* Calculate ETR only for FE but not only after Showtime entry and even afterwards;
      Needed to check for reasonable values reported by CPE e.g. after SRA */
   if (nDirection == DSL_DOWNSTREAM)
   {
      nDbiRtxUsed = DSL_DBS_RTX_USED_DS;
      nDbiB10 = DSL_DBS_FRAMING_BP_DS;
      nDbiR1 = DSL_DBS_FRAMING_RP_DS;
      nDbiL1 = DSL_DBS_FRAMING_LP_DS;
      nDbiM1 = DSL_DBS_FRAMING_MP_DS;
      nDbiQ = DSL_DBS_FRAMING_RETX_Q_DS;
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
      {
         nDbiInpMinRein = DSL_DBC_RETX_INPMIN8_REIN_DS;
      }
      else
      {
         nDbiInpMinRein = DSL_DBC_RETX_INPMIN_REIN_DS;
      }
      nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_DS;
      nDbiActNdr = DSL_DBSC_RETX_ACTNDR_DS;
      nDbiMaxEtr = DSL_DBC_RETX_MAXETR_DS;
      nDbiEtr = DSL_DBSC_RETX_EST_ETR_DS;
   }
   else
   {
      nDbiRtxUsed = DSL_DBS_RTX_USED_US;
      nDbiB10 = DSL_DBS_FRAMING_BP_US;
      nDbiR1 = DSL_DBS_FRAMING_RP_US;
      nDbiL1 = DSL_DBS_FRAMING_LP_US;
      nDbiM1 = DSL_DBS_FRAMING_MP_US;
      nDbiQ = DSL_DBS_FRAMING_RETX_Q_US;
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
      {
         nDbiInpMinRein = DSL_DBC_RETX_INPMIN8_REIN_US;
      }
      else
      {
         nDbiInpMinRein = DSL_DBC_RETX_INPMIN_REIN_US;
      }
      nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_US;
      nDbiActNdr = DSL_DBSC_RETX_ACTNDR_US;
      nDbiMaxEtr = DSL_DBC_RETX_MAXETR_US;
      nDbiEtr = DSL_DBSC_RETX_EST_ETR_US;
   }

   nIatRein = DSL_UINT8_GET(DSL_DBC_RETX_IAT_REIN_DS);
   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
         nMode = DSL_DEV_MODE_VDSL_30A;
      else
         nMode = DSL_DEV_MODE_VDSL;
   }

   if (DSL_UINT8_GET(nDbiRtxUsed) == (DSL_uint8_t)DSL_RTX_USED)
   {
      DSL_uint32_t nEtr;
      DSL_uint16_t B10, R1, L1, M1, V, Qtx, Qrx;
      DSL_uint8_t Q;

      B10   = DSL_UINT16_GET(nDbiB10);
      R1    = DSL_UINT16_GET(nDbiR1);
      L1    = DSL_UINT16_GET(nDbiL1);
      M1    = DSL_UINT16_GET(nDbiM1);
      Q     = DSL_UINT8_GET(nDbiQ);

      nInpMinRein = (DSL_int32_t)DSL_UINT8_GET(nDbiInpMinRein);
      fShineRatio = (DSL_float_t)DSL_UINT8_GET(nDbiShineRatio);
      nActNdr = (DSL_uint32_t)DSL_UINT32_GET(nDbiActNdr);

      /* Actual Expected Throughput: */
      if (nDirection == DSL_DOWNSTREAM)
      {
         nEtr = (((DSL_uint32_t)DSL_CalcETR( pContext, nLine, M1, B10, R1, Q, L1, nMode,
                      nInpMinRein, fShineRatio, nIatRein, nActNdr )) / 1000) * 1000;
      }
      else
      {
         Qtx   = DSL_UINT8_GET(DSL_DBS_FRAMING_RETX_QTX_US);
         Qrx   = DSL_UINT8_GET(DSL_DBS_FRAMING_RETX_QRX_US);
         V     = DSL_UINT8_GET(DSL_DBS_FRAMING_RETX_V_US);

         nEtr = (((DSL_uint32_t)DSL_CalcETRUS( pContext, nLine, M1, B10, R1, Q, L1, nMode,
                      nInpMinRein, fShineRatio, nIatRein, nActNdr, Qtx, Qrx, V )) / 1000) * 1000;
      }

      nMaxEtrRtx = DSL_UINT32_GET(nDbiMaxEtr);
      nEtr = DSL_MIN(nEtr, nMaxEtrRtx);

      DSL_UINT32_SET(nDbiEtr, nEtr);
   }

   return (errorCode);

}

#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */


/**
   This function sends the firmware message "CMD_BearerChsXX_Get".

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]
   \param nChannel Specifies the bearer channel for the message, [I]
   \param nDirection Upstream or Downstream, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_BearerChannelStatusGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_uint8_t nChannel,
   const DSL_AccessDir_t nDirection)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_DEV_VersionCheck_t nFwVer = DSL_VERSION_ERROR;
   DSL_boolean_t bRtxUsed = DSL_FALSE;
   AVX_AckBearerChStatusUsGet_t sAck;

   DSL_CHECK_CTX_POINTER(pContext);

   nRet = DSL_CheckFirmwareVersion(pContext, nLine, 5, -1, -1, &nFwVer);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during FW version get!" DSL_CRLF, nLine);

   /* get bearer channel params and calculate INP */
   nRet = DSL_AVX_SendMsgRtxFrameDataGet(pContext, nLine, DSL_DOWNSTREAM);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during Framedata RTx DS Get!" DSL_CRLF, nLine);

   if ( DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2) )
   {
      if ((nDirection == DSL_UPSTREAM) &&(( nFwVer == DSL_VERSION_BIGGER ) || ( nFwVer == DSL_VERSION_EQUAL )))
      {
         nRet = DSL_AVX_SendMsgRtxFrameDataGet(pContext, nLine, DSL_UPSTREAM);
         DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
            "Error during Framedata RTx US Get!" DSL_CRLF, nLine);
      }

      /* for VDSL mode: retrieve framing parameters */
      nRet = DSL_AVX_SendMsgVdsl2FrameDataGet(pContext, nLine, nDirection);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error during Frame Data Ext Get!" DSL_CRLF, nLine);
   }
   else
   {
      if (nDirection == DSL_UPSTREAM)
      {
         /* since FRAME_DATA_US_GET is not sent in ADSL - set RTX_USED here */
         if (DSL_RTX_OFF == (DSL_RtxEnabling_t)DSL_UINT8_GET(DSL_DBL_RETX_ENABLE_US))
         {
            DSL_UINT8_SET(DSL_DBS_RTX_USED_US, DSL_RTX_FORBIDDEN);
         }
         else
         {
            DSL_UINT8_SET(DSL_DBS_RTX_USED_US, DSL_RTX_NOT_SUPP_BY_BOTH);
         }
      }

      /* for ADSL mode: retrieve framing parameters */
      nRet = DSL_AVX_SendMsgAdslFrameDataGet(pContext, nLine, nDirection);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error during ADSL Framedata Get!" DSL_CRLF, nLine);
   }

   if ((nDirection == DSL_DOWNSTREAM) || ( nFwVer == DSL_VERSION_BIGGER ) || ( nFwVer == DSL_VERSION_EQUAL ))
   {

      /* RTX ACTNDR, INPREIN and INP SHINE could be  now retreived
         directly from the FW (from FS4 onward)*/
      nRet = DSL_AVX_RtxNdrCalculate(pContext, nLine, nDirection);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error during RTX ACTNDR DS calculation!" DSL_CRLF, nLine);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   /* If FE data is not yet available - RTX ACTDR (ETR) should be
       calculated from framing parameters */
   nRet = DSL_AVX_RtxETRCalculate(pContext, nLine, nDirection);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during ETR calculation!" DSL_CRLF, nLine);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
   }
   
   if ( nDirection == DSL_DOWNSTREAM )
   {
      bRtxUsed = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) == (DSL_uint8_t)DSL_RTX_USED);
   }
   else
   {
      bRtxUsed = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_US) == (DSL_uint8_t)DSL_RTX_USED);
   }

   if (bRtxUsed)
   {
      nRet =  DSL_AVX_SendMsgBearerChSRtxGet(pContext, nLine, nDirection);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error during BearerChS Rtx Get!" DSL_CRLF, nLine);
   }

   nRet = DSL_AVX_SendMsgBearerChSGet(pContext, nLine, nDirection, &sAck);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during BearerChS Get!" DSL_CRLF, nLine);
   /* Copy data only if successful */
   if (nRet >= 0)
   {
      errorCode = DSL_AVX_OnBearerChsGet (pContext, nLine, nDirection, &sAck);
   }

   if ((nDirection == DSL_DOWNSTREAM) || ( nFwVer == DSL_VERSION_BIGGER ) || ( nFwVer == DSL_VERSION_EQUAL ))
   {
      nRet = DSL_AVX_RtxInpDsCalculate(pContext, nLine, nDirection);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error during RTX INP DS calculation!" DSL_CRLF, nLine);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
      /* ATTNDR should be already retrieved via DSL_AVX_SendMsgLineStatus */
      nRet = DSL_AVX_RtxActEtruCalculate(pContext, nLine, nDirection);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error during RTX ETRU  calculation!" DSL_CRLF, nLine);
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
   }

   return (errorCode);
}

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_Eaps2FsmStateSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_Eaps2States_t nEaps2StateNew)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_Eaps2States_t nCurState = (DSL_Eaps2States_t) DSL_UINT8_GET(DSL_DBS_EAPS2_STATE);

   if (nCurState == DSL_EAPS2_DISABLED)
   {
      DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2FsmStateSet EAPS2 off" DSL_CRLF ,
         nLine));
      return DSL_SUCCESS;
   }

   if (nEaps2StateNew > DSL_EAPS2_LAST)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2FsmStateSet illegal state %d" DSL_CRLF ,
         nLine, nEaps2StateNew));
      return DSL_ERROR;
   }

   /* no change */
   if (nCurState == nEaps2StateNew)
      return errorCode;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2FsmStateSet %d" DSL_CRLF ,
      nLine, nEaps2StateNew));

   DSL_UINT8_SET(DSL_DBS_EAPS2_STATE, nEaps2StateNew);

   if (pContext->pEventCallback != DSL_NULL)
   {
      DSL_boolean_t bSemMask = DSL_FALSE;

      bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_EAPS2_STATE));
      if (bSemMask == DSL_FALSE)
      {
         DSL_CB_DATA_Eaps2State_t nCbData;
         nCbData.nEaps2State = nEaps2StateNew;

         (void)(pContext->pEventCallback)( (DSL_void_t *)pContext,
                                     nLine,
                                     DSL_CHANNEL_NA,
                                     DSL_ACCESSDIR_NA,
                                     DSL_ATUDIR_NA,
                                     DSL_CBS_EAPS2_STATE,
                                     (DSL_CB_DATA_Union_t *)&nCbData );
      }
   }

   return(errorCode);
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_Eaps2FsmEnable(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_boolean_t bEnable)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;

   if (bEnable)
   {
      /* if already enabled, this causes not a reset of the state machine
      because it might be currently running */
      if (_DSLAPI DSL_AVX_Eaps2FsmStateGet(pContext, nLine) == DSL_EAPS2_DISABLED)
      {
         /* backup current VDSL bits for later en/disabling */
         DSL_AVX_VdslBackup(pContext, nLine);
         DSL_AVX_Eaps2FsmReset(pContext, nLine);
      }
   }
   else
   {
      DSL_UINT8_SET(DSL_DBS_EAPS2_STATE, DSL_EAPS2_DISABLED);
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2FsmEnable %s" DSL_CRLF ,
      nLine, (bEnable?"true":"false")));

   return(errorCode);
}

DSL_Error_t DSL_AVX_Eaps2Initialize(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet;
   static const DSL_uint8_t nChannel = 0;

   if (DSL_AVX_Eaps2FsmStateGet(pContext, nLine) == DSL_EAPS2_ENABLED)
   {
      /* backup current VDSL bits for later en/disabling */
      nRet = DSL_AVX_VdslBackup(pContext, nLine);
      DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

      /* reset valid profile mask */
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_FAILED, 0);
      DSL_UINT8_SET(DSL_DBL_ADSL_PROFILE_FAILED, DSL_FALSE);

      errorCode = DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2InitialProfileSet failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      nRet = DSL_AVX_Eaps2FsmReset(pContext, nLine);
      DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);

      nRet = DSL_AVX_Eaps2FsmStateSet(pContext, nLine, DSL_EAPS2_ACTIVATE);
      DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
   }
   else if (DSL_AVX_Eaps2FsmStateGet(pContext, nLine) == DSL_EAPS2_DISABLED)
   {
      /* Reset EAPS2_RETRAIN_MODE flag since it is also used in
         EAPS2-disabled case for MemSplit retrains  */
      DSL_MemPartRetrain_t retrainMode = (DSL_MemPartRetrain_t)DSL_UINT8_GET(DSL_DBL_MEMSPLIT_RETRAIN_CFG);
      DSL_UINT8_SET(DSL_DBS_EAPS2_RETRAIN_MODE, (retrainMode == DSL_MEMPART_RETRAIN_ON)?DSL_TRUE:DSL_FALSE);
   }

   return(errorCode);
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_Eaps2FsmReset(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint16_t nChannel = 0;
   DSL_boolean_t cdCheck;
   DSL_MemPartRetrain_t retrainMode;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2FsmReset" DSL_CRLF, nLine));
      
   cdCheck     = (DSL_boolean_t)DSL_UINT8_GET(DSL_DBI_EAPS2_CFG_D2_CHECK);
   retrainMode = (DSL_MemPartRetrain_t)DSL_UINT8_GET(DSL_DBL_MEMSPLIT_RETRAIN_CFG);

   DSL_UINT8_SET(DSL_DBS_EAPS2_STATE, DSL_EAPS2_ENABLED);
   DSL_UINT8_SET(DSL_DBS_EAPS2_D2_CHECK, cdCheck);
   DSL_UINT8_SET(DSL_DBS_EAPS2_RECONF_COUNT, 0);
   DSL_UINT8_SET(DSL_DBS_EAPS2_FW_FAIL_COUNT, 0);
   DSL_UINT8_SET(DSL_DBS_EAPS2_FAIL_COUNT, 0);
   DSL_AVX_VdslRestore(pContext, nLine);

   if (DSL_AVX_Eaps2FsmStateGet(pContext, nLine) == DSL_EAPS2_ENABLED)
   {
      /* set retrain mode to TRUE if the mempart retrain in on or auto */
      DSL_UINT8_SET(DSL_DBS_EAPS2_RETRAIN_MODE, (retrainMode == DSL_MEMPART_RETRAIN_OFF)?DSL_FALSE:DSL_TRUE);
   }
   else
   {
      /* set retrain mode to FALSE if the mempart retrain in off or auto */
      DSL_UINT8_SET(DSL_DBS_EAPS2_RETRAIN_MODE, (retrainMode == DSL_MEMPART_RETRAIN_ON)?DSL_TRUE:DSL_FALSE);
   }

   return(errorCode);
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Eaps2States_t DSL_AVX_Eaps2FsmStateGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static const DSL_uint8_t nChannel = 0;

   return ((DSL_Eaps2States_t)DSL_UINT8_GET(DSL_DBS_EAPS2_STATE));
}

/* Calculate memory splits for all RTX/IFEC modes
   from configuration only.
   This corresponds to ApsMemPartitioning spec case II. */ 
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2CalculateDsMemPortions(
      DSL_Context_t *pContext,
      const DSL_uint16_t nLine,
      DSL_uint8_t nProfile,
      DSL_uint32_t *nDsMemPortionIfec,
      DSL_uint32_t *nDsMemPortionRtx,
      DSL_uint32_t *nDsMemPortionRtxDsUs)
{
   static const DSL_int_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_int8_t nInitialDsMemPortion = -1;
   DSL_uint16_t nMaxDelayDs = 0, nMaxDelayUs = 0;

   errorCode = DSL_AVX_Eaps2DynamicItlvPartConfigCalculate(pContext,
                  nLine, nProfile, DSL_TRUE, DSL_FALSE, nDsMemPortionRtx);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartConfigCalculate "
         "for RTX failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2DynamicItlvPartConfigCalculate(pContext,
                  nLine, nProfile, DSL_TRUE, DSL_TRUE, nDsMemPortionRtxDsUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartConfigCalculate "
         "for RTX (DS+US) failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   /* FIXME: either initial MemPortion is only to be applied
      for the first configuration in an EAPS2 flow or only if Retrain mode is on */
   nInitialDsMemPortion = DSL_INT8_GET(DSL_DBL_MEMSPLIT_INIT_DS_MEM_PORTION);
   if ( nInitialDsMemPortion != -1 )
   {
      /* if initial ds mem portion was set then use it */
      *nDsMemPortionIfec = (DSL_uint32_t)nInitialDsMemPortion;
   }
   else
   {
      nMaxDelayDs = DSL_UINT16_GET(DSL_DBC_MAX_I_DELAY_DS);
      nMaxDelayUs = DSL_UINT16_GET(DSL_DBC_MAX_I_DELAY_US);

      if ((nMaxDelayDs == 1) && (nMaxDelayUs != 1))
      {
         /* 100% of the memory can be used for US */
         *nDsMemPortionIfec = 0;
      }
      else if ((nMaxDelayUs == 1) && (nMaxDelayDs != 1))
      {
         /* 100% of the memory can be used for DS */
         *nDsMemPortionIfec = 100;
      }
      else if ((nMaxDelayUs == nMaxDelayDs) && (nMaxDelayUs == 1))
      {
         /* memsplit doesn't matter at all - take the memsplit from the DB */
         *nDsMemPortionIfec = (DSL_uint32_t)DSL_UINT16_GET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION);
      }
      else
      {
         /* if initial ds mem portion was set then calculate interleaver dsl mem portion */
         errorCode = DSL_AVX_Eaps2DynamicItlvPartConfigCalculate(pContext,
                        nLine, nProfile, DSL_FALSE, DSL_FALSE, nDsMemPortionIfec);
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartConfigCalculate "
               "for IFEC failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }
      }
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2CalculateNextProfileDsMemPortion
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_int8_t memPortion = 0;
   DSL_uint32_t nDsMemPortion = 0;
   DSL_boolean_t bRtxUsedDs = DSL_FALSE, bRtxUsedUs = DSL_FALSE;
   DSL_boolean_t bRetrain = DSL_FALSE;
   DSL_dbi_t nDbiMemPortion;
   DSL_uint16_t nMaxDelayDs = 0, nMaxDelayUs = 0;
   static const DSL_uint8_t nChannel = 0;

   memPortion = (DSL_int8_t)DSL_INT8_GET(DSL_DBL_EAPS2_DS_MEM_PORTION);

   if ( memPortion == -1 )
   {
      bRtxUsedDs = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_DS)==(DSL_uint8_t)DSL_RTX_USED);
      bRtxUsedUs = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_US)==(DSL_uint8_t)DSL_RTX_USED);

      if ( bRtxUsedDs == DSL_FALSE ) /* IFEC mode */
      {
         nMaxDelayDs = DSL_UINT16_GET(DSL_DBC_MAX_I_DELAY_DS);
         nMaxDelayUs = DSL_UINT16_GET(DSL_DBC_MAX_I_DELAY_US);

         if ((nMaxDelayDs == 1) && (nMaxDelayUs != 1))
         {
            /* 100% of the memory can be used for US */
            nDsMemPortion = 0;
            goto MEMSPLIT_EXIT;
         }
         else if ((nMaxDelayUs == 1) && (nMaxDelayDs != 1))
         {
            /* 100% of the memory can be used for DS */
            nDsMemPortion = 100;
            goto MEMSPLIT_EXIT;
         }
         else if ((nMaxDelayUs == nMaxDelayDs) && (nMaxDelayUs == 1))
         {
            /* memsplit doesn't matter at all - take the memsplit from the DB */
            nDsMemPortion = (DSL_uint32_t)DSL_UINT16_GET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION);
            goto MEMSPLIT_EXIT;
         }
      }

      errorCode = DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate(pContext,
                     nLine, pBat, nFromProfile, nNextProfile,
                     bRtxUsedDs, bRtxUsedUs, &nDsMemPortion,
                     &bRetrain);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2CalculateNextProfileDsMemPortion for failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

MEMSPLIT_EXIT:

      if (bRtxUsedUs) nDbiMemPortion = DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION;
      else if (bRtxUsedDs) nDbiMemPortion = DSL_DBL_EAPS2_DS_RTX_MEM_PORTION;
      else nDbiMemPortion = DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION;
      DSL_UINT16_SET(nDbiMemPortion, nDsMemPortion);
   }

   return errorCode;
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_Eaps2Configure(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static const DSL_int_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_APS_Eaps2Config_t eaps2Config;
   DSL_APS_DBG_Eaps2Config_t dbgEaps2Config;
   AVX_CmdApsControlSet_t sCmd;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_Eaps2Configure" DSL_CRLF, nLine));

   nRet = DSL_APS_Eaps2ConfigGet(pContext, &eaps2Config);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "DSL_APS_Eaps2ConfigGet failed" DSL_CRLF, nLine);

   nRet = DSL_APS_DBG_Eaps2ConfigGet(pContext, &dbgEaps2Config);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "DSL_APS_DBG_Eaps2ConfigGet failed" DSL_CRLF, nLine);

   memset(&sCmd, 0, sizeof(sCmd));

   switch (eaps2Config.optimizationMode)
   {
   case DSL_EAPS2_OPTIMIZATION_DS_US:
      sCmd.Policy = AVX_APS_POLICY_DSUS;
      break;
   case DSL_EAPS2_OPTIMIZATION_US:
      sCmd.Policy = AVX_APS_POLICY_US;
      break;
   case DSL_EAPS2_OPTIMIZATION_DS:
      sCmd.Policy = AVX_APS_POLICY_DS;
      break;
   default:
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: unknown Eaps2 optimization mode" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   sCmd.Control_Ena |= AVX_8827_APS_ENA_MASK | AVX_8827_APS_EVT_ENA_MASK;
   if (dbgEaps2Config.cdCheck == DSL_FALSE)
   {
      sCmd.Control_Dis |= AVX_8827_APS_CDCHECK_DIS_MASK;
   }
   else
   {
      sCmd.Control_Ena |= AVX_8827_APS_CDCHECK_ENA_MASK | AVX_8827_APS_CDCHECK_ABORT_ENA_MASK;
   }

   nRet = DSL_AVX_SendMessage(pContext,
            nLine, MSGID_EXT(AVX_CMD_APS_CONTROL_SET),
            sizeof(sCmd), (DSL_uint8_t *) &sCmd,
            0, DSL_NULL);

   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "DSL_AVX_SendMessage AVX_CMD_APS_CONTROL failed" DSL_CRLF, nLine);

   if (dbgEaps2Config.operatingModePreselection && dbgEaps2Config.cdCheck)
   {
      nRet = DSL_AVX_SendMsgApsPreselectDataSet(pContext, nLine);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_FALSE, errorCode,
         "DSL_AVX_SendMsgApsPreselectDataSet failed" DSL_CRLF, nLine);
   }

   DSL_AVX_Eaps2D2CheckSend(pContext, nLine, DSL_TRUE);

   /* Reset last profile to a special value */
   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_LAST, 0xFF);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_Eaps2Configure" DSL_CRLF, nLine));

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_SendMsgApsPreselectDataSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   AVX_CmdApsPreselectDataSet_t sCmd;
   DSL_AVX_APS_PreselectData_t *pData;
   DSL_AVX_APS_PreselectDataTable_t sPreselectTable;
   unsigned int n;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_SendMsgApsPreselectDataSet" DSL_CRLF, nLine));

   nRet = DSL_AVX_Eaps2PreselectionTableGet(pContext, nLine, &sPreselectTable);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "error getting Eaps2PreselectionTable" DSL_CRLF, nLine);

   memset(&sCmd, 0, sizeof(sCmd));
   for (n = 0; n < DSL_ARRAY_LENGTH(sPreselectTable.Entry); n++)
   {
      pData = &sPreselectTable.Entry[n];

      if (pData->vdslProfile == 0)
         continue;

      sCmd.tVdslProfileSel             = pData->vdslProfile;
      sCmd.tPreselData.US0Usage        = pData->US0Usage;
      sCmd.tPreselData.MaxnomatpDs     = pData->MaxnomatpDs;
      sCmd.tPreselData.MaxFrequency    = DSL_MAX(256,pData->MaxFrequency);

      nRet = DSL_AVX_SendMessage(pContext,
               nLine, MSGID_EXT(AVX_CMD_APS_PRESELECT_DATA_SET),
               sizeof(sCmd), (DSL_uint8_t *) &sCmd,
               0, DSL_NULL);

      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_FALSE, errorCode,
         "DSL_AVX_SendMessage AVX_CMD_APS_PRESELECT_DATA_SET failed" DSL_CRLF, nLine);
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_SendMsgApsPreselectDataSet" DSL_CRLF, nLine));

   return errorCode;
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_Eaps2Shutdown(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   AVX_CmdApsControlSet_t sCmd;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_Eaps2Shutdown" DSL_CRLF, nLine));

   memset(&sCmd, 0, sizeof(sCmd));
   sCmd.Policy = AVX_APS_POLICY_DS;
   sCmd.Control_Dis |= AVX_8827_APS_DIS_MASK;

   nRet = DSL_AVX_SendMessage(pContext,
            nLine, MSGID_EXT(AVX_CMD_APS_CONTROL_SET),
            sizeof(sCmd), (DSL_uint8_t *) &sCmd,
            0, DSL_NULL);

   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_FALSE, errorCode,
      "DSL_AVX_SendMessage AVX_CMD_APS_CONTROL failed" DSL_CRLF, nLine);


   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_Eaps2Shutdown" DSL_CRLF, nLine));

   return errorCode;
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_CalculateMemPortions
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
)
{
   static const DSL_int_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_int8_t nMemPortion = -1;
   DSL_uint32_t nDsMemPortionIfec = 0, nDsMemPortionRtx = 0, nDsMemPortionRtxDsUs;
   DSL_uint8_t nProfile = 0;
   DSL_Eaps2States_t nEaps2State = DSL_EAPS2_DISABLED;
   DSL_Profile_t nConfiguredProfile;


   if ((DSL_boolean_t)DSL_UINT8_GET(DSL_DBS_MEMSPLIT_RETRAIN_MODE) == DSL_TRUE)
   {
      /* if lwc was issued due to MemSplit retrain - skip calculation*/
      DSL_UINT8_SET(DSL_DBS_MEMSPLIT_RETRAIN_MODE, DSL_FALSE);
      return errorCode;
   }

   if (!(DSL_G997_IsVdslConfigured(pContext, nLine)))
   {
      return errorCode;
   }

   nEaps2State = DSL_AVX_Eaps2FsmStateGet(pContext, nLine);
   if (nEaps2State == DSL_EAPS2_ACTIVATE)  /* The first EAPS2 configuration */
   {
      nProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);
   }
   else if (nEaps2State == DSL_EAPS2_DISABLED)
   {
      /* EAPS2 is off and no memsplit retrain is active*/
      errorCode = DSL_VdslConfiguredProfileGet(pContext, nLine, &nConfiguredProfile);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: Unable to get profile: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      switch (nConfiguredProfile)
      {
         case DSL_PROFILE_8A: nProfile = DSL_G997_PROFILES_8A; break;
         case DSL_PROFILE_8B: nProfile = DSL_G997_PROFILES_8B; break;
         case DSL_PROFILE_8C: nProfile = DSL_G997_PROFILES_8C; break;
         case DSL_PROFILE_8D: nProfile = DSL_G997_PROFILES_8D; break;
         case DSL_PROFILE_12A: nProfile = DSL_G997_PROFILES_12A; break;
         case DSL_PROFILE_12B: nProfile = DSL_G997_PROFILES_12B; break;
         case DSL_PROFILE_17A:
         case DSL_PROFILE_17B: nProfile = DSL_G997_PROFILES_17A; break;
         case DSL_PROFILE_30A: nProfile = DSL_G997_PROFILES_30A; break;
         default:
         {
            errorCode = DSL_ERROR;
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_CalculateMemPortions unknown profile: %d!"
               DSL_CRLF, nLine, errorCode));
            return errorCode;
         }
      }
   }
   else
   {
      /* EAPS2 state 'retrain' or 'finished' - values already calculated */
      return errorCode;
   }

   nMemPortion = DSL_INT8_GET(DSL_DBL_EAPS2_DS_MEM_PORTION);

   if ( nMemPortion == -1 )
   {
      errorCode = DSL_AVX_Eaps2CalculateDsMemPortions( pContext, nLine, nProfile,
            &nDsMemPortionIfec, &nDsMemPortionRtx, &nDsMemPortionRtxDsUs);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2CalculateDsMemPortions failed: %d!" DSL_CRLF,
             nLine, errorCode));
         return errorCode;
      }

      DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION, nDsMemPortionRtx);
      DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION, nDsMemPortionRtxDsUs);
      DSL_UINT16_SET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION, nDsMemPortionIfec);
   }
   else if (( nMemPortion >= 0 ) && ( nMemPortion <= 100 ))
   {
      DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION, (DSL_int16_t)nMemPortion);
      DSL_UINT16_SET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION, (DSL_int16_t)nMemPortion);
      DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION, (DSL_int16_t)nMemPortion);
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OnApsLineStatusInitGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtApsLineStatusInitGet_t * const pAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   AVX_ApsLineInitStatus_t *pSt = &pAck->tApsLineStatusInit;
   static const DSL_uint8_t nChannel = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_OnApsLineStatusInitGet:" DSL_CRLF
      "\tNewProfile = %d" DSL_CRLF 
      "\tMaxToneDs = %d" DSL_CRLF
      "\tMaxToneUs = %d" DSL_CRLF 
      "\tKl0EstimO = %d" DSL_CRLF
      "\tLatnPbUs[5] = %d %d %d %d %d" DSL_CRLF
      "\tMaxToneDsAps = %d" DSL_CRLF, nLine,
      pSt->NewProfile, pSt->MaxToneDs, pSt->MaxToneUs, pSt->Kl0EstimO,
      pSt->LatnPbUs[0], pSt->LatnPbUs[1], pSt->LatnPbUs[2], pSt->LatnPbUs[3],
      pSt->LatnPbUs[4],
      pSt->MaxToneDsAps));

   if (pSt->NewProfile != AVX_APS_ADSL_MODE)
   {
      /* Store current profile internally */
      DSL_UINT8_SET(DSL_DBS_EAPS2_D2_CHECK_PROFILE,
            (DSL_uint8_t)0x1 << (pSt->NewProfile - 1));

      if ((pSt->NewProfile == AVX_VDSL_PROFILE_12A) ||
          (pSt->NewProfile == AVX_VDSL_PROFILE_12B) ||
          (pSt->NewProfile == AVX_VDSL_PROFILE_17A) ||
          (pSt->NewProfile == AVX_VDSL_PROFILE_30A))
      {
         DSL_UINT16_SET(DSL_DBS_MAX_TONE_DS, pSt->MaxToneDs);
         DSL_UINT16_SET(DSL_DBS_MAX_TONE_US, pSt->MaxToneUs);
      }
   }
   else
      /* empty profile means ADSL */
      DSL_UINT8_SET(DSL_DBS_EAPS2_D2_CHECK_PROFILE, 0);

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OnPsdWarningGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtPsdWarningGet_t * const pAck)
{
   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_OnPsdWarningGet: WarnReason = %04X" DSL_CRLF, nLine, pAck->WarnReason));

   if (pContext->pEventCallback != DSL_NULL)
   {
      if ( pAck->WarnReason & AVX_PSD_EVT_UPBO_MASK )
      {
         DSL_CB_DATA_PsdWarning_t nCbData;

         nCbData.nWarningMask = 0;
         nCbData.nWarningMask |= DSL_PSD_WARN_UPBO;

         (void)(pContext->pEventCallback)( (DSL_void_t *)pContext,
                                     nLine,
                                     DSL_CHANNEL_NA,
                                     DSL_ACCESSDIR_NA,
                                     DSL_ATUDIR_NA,
                                     DSL_CBS_PSD_WARNING,
                                     (DSL_CB_DATA_Union_t *)&nCbData );
      }
   }

   return errorCode;
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2ProfilePhysMemCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_uint32_t *pPhysMem)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_uint32_t nMaxDelayOctet_ext_O, nMaxDelayOctet_ext_R = 0, 
                nMaxDelayOctet_ext_R_min, nMaxDelayOctet_ext_R_max;
   DSL_uint8_t nRtxExtMemory = 0, nRtxOptions = 0;

   DSL_CHECK_POINTER(pContext, pPhysMem);

   *pPhysMem = 0;
   if (nProfile == DSL_G997_PROFILES_30A)
   {
      *pPhysMem = 64 * 1024;
   }
   else if (nProfile == DSL_G997_PROFILES_17A)
   {
      *pPhysMem = 48 * 1024;
   }
   else if ((nProfile == DSL_G997_PROFILES_12A) ||
            (nProfile == DSL_G997_PROFILES_12B))
   {
      *pPhysMem = 32 * 1024;
   }
   else if ((nProfile == DSL_G997_PROFILES_8A) ||
            (nProfile == DSL_G997_PROFILES_8B) ||
            (nProfile == DSL_G997_PROFILES_8C) ||
            (nProfile == DSL_G997_PROFILES_8D))
   {
      *pPhysMem = 32 * 1024;
   }
   else
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2ProfilePhysMemCalculate: unknown nProfile=%d" DSL_CRLF, nLine, nProfile));
      return errorCode;
   }

   /* check if the line is not in showtime */
   if (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) != DSL_LINESTATUS_SHOWTIME_TC_SYNC)
   {
      /* return default PhysMem */
      return DSL_SUCCESS;
   }
   
   nMaxDelayOctet_ext_R_min = 2 *  16 * 1024; /* will be incremented according to the profile */
   nMaxDelayOctet_ext_R_max = 2 * 256 * 1024;

   if ((DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) == (DSL_uint8_t)DSL_RTX_USED) &&
       (DSL_UINT8_GET(DSL_DBS_RTX_USED_US) == (DSL_uint8_t)DSL_RTX_USED))
   {
      nMaxDelayOctet_ext_O = 2 * 58488;
   }
   else 
   if ((DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) == (DSL_uint8_t)DSL_RTX_USED) &&
       (DSL_UINT8_GET(DSL_DBS_RTX_USED_US) != (DSL_uint8_t)DSL_RTX_USED))
   {
      nMaxDelayOctet_ext_O = 2 * 57532;
   }
   else
   {
      /* return default PhysMem */
      return DSL_SUCCESS;
   }

   nRtxExtMemory = DSL_INT8_GET(DSL_DBL_MFS_RTX_EXTENDED_MEMORY);

   if (nProfile == DSL_G997_PROFILES_30A)
   {
      nMaxDelayOctet_ext_R_min *= 4;
      nMaxDelayOctet_ext_O *= 2;

      if (nRtxExtMemory & 0x02) nRtxOptions |= AVX_8858_EXT_MEM_G9935_ENABLE_MASK;
      if (nRtxExtMemory & 0x08) nRtxOptions |= AVX_8858_EXT_MEM_G9932_ENABLE_MASK;
   }
   else if (nProfile == DSL_G997_PROFILES_17A)
   {
      nMaxDelayOctet_ext_R_min *= 3;

      if (nRtxExtMemory & 0x01) nRtxOptions |= AVX_8858_EXT_MEM_G9935_ENABLE_MASK;
      if (nRtxExtMemory & 0x04) nRtxOptions |= AVX_8858_EXT_MEM_G9932_ENABLE_MASK;
   }
   else
   {
      nMaxDelayOctet_ext_R_min *= 2;

      if (nRtxExtMemory & 0x01) nRtxOptions |= AVX_8858_EXT_MEM_G9935_ENABLE_MASK;
      if (nRtxExtMemory & 0x04) nRtxOptions |= AVX_8858_EXT_MEM_G9932_ENABLE_MASK;
   }

   nMaxDelayOctet_ext_R |= (((DSL_UINT16_GET(DSL_DBS_PMS_TC_RMSG2_OCT_10_11)) & AVX_03E3_PMS_TC_RMSG2_OCT11_MASK) >> 8) << 16;
   nMaxDelayOctet_ext_R |=  ((DSL_UINT16_GET(DSL_DBS_PMS_TC_RMSG2_OCT_12_13)) & AVX_03E3_PMS_TC_RMSG2_OCT12_MASK) << 8;
   nMaxDelayOctet_ext_R |=  ((DSL_UINT16_GET(DSL_DBS_PMS_TC_RMSG2_OCT_12_13)) & AVX_03E3_PMS_TC_RMSG2_OCT13_MASK) >> 8;
   
   /* Check if MAXDELAYOCTET_ext_R is in valid range */
   if ((nMaxDelayOctet_ext_R < nMaxDelayOctet_ext_R_min) || 
       (nMaxDelayOctet_ext_R > nMaxDelayOctet_ext_R_max))
   {
      /* return default PhysMem */
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2ProfilePhysMemCalculate: nMaxDelayOctet_ext_R=%u is not in the valid randge min=%u ... max=%u" DSL_CRLF, nLine, 
         nMaxDelayOctet_ext_R, nMaxDelayOctet_ext_R_min, nMaxDelayOctet_ext_R_max));
      return errorCode;
   }

   /* check if last showtime was in G.993.2 (VDSL2) or in G.993.5 (VDSL2+IVE) opmode */
   if ((DSL_UINT8_GET(DSL_DBS_ATSE_8) && (nRtxOptions & AVX_8858_EXT_MEM_G9932_ENABLE_MASK)) ||
       (DSL_UINT8_GET(DSL_DBS_ATSE_9) && (nRtxOptions & AVX_8858_EXT_MEM_G9935_ENABLE_MASK)))
   {
      *pPhysMem = DSL_MIN(nMaxDelayOctet_ext_R, nMaxDelayOctet_ext_O);
   }

   return errorCode;
}

/* Calculate the actual used Interleaver Memory for a given
   direction and RTX/IFEC mode
   from framing status. */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2ActMemCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t *pActMem)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t    errorCode = DSL_SUCCESS;

   DSL_uint16_t   nN = 0, nq = 0, nD = 0;
   DSL_uint32_t   nDbiD = 0, nDbiN = 0, nDbiq = 0;

   DSL_uint16_t   nR = 0, nH = 0;
   DSL_uint8_t    nQ = 0, nQtx = 0;
   DSL_uint32_t   nDbiQ = 0, nDbiQtx = 0, nDbiR = 0;
   DSL_float_t    fTdmt = 0.0, fFs = 0.0;

   DSL_CHECK_POINTER(pContext, pActMem);

   *pActMem = 0;

   if ( bRtxUsed == DSL_TRUE )
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiR   = DSL_DBS_FRAMING_RP_DS;
         nDbiN   = DSL_DBS_FRAMING_NFEC_DS;
         nDbiQ   = DSL_DBS_FRAMING_RETX_Q_DS;
         nDbiQtx = DSL_DBS_FRAMING_RETX_QTX_DS;
      }
      else
      {
         nDbiR   = DSL_DBS_FRAMING_RP_US;
         nDbiN   = DSL_DBS_FRAMING_NFEC_US;
         nDbiQ   = DSL_DBS_FRAMING_RETX_Q_US;
         nDbiQtx = DSL_DBS_FRAMING_RETX_QTX_US;
      }

      nR   = DSL_UINT16_GET(nDbiR);
      nN   = DSL_UINT16_GET(nDbiN);
      nQ   = DSL_UINT8_GET(nDbiQ);
      nQtx = DSL_UINT8_GET(nDbiQtx);

      nH = nN - nR;
      *pActMem = (DSL_uint32_t)(nQtx * nQ * nH);
   }
   else
   {
      if (nProfile == DSL_G997_PROFILES_30A)
      {
         /* set Tdmt and fs for the VDSL profile 30a */
         fFs = 8.0 * 256.0/257.0;
         fTdmt = 0.125;
      }
      else if (nProfile == 0)
      {
         /* set Tdmt and fs for the ADSL profile */
         fFs = 4.0;
         fTdmt = 0.25 * 68.0/69.0;
      }
      else
      {
         /* set Tdmt and fs for the rest VDSL profiles */
         fFs = 4.0 * 256.0/257.0;
         fTdmt = 0.25;
      }

      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiD = DSL_DBS_FRAMING_DP_DS;
         nDbiN = DSL_DBS_FRAMING_NFEC_DS;
         nDbiq = DSL_DBS_FRAMING_QP_DS;
      }
      else
      {
         nDbiD = DSL_DBS_FRAMING_DP_US;
         nDbiN = DSL_DBS_FRAMING_NFEC_US;
         nDbiq = DSL_DBS_FRAMING_QP_US;
      }

      nN = DSL_UINT16_GET(nDbiN);
      nq = DSL_UINT16_GET(nDbiq);
      nD = DSL_UINT16_GET(nDbiD);

      if ( nq > 0 )
      {
         *pActMem = ceil(0.5 * (nN/(DSL_float_t)nq - 1.0)*(nD - 1.0) * fTdmt * fFs);
      }
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2ActMemCalculate(%s,%s,0x%02X): %d" DSL_CRLF, nLine, 
      (nDirection ? "DS" : "US"),
      (bRtxUsed ? "RTX" : "IFEC"),
      nProfile,
      *pActMem));

   return errorCode;
}

/* Calculate Attainable LineRate for the next profile according
   "IV) Additional retrain when reaching showtime with profile switch and with new memory split " */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2AttNdrNextProfileCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_uint32_t *pAttNdr)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t    errorCode = DSL_SUCCESS;

   DSL_int_t      nLineRate = 0, nLrNext = 0;
   DSL_uint32_t   nActLr = 0, nAttNdr = 0, nActNdr = 0;
   DSL_G997_NSCData8_t *pNextBat;

   DSL_CHECK_POINTER(pContext, pAttNdr);

   *pAttNdr = 0;

   nAttNdr = DSL_UINT32_GET(DSL_DBS_ATTNDR_DS) / 1000;
   nActLr = DSL_UINT32_GET(DSL_DBS_ACTLINERATE_DS) / 1000;
   nActNdr  = DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_DS)/1000;
   if (nAttNdr < nActNdr)
   {
      nAttNdr = nActNdr;
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2AttNdrNextProfileCalculate: "
         "no AttNdr, set AttNdr = nActNdr = %d" DSL_CRLF,
         nLine, nActNdr));
   }

   /* LineRateNext =  ActualLineRate + DeltaLineRate + DeltaLineRatePlus */
   nLrNext = nActLr;
   errorCode = DSL_AVX_Eaps2DeltaLineRateCalculate(pContext, nLine, 
      pBat, nFromProfile, nNextProfile, &nLineRate);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRateCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }
   nLrNext += nLineRate;

   /* dLRplus must be derived from pNextBat */
   pNextBat = (DSL_G997_NSCData8_t *) DSL_Malloc(sizeof(DSL_G997_NSCData8_t));
   if (pNextBat == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_Malloc(%d) failed!" DSL_CRLF, nLine, 
         (DSL_int_t)sizeof(DSL_G997_NSCData8_t)));
      return DSL_ERROR;
   }
   errorCode = DSL_AVX_Eaps2BatApproximate(pContext, nLine, nFromProfile, nNextProfile, pBat, pNextBat);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pNextBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2BatApproximate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(pContext, nLine, 
      pNextBat, nFromProfile, nFromProfile, nNextProfile, &nLineRate);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pNextBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }
   nLrNext += nLineRate;

   /* pAttNdr for DSL_UPSTREAM will be the same as for DSL_DOWNSTREAM */
   if ( nActLr > 0 )
   {
      *pAttNdr = ( nLrNext / (DSL_float_t)nActLr) * nAttNdr  ;
   }

   DSL_Free(pNextBat);
   return errorCode;
}

/* Calculate the minimum data rate relevant for the MDO split 
   for a given
   direction, profile and RTX/IFEC mode
   derived from configuration data only. */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MinMemRateConfigCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t *pMinMemRate)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t       errorCode = DSL_SUCCESS;

   DSL_uint32_t      nMinRate = 0;
   DSL_uint16_t      nMaxDelay = 0;
   DSL_uint8_t       nMinInp = 0, nShineRatio = 0;
   DSL_uint32_t      nDbiMinRate = 0, nDbiMaxDelay = 0, nDbiMinInp = 0, nDbiShineRatio = 0;

   DSL_float_t       fp = 0.0, fOH = 0.0;

   DSL_CHECK_POINTER(pContext, pMinMemRate);

   *pMinMemRate = 0;

   if ( bRtxUsed == DSL_TRUE )
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMinRate    = DSL_DBC_RETX_MINETR_DS;
         nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_DS;
         if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
         {
            nDbiMinInp     = DSL_DBC_RETX_INPMIN8_REIN_DS;
         }
         else
         {
            nDbiMinInp     = DSL_DBC_RETX_INPMIN_REIN_DS;
         }
      }
      else
      {
         nDbiMinRate    = DSL_DBC_RETX_MINETR_US;
         nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_US;
         if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
         {
            nDbiMinInp     = DSL_DBC_RETX_INPMIN8_REIN_US;
         }
         else
         {
            nDbiMinInp     = DSL_DBC_RETX_INPMIN_REIN_US;
         }
      }

      nMinRate          = DSL_UINT32_GET(nDbiMinRate)/1000;
      nShineRatio       = DSL_UINT8_GET(nDbiShineRatio);
      nMinInp           = DSL_UINT8_GET(nDbiMinInp);

      fp = (nProfile == DSL_G997_PROFILES_30A)?0.125:0.25;
      fOH = nShineRatio / 1000.0 + ( nMinInp * fp )/ 8.0;
   }
   else
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMinRate    = DSL_DBC_MIN_DATARATE_DS;
         nDbiMaxDelay   = DSL_DBC_MAX_I_DELAY_DS;
         nDbiMinInp     = DSL_DBC_MIN_INP_DS;
      }
      else
      {
         nDbiMinRate    = DSL_DBC_MIN_DATARATE_US;
         nDbiMaxDelay   = DSL_DBC_MAX_I_DELAY_US;
         nDbiMinInp     = DSL_DBC_MIN_INP_US;
      }

      nMinRate          = DSL_UINT32_GET(nDbiMinRate)/1000;
      nMaxDelay         = DSL_UINT16_GET(nDbiMaxDelay);
      nMinInp           = DSL_UINT8_GET(nDbiMinInp)/2;

      fp = (nProfile == DSL_G997_PROFILES_30A)?1.0:0.5;

      if ( nMaxDelay == 0 ) nMaxDelay = 64;
      fOH = ( fp * nMinInp ) / nMaxDelay;
   }

   if ( fOH < 1.0 )
   {
      *pMinMemRate = (DSL_uint32_t)(nMinRate / ( 1.0 - fOH ));
   }
   else
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2MinMemRateConfigCalculate: "
         "empty MinMemRate %d due to OH = %f < 1" DSL_CRLF, 
         nLine, *pMinMemRate, fOH));

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MinMemConfigCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t *pMinMem)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t       errorCode = DSL_SUCCESS;

   DSL_uint32_t      nMinEtr = 0, nMinRate = 0;
   DSL_uint16_t      nMaxDelay = 0;
   DSL_uint8_t       nShineRatio = 0, nMinInp = 0;

   DSL_uint32_t      nDbiMinEtr = 0, nDbiShineRatio = 0,
                     nDbiMinRate = 0, nDbiMaxDelay = 0, nDbiMinInp = 0;

   DSL_uint32_t      nMinMemRate = 0;
   DSL_float_t       fp = 0.0, fOH = 0.0;

   DSL_CHECK_POINTER(pContext, pMinMem);

   *pMinMem = 0;

   if ( bRtxUsed == DSL_TRUE )
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMinEtr     = DSL_DBC_RETX_MINETR_DS;
         nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_DS;
         if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
         {
            nDbiMinInp     = DSL_DBC_RETX_INPMIN8_REIN_DS;
         }
         else
         {
            nDbiMinInp     = DSL_DBC_RETX_INPMIN_REIN_DS;
         }
      }
      else
      {
         nDbiMinEtr     = DSL_DBC_RETX_MINETR_US;
         nDbiShineRatio = DSL_DBC_RETX_SHINERATIO_US;
         if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
         {
            nDbiMinInp     = DSL_DBC_RETX_INPMIN8_REIN_US;
         }
         else
         {
            nDbiMinInp     = DSL_DBC_RETX_INPMIN_REIN_US;
         }
      }

      nMinEtr           = DSL_UINT32_GET(nDbiMinEtr)/1000;
      nShineRatio       = DSL_UINT8_GET(nDbiShineRatio);
      nMinInp           = DSL_UINT8_GET(nDbiMinInp);

      fp = (nProfile == DSL_G997_PROFILES_30A)?0.125:0.25;
      fOH = nShineRatio / 1000.0 + nMinInp * fp / 8.0;

      if ( fOH < 1.0 )
      {
         nMinMemRate = (DSL_uint32_t)( nMinEtr / ( 1.0 - fOH ));
      }

      *pMinMem = ceil(nMinMemRate * 5 / 8);
   }
   else
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMinRate    = DSL_DBC_MIN_DATARATE_DS;
         nDbiMaxDelay   = DSL_DBC_MAX_I_DELAY_DS;
         nDbiMinInp     = DSL_DBC_MIN_INP_DS;
      }
      else
      {
         nDbiMinRate    = DSL_DBC_MIN_DATARATE_US;
         nDbiMaxDelay   = DSL_DBC_MAX_I_DELAY_US;
         nDbiMinInp     = DSL_DBC_MIN_INP_US;
      }

      nMinRate          = DSL_UINT32_GET(nDbiMinRate)/1000;
      nMaxDelay         = DSL_UINT16_GET(nDbiMaxDelay);
      nMinInp           = DSL_UINT8_GET(nDbiMinInp)/2;

      fp = (nProfile == DSL_G997_PROFILES_30A)?1.0:0.5;

      if ( nMaxDelay == 0 ) nMaxDelay = 64;
      if ( nMaxDelay == 255 ) nMaxDelay = 1;
      fOH = ( fp *  nMinInp ) / nMaxDelay;

      if ( fOH < 1.0 )
      {
         nMinMemRate = nMinRate / ( 1.0 - fOH );
      }

      *pMinMem = ceil(( nMinMemRate * nMaxDelay ) / (2 * 8));
   }

   return errorCode;
}

/* Calculate the minimum required interleaver memory for a given
   direction, RTX/IFEC mode and available memory
   derived from configuration and current showtime status. */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MinMemCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t nActMem,
   DSL_uint32_t *pMinMem)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t       errorCode = DSL_SUCCESS;

   DSL_uint32_t      nMinRate = 0, nActNdr = 0, nActEtru = 0;
   DSL_uint32_t      nDbiMinRate = 0, nDbiActNdr = 0, nDbiActEtru = 0;

   DSL_CHECK_POINTER(pContext, pMinMem);

   *pMinMem = 0;

   if ( bRtxUsed == DSL_TRUE )
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMinRate  = DSL_DBC_RETX_MINETR_DS;
         nDbiActEtru  = DSL_DBSC_RETX_ATTETRU_DS;
      }
      else
      {
         nDbiMinRate  = DSL_DBC_RETX_MINETR_US;
         nDbiActEtru  = DSL_DBSC_RETX_ATTETRU_US;
      }

      nMinRate = DSL_UINT32_GET(nDbiMinRate)/1000;
      nActEtru = DSL_UINT32_GET(nDbiActEtru)/1000;

      if ( nActEtru > 0 )
      {
         *pMinMem = ceil(( nMinRate * nActMem ) / nActEtru);
      }
      else
         DSL_DEBUG(DSL_DBG_WRN, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2MinMemCalculate: no ActEtru, MinMem = %d" DSL_CRLF, 
            nLine, *pMinMem));
   }
   else
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMinRate = DSL_DBC_MIN_DATARATE_DS;
         nDbiActNdr  = DSL_DBSC_ACT_DATARATE_DS;
      }
      else
      {
         nDbiMinRate = DSL_DBC_MIN_DATARATE_US;
         nDbiActNdr  = DSL_DBSC_ACT_DATARATE_US;
      }

      nMinRate = DSL_UINT32_GET(nDbiMinRate)/1000;
      nActNdr  = DSL_UINT32_GET(nDbiActNdr)/1000;

      if ( nActNdr > 0 )
      {
         *pMinMem = ceil(( nMinRate * nActMem ) / nActNdr );
      }
      else
         DSL_DEBUG(DSL_DBG_WRN, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2MinMemCalculate: no ActNdr, MinMem = %d" DSL_CRLF, 
            nLine, *pMinMem));
}

   return errorCode;
}

/* Calculate the maximum required interleaver memory for a given
   direction, profile and RTX/IFEC mode 
   derived from configuration data only. */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MaxMemConfigCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t *pMaxMem)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t       errorCode = DSL_SUCCESS;

   DSL_uint32_t      nMaxRate = 0;
   DSL_uint16_t      nMaxDelay = 0;
   DSL_uint8_t       nMinInp = 0;

   DSL_uint32_t      nDbiMaxRate = 0, nDbiMaxDelay = 0, nDbiMinInp = 0;

   DSL_uint32_t      nMaxMemRate = 0;
   DSL_float_t       fp = 0.0, fOH = 0.0;

   DSL_CHECK_POINTER(pContext, pMaxMem);

   *pMaxMem = 0;

   if ( bRtxUsed == DSL_TRUE )
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMaxRate = DSL_DBC_RETX_MAXETR_DS;
      }
      else
      {
         nDbiMaxRate = DSL_DBC_RETX_MAXETR_US;
      }

      nMaxRate = DSL_UINT32_GET(nDbiMaxRate)/1000;

      fOH = 0.0;
      nMaxMemRate = (DSL_uint32_t)(nMaxRate / ( 1.0 - fOH ));

      *pMaxMem = ceil(nMaxMemRate * 5 / 8);
   }
   else
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMaxRate    = DSL_DBC_MAX_DATARATE_DS;
         nDbiMaxDelay   = DSL_DBC_MAX_I_DELAY_DS;
         nDbiMinInp     = DSL_DBC_MIN_INP_DS;
      }
      else
      {
         nDbiMaxRate    = DSL_DBC_MAX_DATARATE_US;
         nDbiMaxDelay   = DSL_DBC_MAX_I_DELAY_US;
         nDbiMinInp     = DSL_DBC_MIN_INP_US;
      }

      nMaxRate          = DSL_UINT32_GET(nDbiMaxRate)/1000;
      nMaxDelay         = DSL_UINT16_GET(nDbiMaxDelay);
      nMinInp           = DSL_UINT8_GET(nDbiMinInp)/2;

      fp = (nProfile == DSL_G997_PROFILES_30A)?1.0:0.5;

      if ( nMaxDelay == 0 ) 
         nMaxDelay = 64;
      fOH = fp * nMinInp / nMaxDelay;

      if ( fOH < 1.0 )
      {
         nMaxMemRate = (DSL_uint32_t)(nMaxRate / ( 1.0 - fOH ));
      }

      *pMaxMem = ceil(( nMaxMemRate * nMaxDelay ) / (2 * 8));
   }

   return errorCode;
}

/* Calculate the maximum required interleaver memory for a given
   direction, RTX/IFEC mode and available memory
   derived from configuration and current showtime status. */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MaxMemCurrentProfileCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t nActMem,
   DSL_uint32_t *pMaxMem)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t       errorCode = DSL_SUCCESS;

   DSL_uint32_t      nMaxRate = 0, nActNdr = 0, nAttNdr = 0;
   DSL_uint32_t      nDbiMaxRate = 0, nDbiActNdr = 0, nDbiAttNdr = 0;

   DSL_float_t       fSraFactor = 0.0;

   DSL_CHECK_POINTER(pContext, pMaxMem);

   *pMaxMem = 0;

   fSraFactor = DSL_UINT8_GET(DSL_DBL_MEMSPLIT_SRA_FACTOR)/100.0;
   fSraFactor += 1.0;

   if ( bRtxUsed == DSL_TRUE )
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMaxRate  = DSL_DBC_RETX_MAXNDR_DS;
         nDbiActNdr   = DSL_DBSC_RETX_ACTNDR_DS;
         nDbiAttNdr   = DSL_DBS_ATTNDR_DS;
      }
      else
      {
         nDbiMaxRate  = DSL_DBC_RETX_MAXNDR_US;
         nDbiActNdr   = DSL_DBSC_RETX_ACTNDR_US;
         nDbiAttNdr   = DSL_DBS_ATTNDR_US;
      }
   }
   else
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMaxRate = DSL_DBC_MAX_DATARATE_DS;
         nDbiActNdr  = DSL_DBSC_ACT_DATARATE_DS;
         nDbiAttNdr  = DSL_DBS_ATTNDR_DS;
      }
      else
      {
         nDbiMaxRate = DSL_DBC_MAX_DATARATE_US;
         nDbiActNdr  = DSL_DBSC_ACT_DATARATE_US;
         nDbiAttNdr  = DSL_DBS_ATTNDR_US;
      }
   }

   nMaxRate = DSL_UINT32_GET(nDbiMaxRate)/1000;
   nActNdr  = DSL_UINT32_GET(nDbiActNdr)/1000;
   nAttNdr  = DSL_UINT32_GET(nDbiAttNdr)/1000;

   /* if FE AttNdr is not available yet or wrong, assume ActNDR, ActNdr <= AttNdr */
   if ((nAttNdr == 0) || (nAttNdr < nActNdr))
   {
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2MaxMemCurrentProfileCalculate: "
         "unexpected AttNdr=%d, set AttNdr=nActNdr=%d" DSL_CRLF, 
         nLine, nAttNdr, nActNdr));
      nAttNdr = nActNdr;
   }

   if ( nActNdr && nAttNdr)
      *pMaxMem = ceil(( DSL_MIN( nMaxRate, nAttNdr * fSraFactor ) * nActMem ) / nActNdr);
   else
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2MaxMemCurrentProfileCalculate: "
         "no ActNdr or AttNdr, MaxMem = %d" DSL_CRLF, 
         nLine, *pMaxMem));

   return errorCode;
}

/* Calculate the maximum required interleaver memory for a given
   direction, next profile, RTX/IFEC mode and available memory
   derived from configuration and current showtime status. */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2MaxMemNextProfileCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_boolean_t bRtxUsed,
   DSL_uint32_t nActMem,
   DSL_uint32_t *pMaxMem)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t       errorCode = DSL_SUCCESS;

   DSL_uint32_t      nMaxRate = 0, nActNdr = 0, nAttNdr = 0;
   DSL_uint32_t      nDbiMaxRate = 0, nDbiActNdr = 0;

   DSL_float_t       fSraFactor = 0.0;

   DSL_CHECK_POINTER(pContext, pMaxMem);

   *pMaxMem = 0;

   fSraFactor = DSL_UINT8_GET(DSL_DBL_MEMSPLIT_SRA_FACTOR)/100.0;
   fSraFactor += 1.0;

   if ( bRtxUsed == DSL_TRUE )
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMaxRate  = DSL_DBC_RETX_MAXNDR_DS;
         nDbiActNdr   = DSL_DBSC_RETX_ACTNDR_DS;
      }
      else
      {
         nDbiMaxRate  = DSL_DBC_RETX_MAXNDR_US;
         nDbiActNdr   = DSL_DBSC_RETX_ACTNDR_US;
      }
   }
   else
   {
      if ( nDirection == DSL_DOWNSTREAM )
      {
         nDbiMaxRate = DSL_DBC_MAX_DATARATE_DS;
         nDbiActNdr  = DSL_DBSC_ACT_DATARATE_DS;
      }
      else
      {
         nDbiMaxRate = DSL_DBC_MAX_DATARATE_US;
         nDbiActNdr  = DSL_DBSC_ACT_DATARATE_US;
      }
   }

   nMaxRate = DSL_UINT32_GET(nDbiMaxRate)/1000;
   nActNdr  = DSL_UINT32_GET(nDbiActNdr)/1000;

   errorCode = DSL_AVX_Eaps2AttNdrNextProfileCalculate(pContext, nLine, 
                  pBat, nFromProfile, nNextProfile, &nAttNdr);
   if (errorCode != DSL_SUCCESS)
   {
      return errorCode;
   }

   /* if AttNdr is not available yet, assume ActNDR, ActNdr <= AttNdr */
   if (nAttNdr == 0)
   {
      nAttNdr = nActNdr;
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2MaxMemNextProfileCalculate: "
         "no AttNdr, set AttNdr = nActNdr = %d" DSL_CRLF,
         nLine, nActNdr));
   }
   
   if ( nActNdr && nAttNdr )
   {
      *pMaxMem = ceil(( DSL_MIN(nMaxRate, nAttNdr * fSraFactor) * nActMem ) / nActNdr);
   }
   else
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2MaxMemNextProfileCalculate: "
         "no ActNdr or AttNdr, MaxMem = %d" DSL_CRLF, 
         nLine, *pMaxMem));

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DeltaLineRateCappedCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_int_t nLineRate,
   DSL_uint32_t *pLineRateCapped)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint32_t nMaxRate = 0, nActLineRate = 0, nTotalDataRate = 0;
   DSL_uint16_t nR = 0, nN = 0;
   DSL_float_t fLrFactor = 1.01, fRsOverhead = 0.0, fTrellisOverhead = 0.0;

   DSL_CHECK_POINTER(pContext, pLineRateCapped);

   *pLineRateCapped = 0;

   nActLineRate = DSL_UINT32_GET(DSL_DBS_ACTLINERATE_DS)/1000;
   nTotalDataRate = DSL_UINT32_GET(DSL_DBSC_TOTAL_DATARATE_DS)/1000;
   nMaxRate = DSL_UINT32_GET(DSL_DBC_MAX_DATARATE_DS)/1000;

   nR = DSL_UINT16_GET(DSL_DBS_FRAMING_RP_DS);
   nN = DSL_UINT16_GET(DSL_DBS_FRAMING_NFEC_DS);

   if ( nN > 0 )
   {
      fRsOverhead = nR / (DSL_float_t)nN;
   }

   if ( nActLineRate > 0 )
   {
      fTrellisOverhead = (1.0 - nTotalDataRate / (DSL_float_t)nActLineRate);
   }

   *pLineRateCapped = DSL_MIN(nLineRate, nMaxRate * (1 + fRsOverhead) * (1 + fTrellisOverhead) * fLrFactor);
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRateCappedCalculate: %d!" DSL_CRLF, nLine, *pLineRateCapped));

   return (errorCode);
}

/* Calculates a retrain decision for a fixed MDOSPLIT config
   from VDSL showtime to a different VDSL profile.
   This corresponds to ApsMemPartitioning spec case I. */ 
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2FixedItlvPartConfigVdslCheck(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pNextBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_boolean_t bRtxUsed,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t    errorCode = DSL_SUCCESS;
   DSL_int8_t     nMemPortion = -1;
   DSL_int_t      nLineRate = 0;
   DSL_uint32_t   nLineRateCapped = 0, nActNdrUs = 0, nActNdrDs = 0, nPhysMemY = 0,
                  nActMemUs = 0, nActMemDs = 0, nMinMemRateUs = 0;
   DSL_float_t    fMarginFactor = 1.01;

   DSL_CHECK_POINTER(pContext, bRetrain);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2FixedItlvPartConfigVdslCheck(Profile %d->%d, bRtx=%d)" DSL_CRLF, 
      nLine, nFromProfile, nNextProfile, bRtxUsed));

   *bRetrain = DSL_TRUE;

   nActNdrUs = DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_US)/1000;
   nActNdrDs = DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_DS)/1000;
   nMemPortion = DSL_INT8_GET(DSL_DBL_EAPS2_DS_MEM_PORTION);

   errorCode = DSL_AVX_Eaps2ProfilePhysMemCalculate(pContext, nLine, nNextProfile, &nPhysMemY);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2ProfilePhysMemCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(pContext, nLine, 
                  pNextBat, nFromProfile, nFromProfile, nNextProfile, &nLineRate);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRateCappedCalculate(pContext, nLine, nLineRate, &nLineRateCapped);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRateCappedCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2ActMemCalculate(pContext, nLine, DSL_UPSTREAM, nFromProfile, bRtxUsed, &nActMemUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2ActMemCalculate for UPSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2ActMemCalculate(pContext, nLine, DSL_DOWNSTREAM, nFromProfile, bRtxUsed, &nActMemDs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2ActMemCalculate for DOWNSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MinMemRateConfigCalculate(pContext, nLine, DSL_UPSTREAM, nFromProfile, bRtxUsed, &nMinMemRateUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2MinMemRateConfigCalculate for DOWNSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (( nActNdrUs == 0 ) || ( nActNdrDs == 0 ))
   {
      return (errorCode);
   }

   if ((floor(nPhysMemY * nMemPortion) <= ((nActMemDs * nLineRateCapped * fMarginFactor) / nActNdrDs)) ||
       (nPhysMemY - floor(nPhysMemY * nMemPortion)) <= (( nActMemUs * nMinMemRateUs )/ nActNdrUs))
   {
      *bRetrain = DSL_FALSE;
   }
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2FixedItlvPartConfigVdslCheck out: bRetrain=%d" DSL_CRLF, 
      nLine, *bRetrain));

   return (errorCode);
}

#define DSL_APS_MEM_DS_ADSL2P_WEXTFRM     (24000/2)
#define DSL_APS_MEM_DS_ADSL2P_WOEXTFRM    ((254/2)*63)
#define DSL_APS_MEM_US_ADSL2P2            ((254/2)*7)

/* Calculates a retrain decision for a fixed MDOSPLIT config
   from VDSL showtime to ADSL.
   This corresponds to ApsMemPartitioning spec case I. */ 
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2FixedItlvPartConfigAdslCheck(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_G997_NSCData8_t *pBat,
   DSL_boolean_t bRtxUsed,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t    errorCode = DSL_SUCCESS;
   DSL_int_t      nLineRate = 0;
   DSL_uint32_t   nLineRateCapped = 0, nActNdrUs = 0, nActNdrDs = 0,
                  nActMemUs = 0, nActMemDs = 0, nMinMemRateUs = 0;
   DSL_float_t    fMarginFactor = 1.01;

   DSL_CHECK_POINTER(pContext, bRetrain);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2FixedItlvPartConfigAdslCheck(profile=%d, bRtx=%d)" DSL_CRLF, 
      nLine, nProfile, bRtxUsed));

   *bRetrain = DSL_TRUE;

   nActNdrUs = DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_US)/1000;
   nActNdrDs = DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_DS)/1000;

   /* FIXME: nLineRate shall be full estimated rate of next config, but 
      DSL_AVX_Eaps2AttNdrNextProfileCalculate doesn't support ADSLx as next profile.
      pBat passed must be pNextBat if DSL_AVX_Eaps2DeltaLineRatePlusCalculate is used.      */
   /* set next profile as any !eq to DSL_G997_PROFILES_30A */
   errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(pContext, nLine, pBat, 
                  nProfile, nProfile, DSL_G997_PROFILES_17A, &nLineRate);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRateCappedCalculate(pContext, nLine, nLineRate, &nLineRateCapped);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRateCappedCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2ActMemCalculate(pContext, nLine, DSL_UPSTREAM, nProfile, bRtxUsed, &nActMemUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2ActMemCalculate for UPSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2ActMemCalculate(pContext, nLine, DSL_DOWNSTREAM, nProfile, bRtxUsed, &nActMemDs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2ActMemCalculate for DOWNSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   /* for the Adsl2+ use non DSL_G997_PROFILES_30A profile */
   errorCode = DSL_AVX_Eaps2MinMemRateConfigCalculate(pContext, nLine, DSL_UPSTREAM, DSL_G997_PROFILES_17A, bRtxUsed, &nMinMemRateUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2MinMemRateConfigCalculate for DOWNSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (( nActNdrUs == 0 ) || ( nActNdrDs == 0 ))
   {
      return (errorCode);
   }

   if ((DSL_APS_MEM_DS_ADSL2P_WEXTFRM <= (( nActMemDs * nLineRateCapped * fMarginFactor ) / nActNdrUs)) ||
       (DSL_APS_MEM_US_ADSL2P2 <= (( nActMemUs * nMinMemRateUs ) / nActNdrUs )))
   {
      *bRetrain = DSL_FALSE;
   }
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]DSL_AVX_Eaps2FixedItlvPartConfigAdslCheck - out: bRetrain=%d" DSL_CRLF, nLine, *bRetrain));

   return (errorCode);
}

/* Calculate the DS Interleaver Memory portion for a given
   profile and RTX usage
   from configuration data only. */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DynamicItlvPartConfigCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsedDs,
   DSL_boolean_t bRtxUsedUs,
   DSL_uint32_t *pMemPortion)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t    errorCode = DSL_SUCCESS;
   DSL_uint32_t   nAddDs1 = 0, nMemUs1 = 0, nMemDs1 = 0,
                  nAddUs2 = 0, nMemUs2 = 0, nMemDs2 = 0,
                  nMinMemUs = 0, nMinMemDs = 0, nMaxMemUs = 0, nMaxMemDs = 0,
                  nPhysMem = 0, nMinMemSum = 0;
   DSL_float_t    fDsWeight = 0.0;

   DSL_CHECK_POINTER(pContext, pMemPortion);

   *pMemPortion = 0;

   fDsWeight = DSL_UINT8_GET(DSL_DBL_MEMSPLIT_DS_WEIGHT)/100.0;

   errorCode = DSL_AVX_Eaps2ProfilePhysMemCalculate(pContext, 
                  nLine, nProfile, &nPhysMem);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2ProfilePhysMemCalculate failed: %d" DSL_CRLF, 
         nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MinMemConfigCalculate(pContext, nLine, DSL_UPSTREAM, 
                  nProfile, bRtxUsedUs, &nMinMemUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2MinMemConfigCalculate for UPSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MinMemConfigCalculate(pContext, nLine, DSL_DOWNSTREAM, 
                  nProfile, bRtxUsedDs, &nMinMemDs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MinMemConfigCalculate for DOWNSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   nMinMemSum = nMinMemUs + nMinMemDs;

   if (nMinMemSum >= nPhysMem)
   {
      *pMemPortion = ceil(100 * nMinMemDs / nMinMemSum);
   }
   else
   {
      nAddDs1 = (DSL_uint32_t)(ceil(nPhysMem - nMinMemSum) * fDsWeight);
      nMemDs1 = nMinMemDs + nAddDs1;
      nMemUs1 = nPhysMem - nMemDs1;

      errorCode = DSL_AVX_Eaps2MaxMemConfigCalculate(pContext, nLine, DSL_UPSTREAM, 
                     nProfile, bRtxUsedUs, &nMaxMemUs);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext, 
            "DSL[%02d]: DSL_AVX_Eaps2MaxMemConfigCalculate for UPSTREAM failed: %d!" 
            DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      errorCode = DSL_AVX_Eaps2MaxMemConfigCalculate(pContext, nLine, DSL_DOWNSTREAM, 
                     nProfile, bRtxUsedDs, &nMaxMemDs);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext, 
            "DSL[%02d]: DSL_AVX_Eaps2MaxMemConfigCalculate for DOWNSTREAM failed: %d!" 
            DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      if ( nMemDs1 > nMaxMemDs ) nAddUs2 = nMemDs1 - nMaxMemDs;
      nMemUs2 = nMemUs1 + nAddUs2;
      nMemDs2 = nPhysMem - nMemUs2;

      *pMemPortion = ceil(( nMemDs2 * 100 ) / nPhysMem );
   }

   if ( *pMemPortion > 100 )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartConfigCalculate: calculated values of "
         "memory portions RTX/IFEC (%u) are not in the range of 0...100!" DSL_CRLF,
            nLine, *pMemPortion));

      return DSL_ERR_MEM_PARTITION_INFEASIBLE;
   }

   if ( *pMemPortion < 5 )
   {
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartConfigCalculate: limit the MemPortion %d %% to the lower bound 5 %%!"
         DSL_CRLF, nLine, *pMemPortion));

      *pMemPortion = 5;
   }

   if ( *pMemPortion > 95 )
   {
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartConfigCalculate: limit the MemPortion %d %% to the upper bound 95%%!"
         DSL_CRLF, nLine, *pMemPortion));

      *pMemPortion = 95;
   }

   return (errorCode);
}

/* Calculate the optimized DS Interleaver Memory portion for a given
   profile and RTX usage
   from showtime status
   and propose a retrain for rate improvement. 
   This corresponds to ApsMemPartitioning spec case III. */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DynamicItlvPartCurrentProfileCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_boolean_t bRtxUsedDs,
   DSL_boolean_t bRtxUsedUs,
   DSL_boolean_t *bRetrain,
   DSL_uint32_t *pMemPortion)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t    errorCode = DSL_SUCCESS;
   DSL_uint32_t   nAddDs1 = 0, nMemUs1 = 0, nMemDs1 = 0,
                  nAddUs2 = 0, nMemUs2 = 0, nMemDs2 = 0,
                  nAddDs3 = 0, /* nMemUs3 = 0, */ nMemDs3 = 0,
                  nActMemUs = 0, nActMemDs = 0,
                  nMinMemUs = 0, nMinMemDs = 0, nMaxMemUs = 0, nMaxMemDs = 0,
                  nPhysMem = 0, nMinMemSum = 0,
                  nDeltaDRgap = 0, nDeltaRateDs = 0, nActNdr = 0;
   DSL_float_t    fDsWeight = 0.0;

   DSL_CHECK_POINTER(pContext, bRetrain);
   DSL_CHECK_POINTER(pContext, pMemPortion);

   DSL_DEBUG(DSL_DBG_MSG, (pContext, 
      "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartCurrentProfileCalculate" DSL_CRLF, 
      nLine));

   *bRetrain = DSL_FALSE;
   *pMemPortion = 0;

   fDsWeight = DSL_UINT8_GET(DSL_DBL_MEMSPLIT_DS_WEIGHT)/100.0;
   nDeltaDRgap = DSL_UINT32_GET(DSL_DBI_EAPS2_DELTA_DATA_RATE_GAP);
   nActNdr = (bRtxUsedDs == DSL_TRUE)?
               DSL_UINT32_GET(DSL_DBSC_RETX_ACTNDR_DS):
               DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_DS);
   nActNdr /= 1000;

   errorCode = DSL_AVX_Eaps2ProfilePhysMemCalculate(pContext, 
                  nLine, nProfile, &nPhysMem);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2ProfilePhysMemCalculate failed: %d" DSL_CRLF, 
         nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2ActMemCalculate(pContext, nLine, DSL_UPSTREAM, 
                  nProfile, bRtxUsedUs, &nActMemUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2ActMemCalculate for UPSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2ActMemCalculate(pContext, nLine, DSL_DOWNSTREAM, 
                  nProfile, bRtxUsedDs, &nActMemDs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2ActMemCalculate for DOWNSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MinMemCalculate(pContext, nLine, DSL_UPSTREAM, 
                  bRtxUsedUs, nActMemUs, &nMinMemUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MinMemCalculate for UPSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MinMemCalculate(pContext, nLine, DSL_DOWNSTREAM, 
                  bRtxUsedDs, nActMemDs, &nMinMemDs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MinMemCalculate for DOWNSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   nMinMemSum = nMinMemUs + nMinMemDs;

   if ( nMinMemSum < nPhysMem ) 
      nAddDs1 = (DSL_uint32_t)(ceil(nPhysMem - nMinMemSum) * fDsWeight);
   nMemDs1 = nMinMemDs + nAddDs1;
   nMemUs1 = nPhysMem - nMemDs1;

   errorCode = DSL_AVX_Eaps2MaxMemCurrentProfileCalculate(pContext, nLine, 
                  DSL_UPSTREAM, bRtxUsedUs, nActMemUs, &nMaxMemUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MaxMemCurrentProfileCalculate "
         "for UPSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MaxMemCurrentProfileCalculate(pContext, nLine, 
                  DSL_DOWNSTREAM, bRtxUsedDs, nActMemDs, &nMaxMemDs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MaxMemCurrentProfileCalculate "
         "for DOWNSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if ( nMemDs1 > nMaxMemDs ) nAddUs2 = nMemDs1 - nMaxMemDs;
   nMemUs2 = nMemUs1 + nAddUs2;
   nMemDs2 = nPhysMem - nMemUs2;

   if ( nMemUs2 > nMaxMemUs ) nAddDs3 = nMemUs2 - nMaxMemUs;
   nMemDs3 = nMemDs2 + nAddDs3;
   /* nMemUs3 = nPhysMem - nMemDs3; */

   if ( nActMemDs > 0 )
   {
      nDeltaRateDs = (( nMemDs3 -  nActMemDs ) * nActNdr ) / nActMemDs;
   }

   if ( nDeltaRateDs > nDeltaDRgap ) *bRetrain = DSL_TRUE;
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]DSL_AVX_Eaps2DynamicItlvPartCurrentProfileCalculate: bRetrain=%d" DSL_CRLF, nLine, *bRetrain));

   *pMemPortion = ceil(( nMemDs3 * 100 ) / nPhysMem );

   if ( *pMemPortion > 100 )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartCurrentProfileCalculate: calculated values of "
         "memory portions RTX/IFEC (%u) are not in the range of 0...100!" DSL_CRLF,
            nLine, *pMemPortion));

      return DSL_ERR_MEM_PARTITION_INFEASIBLE;
   }

   if ( *pMemPortion < 5 )
   {
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartCurrentProfileCalculate: "
         "limit the MemPortion %d %% to the lower bound 5%%!"
         DSL_CRLF, nLine, *pMemPortion));

      *pMemPortion = 5;
   }

   if ( *pMemPortion > 95 )
   {
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartCurrentProfileCalculate: limit the MemPortion %d %% to the upper bound 95%%!"
         DSL_CRLF, nLine, *pMemPortion));

      *pMemPortion = 95;
   }

   return (errorCode);
}

/* Calculate the optimized DS Interleaver Memory portion for a given
   next profile and RTX usage
   from current showtime status. 
   This corresponds to ApsMemPartitioning spec case IV. */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_boolean_t bRtxUsedDs,
   DSL_boolean_t bRtxUsedUs,
   DSL_uint32_t *pMemPortion,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t    errorCode = DSL_SUCCESS;
   DSL_uint32_t   nAddDs1 = 0, nMemUs1 = 0, nMemDs1 = 0,
                  nAddUs2 = 0, nMemUs2 = 0, nMemDs2 = 0,
                  nAddDs3 = 0, /* nMemUs3 = 0, */ nMemDs3 = 0,
                  nActMemUs = 0, nActMemDs = 0,
                  nMinMemUs = 0, nMinMemDs = 0, nMaxMemUs = 0, nMaxMemDs = 0,
                  nPhysMemX = 0, nPhysMemY = 0, nMinMemSum = 0;

   DSL_uint32_t   nLineRate = 0;
   DSL_uint32_t   nLineRateCapped = 0, nLineRateUs = 0, nLineRateDs = 0, nMinMemRateUs = 0;

   DSL_float_t    fDsWeight = 0.0, fMarginFactor = 1.01;

   DSL_CHECK_POINTER(pContext, pMemPortion);
   DSL_CHECK_POINTER(pContext, bRetrain);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate"
      "(profile %d->%d, bRtxDs=%d, bRtxDs=%d)" DSL_CRLF, 
      nLine, nFromProfile, nNextProfile, bRtxUsedDs, bRtxUsedUs));
      
   *pMemPortion = 0;
   *bRetrain = DSL_TRUE;

   nLineRateUs = DSL_UINT32_GET(DSL_DBS_ACTLINERATE_US)/1000;
   nLineRateDs = DSL_UINT32_GET(DSL_DBS_ACTLINERATE_DS)/1000;

   fDsWeight = DSL_UINT8_GET(DSL_DBL_MEMSPLIT_DS_WEIGHT)/100.0;

   errorCode = DSL_AVX_Eaps2ProfilePhysMemCalculate(pContext, nLine, 
                  nFromProfile, &nPhysMemX);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2ProfilePhysMemCalculate for the current profile failed: %d" DSL_CRLF,
         nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2ProfilePhysMemCalculate(pContext, nLine,
                  nNextProfile, &nPhysMemY);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2ProfilePhysMemCalculate for the next profile failed: %d" DSL_CRLF,
         nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2AttNdrNextProfileCalculate(pContext, nLine, pBat, 
                  nFromProfile, nNextProfile, &nLineRate);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2AttNdrNextProfileCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRateCappedCalculate(pContext, nLine, nLineRate, &nLineRateCapped);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRateCappedCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2ActMemCalculate(pContext, nLine, DSL_UPSTREAM,
                  nFromProfile, bRtxUsedUs, &nActMemUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2ActMemCalculate for UPSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2ActMemCalculate(pContext, nLine, DSL_DOWNSTREAM,
                  nFromProfile, bRtxUsedDs, &nActMemDs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2ActMemCalculate for DOWNSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MinMemRateConfigCalculate(pContext, nLine, DSL_UPSTREAM, 
                  nFromProfile, bRtxUsedUs, &nMinMemRateUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MinMemRateConfigCalculate for DOWNSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MinMemCalculate(pContext, nLine, DSL_UPSTREAM,
                  bRtxUsedUs, nActMemUs, &nMinMemUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MinMemCalculate for UPSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MinMemCalculate(pContext, nLine, DSL_DOWNSTREAM, 
                  bRtxUsedDs, nActMemDs, &nMinMemDs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MinMemCalculate for DOWNSTREAM failed: %d!" 
         DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   nMinMemSum = nMinMemUs + nMinMemDs;

   if ( nMinMemSum < nPhysMemY )
      nAddDs1 = (DSL_uint32_t)(ceil(nPhysMemY - nMinMemSum) * fDsWeight);
   nMemDs1 = nMinMemDs + nAddDs1;
   nMemUs1 = nPhysMemY - nMemDs1;

   errorCode = DSL_AVX_Eaps2MaxMemNextProfileCalculate(pContext, nLine, 
                  DSL_UPSTREAM, pBat, nFromProfile, nNextProfile, bRtxUsedUs,
                  nActMemUs, &nMaxMemUs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MaxMemNextProfileCalculate "
         "for UPSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2MaxMemNextProfileCalculate(pContext, nLine, 
                  DSL_DOWNSTREAM, pBat, nFromProfile, nNextProfile, bRtxUsedDs,
                  nActMemDs, &nMaxMemDs);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_Eaps2MaxMemNextProfileCalculate "
         "for DOWNSTREAM failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if ( nMemDs1 > nMaxMemDs ) nAddUs2 = nMemDs1 - nMaxMemDs;
   nMemUs2 = nMemUs1 + nAddUs2;
   nMemDs2 = nPhysMemY - nMemUs2;

   if ( nMemUs2 > nMaxMemUs ) nAddDs3 = nMemUs2 - nMaxMemUs;
   nMemDs3 = nMemDs2 + nAddDs3;
   /* nMemUs3 = nPhysMemY - nMemDs3; */

   *pMemPortion = ceil(( nMemDs3 * 100 ) / nPhysMemY );

   if ( *pMemPortion > 100 )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate: calculated values of "
         "memory portions RTX/IFEC (%u) are not in the range of 0...100!" DSL_CRLF,
            nLine, *pMemPortion));

      return DSL_ERR_MEM_PARTITION_INFEASIBLE;
   }

   if ( *pMemPortion < 5 )
   {
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate: limit the MemPortion %d %% to the lower bound 5 %%!"
         DSL_CRLF, nLine, *pMemPortion));

      *pMemPortion = 5;
   }

   if ( *pMemPortion > 95 )
   {
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate: "
         "limit the MemPortion %d %% to the upper bound 95 %%!"
         DSL_CRLF, nLine, *pMemPortion));

      *pMemPortion = 95;
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate: "
      "MemPortion = %d, "
      "physical memory for the next profile = %d, "
      "physical memory for the curr profile = %d" DSL_CRLF, 
      nLine, *pMemPortion, nPhysMemY, nPhysMemX));

   if (nPhysMemY < nPhysMemX)
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate: "
         "physical memory for next profile %d is less than for current %d."
         DSL_CRLF, nLine, nPhysMemY, nPhysMemX));

      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate: "
         "actual memory ds = %d, actual memory us = %d, "
         "line rate capped = %d, min memory rate us = %d,"
         "line rate ds = %d, line rate us = %d, margin factor = %f."
         DSL_CRLF, nLine, nActMemDs, nActMemUs, nLineRateCapped, 
         nMinMemRateUs, nLineRateDs, nLineRateUs, fMarginFactor));
 
      if (nLineRateDs &&
          ((floor(nPhysMemY * *pMemPortion/100.0) <= ((fMarginFactor * nActMemDs * nLineRateCapped) / nLineRateDs))))
      {
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "Condition hit, no retrain: " DSL_CRLF
            "floor(nPhysMemY * pMemPortion/100) <= (( nActMemDs * nLineRateCapped * fMarginFactor) / nLineRateDs)" DSL_CRLF
            "floor(%d * %d/100) <= ((%d * %d * %f) / %d)"
            DSL_CRLF, nPhysMemY, *pMemPortion, nActMemDs, nLineRateCapped, fMarginFactor, nLineRateDs));
         *bRetrain = DSL_FALSE;
      }
      else if (nLineRateUs &&
               ((nPhysMemY - floor((nPhysMemY * *pMemPortion)/100.0)) <= (( nActMemUs * nMinMemRateUs )/ nLineRateUs)))
      {
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "Condition hit, no retrain: " DSL_CRLF
            "(nPhysMemY - floor(nPhysMemY * pMemPortion/100)) <= (( nActMemUs * nMinMemRateUs )/ nLineRateUs)" DSL_CRLF
            "(%d - floor(%d * %d/100)) <= (( %d * %d )/ %d)"
            DSL_CRLF, nPhysMemY, nPhysMemY, *pMemPortion, nActMemUs, nMinMemRateUs, nLineRateUs));
         *bRetrain = DSL_FALSE;
      }
   }
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate - out: bRetrain=%d" DSL_CRLF, nLine, *bRetrain));

   return (errorCode);
}

/* This is the EAPS2 D5 check, but can also be done without EAPS2 enabled. */
DSL_LOCAL DSL_Error_t DSL_AVX_MemSplitRetrainCheck(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_uint32_t  nDsMemPortion = 0;
   DSL_boolean_t bRtxUsedDs = DSL_FALSE, bRtxUsedUs = DSL_FALSE, bMemSplitRetrain = DSL_FALSE;
   DSL_uint8_t   nProfile;
   DSL_int8_t    nMemPortion = -1;
   DSL_Profile_t vdsl2Profile;
   DSL_dbi_t nDbiMemPortion;
   DSL_uint16_t nMaxDelayDs = 0, nMaxDelayUs = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext, 
      "DSL[%02d]: DSL_AVX_MemSplitRetrainCheck" DSL_CRLF, nLine));

   errorCode = DSL_VdslConfiguredProfileGet(pContext, nLine, &vdsl2Profile);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_VdslConfiguredProfileGet failed: %d!" DSL_CRLF, 
         nLine, errorCode));
      return errorCode;
   }

   if (vdsl2Profile < DSL_PROFILE_17B)
   {
      nProfile = 1 << vdsl2Profile;
   }
   else if (vdsl2Profile == DSL_PROFILE_17B)
   {
      nProfile = DSL_G997_PROFILES_17A;
   }
   else
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, 
         "DSL[%02d]: DSL_AVX_MemSplitRetrainCheck: invalid vdsl2 profile %d!" DSL_CRLF,
         nLine, vdsl2Profile));
      return DSL_ERROR;
   }

   nMemPortion = DSL_INT8_GET(DSL_DBL_EAPS2_DS_MEM_PORTION);
   bMemSplitRetrain = (DSL_boolean_t)DSL_UINT8_GET(DSL_DBS_EAPS2_RETRAIN_MODE);

   if ((bMemSplitRetrain == DSL_TRUE) && (nMemPortion == -1))
   {
      bRtxUsedDs = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_DS)==(DSL_uint8_t)DSL_RTX_USED);
      bRtxUsedUs = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_US)==(DSL_uint8_t)DSL_RTX_USED);

      if ( bRtxUsedDs == DSL_FALSE ) /* IFEC mode */
      {
         nMaxDelayDs = DSL_UINT16_GET(DSL_DBC_MAX_I_DELAY_DS);
         nMaxDelayUs = DSL_UINT16_GET(DSL_DBC_MAX_I_DELAY_US);

         if (((nMaxDelayDs == 1) && (nMaxDelayUs != 1)) ||
             ((nMaxDelayUs == 1) && (nMaxDelayDs != 1)) ||
             ((nMaxDelayUs == nMaxDelayDs) && (nMaxDelayUs == 1)))
         {
            *bRetrain = DSL_FALSE;
            return DSL_SUCCESS;
         }
      }

      errorCode = DSL_AVX_Eaps2DynamicItlvPartCurrentProfileCalculate(pContext,
                     nLine, nProfile, bRtxUsedDs, bRtxUsedUs, bRetrain, &nDsMemPortion);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2DynamicItlvPartCurrentProfileCalculate failed: %d!"
            DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      if ( *bRetrain )
      {
         DSL_DEBUG(DSL_DBG_MSG, (pContext, 
            "DSL[%02d]: DSL_AVX_MemSplitRetrainCheck: memsplit retrain, "
            "DsMemPortion %d" DSL_CRLF, nLine, nDsMemPortion));

         if (bRtxUsedUs) nDbiMemPortion = DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION;
         else if (bRtxUsedDs) nDbiMemPortion = DSL_DBL_EAPS2_DS_RTX_MEM_PORTION;
         else nDbiMemPortion = DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION;

         DSL_UINT16_SET(nDbiMemPortion, nDsMemPortion);
      }
   }

   return errorCode;
}

/**
   Retieve ablsolute breakpoints for a specified profile */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DefaultPsdMaskGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_AccessDir_t nDirection,
   DSL_uint8_t nProfile,
   DSL_G997_DEV_PsdMaskConfig_t *pPsdMaskConfig)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;

   DSL_uint8_t nCurrentProfile;
   DSL_uint8_t nNumBp;

   DSL_uint16_t nArrayIdx = (DSL_uint16_t) DSL_DEV_VDSL2;
   DSL_int16_t nMaxNomPsd = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2DefaultPsdMaskGet: profile %d!" DSL_CRLF,
      nLine, nProfile));

   nCurrentProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);

   nMaxNomPsd = DSL_INT16_AGET((nDirection == DSL_UPSTREAM) ? DSL_DBLA_MAXNOMPSD_US : DSL_DBLA_MAXNOMPSD_DS);

   memset(pPsdMaskConfig, 0, sizeof(DSL_G997_DEV_PsdMaskConfig_t));

   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfile);
   errorCode = DSL_G997_DEV_PsdMaskConfigGet(pContext, nLine, nDirection, DSL_DEV_VDSL2, DSL_DEV_PSDMASK_ONLY, pPsdMaskConfig);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nCurrentProfile);

      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_G997_DEV_PsdMaskConfigGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   nRet = DSL_VNX_PsdMask_Process(pContext, nLine, nDirection, DSL_DEV_VDSL2, pPsdMaskConfig, &nMaxNomPsd);
   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nCurrentProfile);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   nRet = DSL_PsdShift(pContext, (DSL_uint16_t)(nMaxNomPsd / (-5)), pPsdMaskConfig);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   DSL_DEBUG(DSL_DBG_MSG, (pContext, "Breakpoints:  " ));
   for (nNumBp = 0; nNumBp < pPsdMaskConfig->nNumBreakpoints; nNumBp++)
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "(%d,%d) ", pPsdMaskConfig->nBreakPoint[nNumBp].nSubcarrierIndex, pPsdMaskConfig->nBreakPoint[nNumBp].nPsdMaskLevel));
   }
   DSL_DEBUG(DSL_DBG_MSG, (pContext, DSL_CRLF));

   return DSL_SUCCESS;
}

/** Calculates a line rate delta between a current profile 
   given by number and current BAT 
   and a next profile estimated by to be configured PSD and current SNR.
   The delta calculation is done only over the currently configured bands, 
   specified by nCurrentProfile, but may exceed the number of used tones 
   in the BAT.
   
   \param pContext
   \param nLine
   \param pBat             current BAT resulting from nCurrentProfile
   \param nCurrentProfile  Currently configured profile which caused the given 
                           BAT and current SNR per tone
   \param nNextProfile     different profile to estimate and compare against
   \param pDeltaLineRate   returns the possible line rate delta within the 
                           currently configured bands in kbps.
   */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DeltaLineRateCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nCurrentProfile,
   DSL_uint8_t nNextProfile,
   DSL_int_t *pDeltaLineRate)
{
#define DSL_AVX_SNR_GAP 98
#define DSL_AVX_CODING_GAIN 55

   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_G997_TransmitSpectrumShaping_t sCurrTSSis;
   DSL_G997_DEV_PsdMaskConfig_t sNextPsdMask;
   DSL_G997_NSCData8Ex_t snr;
   DSL_BandList_t bandList;
   DSL_int_t deltaLineRate = 0;
   DSL_int_t snrInitial;
   DSL_int_t bandIndex;
   DSL_int_t vnScale;
   DSL_SnrMode_t actSnrMode;
   DSL_G997_VirtualNoisePsdConfig_t sVnPsdConfig;
   DSL_G997_NSCData16_t sTxPsdData;

   DSL_uint32_t nToneDivisor = nCurrentProfile == DSL_G997_PROFILES_30A ? 2 : 1;
   DSL_float_t fFs = 0.;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
   "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRateCalculate profile %d->%d!" DSL_CRLF, 
   nLine, nCurrentProfile, nNextProfile));

   actSnrMode = (DSL_SnrMode_t)DSL_UINT8_GET(DSL_DBS_ACTSNRMODE_DS);
   vnScale = DSL_INT8_GET(DSL_DBL_VN_SCALE_DS);

   errorCode = DSL_BandBorderConfigGet(pContext, nLine, DSL_DOWNSTREAM, &bandList);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_BandBorderConfigGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (bandList.nNumData < 2)
   {
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: too few bands %d < 2!" DSL_CRLF, nLine, bandList.nNumData));
   }

   errorCode = DSL_G997_DEV_TransmitSpectrumShapingGet(pContext, nLine, DSL_DOWNSTREAM, DSL_DEV_VDSL2, &sCurrTSSis);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_G997_DEV_TransmitSpectrumShapingGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2DefaultPsdMaskGet(pContext, nLine, DSL_DOWNSTREAM, nNextProfile, &sNextPsdMask);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DefaultPsdMaskGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_G997_DEV_DeltSNRGet(pContext, nLine, DSL_DOWNSTREAM, &snr);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_G997_DEV_DeltSNRGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_DEV_MedleyReferencePsdNSCGet(pContext, nLine, DSL_DOWNSTREAM, &sTxPsdData);
   if ( errorCode != DSL_SUCCESS )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_MedleyReferencePsdNSCGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   snrInitial = DSL_AVX_SNR_GAP + DSL_UINT16_GET(DSL_DBL_TARSNRM_DS) - DSL_AVX_CODING_GAIN;
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: snrInitial(%d) = DSL_AVX_SNR_GAP(%d) + TARSNRM(%d) - DSL_AVX_CODING_GAIN(%d)" DSL_CRLF,
      nLine, snrInitial, DSL_AVX_SNR_GAP, DSL_UINT16_GET(DSL_DBL_TARSNRM_DS), DSL_AVX_CODING_GAIN));

   errorCode = DSL_VN_DeviceConfigGet(pContext, nLine, DSL_DOWNSTREAM, &sVnPsdConfig);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_VN_DeviceConfigGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (nNextProfile == DSL_G997_PROFILES_30A)
      fFs = (DSL_float_t)((8 * 256.) / 257.);
   else
      fFs = (DSL_float_t)((4 * 256.) / 257.);

   for (bandIndex = 0; bandIndex <= 1 && bandIndex < bandList.nNumData; bandIndex++)
   {
      DSL_Band_t *pBand = &bandList.nBand[bandIndex];
      DSL_uint16_t tone;

      for (tone = pBand->nFirstToneIndex; tone <= pBand->nLastToneIndex; tone++)
      {
         DSL_G997_PsdMaskBreakpoint_t bp, bp_vn;
         DSL_int_t tmp1, tmp2, tmp3, idx;
         DSL_int_t deltaSNR = 0;
         DSL_int_t currVN;
         DSL_int_t curSNR_withVN, curSNR_woVN;
         DSL_int_t nCurrPsd;
         
         idx = tone / (nToneDivisor * snr.nGroupSize);

         if (DSL_PsdBreakPointInterpolatedGet(tone, &sCurrTSSis.BreakPoints, &bp) != DSL_SUCCESS)
            continue;

         nCurrPsd = sCurrTSSis.nMaxNomPsd - 5 * bp.nPsdMaskLevel;

         if (DSL_PsdBreakPointInterpolatedGet(tone, &sNextPsdMask, &bp) != DSL_SUCCESS)
            continue;

         tmp3 = - pBat->nNSCData[tone / nToneDivisor];

         if ((actSnrMode == DSL_SNRMODE_ACTIVE) || (actSnrMode == DSL_SNRMODE_RXREF_ACTIVE))
         {
            if (DSL_PsdBreakPointInterpolatedGet(tone, (DSL_G997_DEV_PsdMaskConfig_t *)&sVnPsdConfig, &bp_vn) != DSL_SUCCESS)
               continue;

            currVN = vnScale - 5 * bp_vn.nPsdMaskLevel;

            curSNR_woVN = -320 + 5 * snr.data.nNSCData[idx];
            
            if ((curSNR_woVN == 0) || (currVN == 0))
               continue;
            
            curSNR_withVN = sTxPsdData.nNSCData[idx] / DSL_MAX(sTxPsdData.nNSCData[idx] / curSNR_woVN, currVN);

            deltaSNR = (-5 * bp.nPsdMaskLevel - nCurrPsd) + curSNR_withVN - DSL_MAX(curSNR_withVN, snrInitial);

            DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
               "dSNR_withVN[%d] = (%d - %d) + %d - MAX(%d,%d); " , tone, 
               -5 * bp.nPsdMaskLevel, nCurrPsd, curSNR_withVN, curSNR_withVN, snrInitial));
         }
         else if (actSnrMode == DSL_SNRMODE_INACTIVE)
         {
            curSNR_woVN = -320 + 5 * snr.data.nNSCData[idx];
            deltaSNR = (-5 * bp.nPsdMaskLevel - nCurrPsd) + curSNR_woVN - DSL_MAX(curSNR_woVN, snrInitial);

            DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
               "dSNR_woVN[%d] = (%d - %d) + %d - MAX(%d,%d); " , tone, 
               -5 * bp.nPsdMaskLevel, nCurrPsd, curSNR_woVN, curSNR_woVN, snrInitial));
         }
         
         tmp2 = deltaSNR / 30;
         tmp1 = 0x0f + tmp3;

         
         DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
            "dLrSum += MIN( MAX( %d, %d) , %d ) * f; " , tmp2, tmp3, tmp1));
         
         tmp2 = DSL_MAX(tmp2, tmp3);

         deltaLineRate += (DSL_int_t)(fFs * DSL_MIN(tmp1, tmp2));

         DSL_DEBUG(DSL_DBG_LOCAL, (pContext,
            "dLrSum = %d" DSL_CRLF, deltaLineRate));
         
      }

      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: deltaLineRate til band %d = %d kbps" DSL_CRLF, nLine, bandIndex, deltaLineRate));
   }

   *pDeltaLineRate = deltaLineRate;
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRateCalculate: %d kbps" DSL_CRLF, nLine, deltaLineRate));

   return DSL_SUCCESS;
}

#if 0
DSL_LOCAL DSL_uint8_t DSL_AVX_Eaps2DeltaAtpGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_uint8_t datp;
   DSL_uint_t deltaDataRateGap;

   deltaDataRateGap = DSL_UINT32_GET(DSL_DBI_EAPS2_DELTA_DATA_RATE_GAP);

   datp = 2 * deltaDataRateGap / 500;

   return datp;
}
#endif

DSL_LOCAL DSL_Profile_t DSL_AVX_ProfileMaskToIndex(
   DSL_uint8_t nProfile)
{
#define PROFILE_CASE(id) \
   if (nProfile == DSL_G997_PROFILES_##id) { return DSL_PROFILE_##id; }

   PROFILE_CASE(30A)
   PROFILE_CASE(17A)
   PROFILE_CASE(12B)
   PROFILE_CASE(12A)
   PROFILE_CASE(8D)
   PROFILE_CASE(8C)
   PROFILE_CASE(8B)
   PROFILE_CASE(8A)

   return DSL_PROFILE_LAST;
}

DSL_LOCAL const char * DSL_AVX_ProfileName(
   DSL_uint8_t nProfile)
{
   static char *names[] = { "8A", "8B", "8C", "8D", "12A", "12B", "17A", "30A", "unknown" };

   DSL_Profile_t id;

   id = DSL_AVX_ProfileMaskToIndex(nProfile);

   return names[id];
}

/** D3 check whether to switch from VDSL showtime to ADSL 
   
   \param nProfile   current VDSL profile
   \param pBat       current BAT

*/
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3AdslCheck(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_G997_NSCData8_t *pBat,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_G997_NSCData8_t *pNextBat;
   DSL_uint16_t highestTone, nFreqMaxADSL;
   DSL_uint8_t maxnomatpVdsl;
   DSL_uint8_t maxnomatpAdsl;
   DSL_boolean_t bRtxUsed = DSL_FALSE, bAdslProfileFailed = DSL_FALSE;
   DSL_int8_t memPortion = 0;
   DSL_DEV_PsdDslMode_t nCommonAdslDevMode;

   *bRetrain = DSL_FALSE;

   DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2D3AdslCheck" DSL_CRLF, nLine));

   memPortion = (DSL_int8_t)DSL_INT8_GET(DSL_DBL_EAPS2_DS_MEM_PORTION);

   if ( DSL_G997_IsAdslConfigured(pContext, nLine) == DSL_FALSE )
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2D3AdslCheck: Adsl mode is not configured!" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   highestTone = DSL_UINT16_GET(DSL_DBS_HIGHESTTONE_DS);

   errorCode = DSL_AVX_MaxNomPsdMaxNomAtpGet(pContext, nLine, 
                  DSL_DOWNSTREAM, DSL_DEV_VDSL2, DSL_NULL, &maxnomatpVdsl);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_MaxNomPsdMaxNomAtpGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }
   
   if ((nProfile >= AVX_VDSL_PROFILE_8A) && (nProfile <= AVX_VDSL_PROFILE_30A))
   {
      maxnomatpVdsl = DSL_MIN(DSL_AVX_APS_PreselectDataTable[nProfile - 1].MaxnomatpDs, maxnomatpVdsl);
   }
   else
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: Unexpected profile number %d, preselected value usage skipped" DSL_CRLF, nLine, nProfile));
   }

   errorCode = DSL_AVX_Eaps2D3HighestAdslCommonModeGet(pContext, nLine, &nCommonAdslDevMode);
   if ((errorCode != DSL_SUCCESS) || (nCommonAdslDevMode == DSL_DEV_XDSL_MODE_LAST))
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2D3HighestAdslCommonModeGet "
         "failed or no common ADSL mode found: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }   

   errorCode = DSL_AVX_MaxNomPsdMaxNomAtpGet(pContext, nLine, DSL_DOWNSTREAM, 
                  nCommonAdslDevMode, DSL_NULL, &maxnomatpAdsl);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_MaxNomPsdMaxNomAtpGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if ((nCommonAdslDevMode == DSL_DEV_ADSL2_PLUS) ||
       (nCommonAdslDevMode == DSL_DEV_ADSL2_PLUS_ANNEX_M) ||   
       (nCommonAdslDevMode == DSL_DEV_ADSL2_PLUS_ANNEX_J))
   {
      nFreqMaxADSL = 2200;
   }
   else
   {
      nFreqMaxADSL = 1100;
   }

   if ((highestTone * 4.3125 <= nFreqMaxADSL) && (maxnomatpAdsl >= maxnomatpVdsl))
   {
      bAdslProfileFailed = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_ADSL_PROFILE_FAILED));
      if (bAdslProfileFailed == DSL_FALSE)
      {
         /* disable VDSL */
         DSL_AVX_VdslDisable(pContext, nLine);

         *bRetrain = DSL_TRUE;

         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: Eaps2 D3: switch %s to ADSL OK" DSL_CRLF,
            nLine, DSL_AVX_ProfileName(nProfile)));
      }
   }
   else if (( memPortion > 0 ) && ( memPortion <= 100 ))
   {
      bRtxUsed = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_DS)==(DSL_uint8_t)DSL_RTX_USED);

      pNextBat = (DSL_G997_NSCData8_t *) DSL_Malloc(sizeof(DSL_G997_NSCData8_t));
      if (pNextBat == DSL_NULL)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_Malloc(%d) failed!" DSL_CRLF, nLine, 
            (DSL_int_t)sizeof(DSL_G997_NSCData8_t)));
         return DSL_ERROR;
      }

      /* set next profile as any !eq to DSL_G997_PROFILES_30A */
      errorCode = DSL_AVX_Eaps2BatApproximate(pContext, nLine, nProfile, DSL_G997_PROFILES_17A, pBat, pNextBat);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_Free(pNextBat);
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2BatApproximate failed: %d" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      errorCode = DSL_AVX_Eaps2FixedItlvPartConfigAdslCheck(pContext, nLine, nProfile, pNextBat, bRtxUsed, bRetrain);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2FixedItlvPartConfigAdslCheck failed: %d!" DSL_CRLF, nLine, errorCode));
      }

      DSL_Free(pNextBat);
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3HighestAdslCommonModeGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_DEV_PsdDslMode_t *pCommonDevMode)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint8_t *pFeXtse = &pContext->G997.FeLineInventory[nLine].ATSECapabilities[0];
   const DSL_uint8_t nChannel = 0;   
   
   if (pCommonDevMode == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2D3HighestAdslCommonModeGet: pCommonDevMode uninitialized" DSL_CRLF, nLine));
      return DSL_ERROR;   
   }

   if ((DSL_UINT8_GET(DSL_DBL_ATSE_7) & pFeXtse[6]) & (ATSE_7_03_M_5_NO))
      *pCommonDevMode = DSL_DEV_ADSL2_PLUS_ANNEX_M;

   else if ((DSL_UINT8_GET(DSL_DBL_ATSE_7) & pFeXtse[6]) & (ATSE_7_01_J_5_NO))
      *pCommonDevMode = DSL_DEV_ADSL2_PLUS_ANNEX_J;
   
   else if ((DSL_UINT8_GET(DSL_DBL_ATSE_6) & pFeXtse[5]) & (ATSE_6_01_A_5_NO | ATSE_6_03_B_5_NO | ATSE_6_07_I_5_NO))
      *pCommonDevMode = DSL_DEV_ADSL2_PLUS;

   else if ((DSL_UINT8_GET(DSL_DBL_ATSE_5) & pFeXtse[4]) & ATSE_5_07_M_3_NO) 
      *pCommonDevMode = DSL_DEV_ADSL2_ANNEX_M;

   else if ((DSL_UINT8_GET(DSL_DBL_ATSE_5) & pFeXtse[4]) & (ATSE_5_03_L_3_NO | ATSE_5_04_L_3_NO))
      *pCommonDevMode = DSL_DEV_ADSL2_ANNEX_L;

   else if ((DSL_UINT8_GET(DSL_DBL_ATSE_4) & pFeXtse[3]) & ATSE_4_07_J_3_NO)
      *pCommonDevMode = DSL_DEV_ADSL2_ANNEX_J;

   else if (((DSL_UINT8_GET(DSL_DBL_ATSE_3) & pFeXtse[2]) & (ATSE_3_03_A_3_NO | ATSE_3_05_B_3_NO)) ||
       ((DSL_UINT8_GET(DSL_DBL_ATSE_4) & pFeXtse[3]) & (ATSE_4_05_I_3_NO)) )
      *pCommonDevMode = DSL_DEV_ADSL2;

   else
      *pCommonDevMode = DSL_DEV_XDSL_MODE_LAST;
      
   return errorCode;
}

/**
   Calculate the line rate delta that can be achieved by subcarriers of 
   nNextProfile exceeding the bandlist of nFromProfile. The (estimated) 
   bitloading of pNextBat is summarized for frequencies above the maximum 
   frequency determined by nFromProfile.

   \param pNextBat            BitAllocationTable the data rate
                              portions shall be calculated from
   \param nCurrentProfile     used for 4/8kHz spacing
   \param nFromProfile        used to get the start tone for BAT integration
   \param nNextProfile        used to get the end tone for BAT integration
   \param pDeltaLineRatePlus  returns the calculated dtat arte portion
   */
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pNextBat,
   DSL_uint8_t nCurrentProfile,
   DSL_uint8_t nFromProfile,
   DSL_uint8_t nNextProfile,
   DSL_int_t *pDeltaLineRatePlus)
{
   DSL_uint16_t startTone, stopTone;
   DSL_int_t deltaLineRate = 0;
   DSL_uint16_t tone;
   DSL_Profile_t profileId;
   DSL_AVX_APS_PreselectDataTable_t sPreselectTable;
   DSL_Error_t nRet, errorCode = DSL_SUCCESS;

   DSL_CHECK_POINTER(pContext, pDeltaLineRatePlus);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
   "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate profile %d->%d!" DSL_CRLF, 
   nLine, nFromProfile, nNextProfile));

   /* FIXME: consider the DS bands for the interval to summarize over */
   switch (nFromProfile)
   {
   case DSL_G997_PROFILES_8A:
   case DSL_G997_PROFILES_8B:
   case DSL_G997_PROFILES_8C:
   case DSL_G997_PROFILES_8D:
      startTone = 1972; /* 8500.0 / 4.3125 */
      break;
   case DSL_G997_PROFILES_12A:
   case DSL_G997_PROFILES_12B:
      startTone = 2783; /* 12000.0 / 4.3125 */
      break;
   case DSL_G997_PROFILES_17A:
      startTone = 4096; /* 17660.0 / 4.3125 */
      break;
   case DSL_G997_PROFILES_30A:
      startTone = 6957; /* 30000.0 / 4.3125 */
      break;
   default:
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: invalid vdsl profile %d!" DSL_CRLF, nLine, nFromProfile));
      return DSL_ERROR;
   }

   nRet = DSL_AVX_Eaps2PreselectionTableGet(pContext, nLine, &sPreselectTable);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "error getting Eaps2PreselectionTable" DSL_CRLF, nLine);

   profileId = DSL_AVX_ProfileMaskToIndex(nNextProfile);
   if(profileId >= DSL_ARRAY_LENGTH(sPreselectTable.Entry))
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: invalid vdsl profile id %d!" DSL_CRLF, nLine, profileId));
      return DSL_ERROR;
   }
   stopTone = sPreselectTable.Entry[profileId].MaxFrequency;

   if (nCurrentProfile == DSL_G997_PROFILES_30A)
   {
      startTone /= 2;
      stopTone /= 2;
   }

   if (stopTone > DSL_MAX_NSC)
   {
      stopTone = DSL_MAX_NSC;
   }

   for (tone = startTone; tone < stopTone; tone++)
   {
      deltaLineRate += pNextBat->nNSCData[tone];
   }

   if (nCurrentProfile != DSL_G997_PROFILES_30A)
      deltaLineRate *= 4;
   else
      deltaLineRate *= 8;

   *pDeltaLineRatePlus = (deltaLineRate * 256) / 257;
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate: %d kbps" DSL_CRLF, nLine, deltaLineRate));

   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2BatApproximate(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t nProfile,
   DSL_uint8_t nNextProfile,
   DSL_G997_NSCData8_t *pBat,
   DSL_G997_NSCData8_t *pDestBat)
{
   const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_BandList_t sBandList, sBandListNext, sBandListNextInverted;
   DSL_Band_t *pBand = DSL_NULL;
   DSL_float_t nBeginAvg, nEndAvg;
   DSL_float_t nSlope;
   DSL_int_t n;
   DSL_uint_t nStartTone, nStartToneValue;
   DSL_uint_t nTone, nBand;
   DSL_uint8_t nProfileCurrent;
   DSL_uint_t nBeginIdx = 0, nMidIdx = 0, nEndIdx = 0;
   DSL_uint_t nBeginNum = 0, nMidNum = 0, nEndNum = 0;
   DSL_G997_RfiBandsConfig_t sRfiBandList;

#define DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE  (10)
#define DSL_AVX_EAPS2_BAT_NUM_OF_GUARD_TONES (50)

   /* Attention: this provides the bandlist for VDSL only! 
      DSL_AVX_Eaps2BatApproximate is not applicable for ADSL in this form. */
   errorCode = DSL_DEV_ConfiguredBandListGet(pContext, nLine, DSL_DOWNSTREAM, &sBandList);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_ConfiguredBandListGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   nProfileCurrent = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);
   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nNextProfile);
   errorCode = DSL_DEV_ConfiguredBandListGet(pContext, nLine, DSL_DOWNSTREAM, &sBandListNext);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_ConfiguredBandListGet next failed: %d!" DSL_CRLF, nLine, errorCode));
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfileCurrent);
      return errorCode;
   }

   errorCode = DSL_G997_RfiBandsConfigGet(pContext, nLine, DSL_G997_VDSL2, &sRfiBandList);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_G997_RfiBandsConfigGet failed %d!" DSL_CRLF, nLine, errorCode));
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfileCurrent);
      return errorCode;
   }

   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfileCurrent);

   if (sBandList.nNumData == 0)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_BandBorderConfigGet returned zero bands!" DSL_CRLF, nLine));
      return DSL_ERROR;
   }
   
   for ( nBand = sBandList.nNumData-1; nBand < DSL_MAX_NUMBER_OF_BANDS; nBand-- )
   {
      pBand = &sBandList.nBand[nBand];

      if ((pBand->nFirstToneIndex == 0) || (pBand->nLastToneIndex == 0))
      {
         /* skip empty band */
         continue;
      }
      
      nMidIdx = pBand->nLastToneIndex;

      if ( nEndNum < DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE )
      {
         /* Find highest 10 consecutive loaded tones */
         nEndNum = 0;
         for ( nEndIdx = pBand->nLastToneIndex; nEndIdx >= pBand->nFirstToneIndex; nEndIdx-- )
         {
            if (!DSL_IsIndexInRfiNotch(nEndIdx, &sRfiBandList) && (pBat->nNSCData[nEndIdx] != 0))
               nEndNum++;
            else
               nEndNum = 0;
      
            if ( nEndNum >= DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE )
               break;
         }
         nMidIdx = nEndIdx;
      }

      /* Check if cnt < DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE => switch to a lower pBand */
      if ( nEndNum < DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE ) continue;
   
      if ( nMidNum < DSL_AVX_EAPS2_BAT_NUM_OF_GUARD_TONES )
      {
         /* Calculate at least 50 loaded tones after the highest 10 consecutive loaded tones */
         for ( ; nMidIdx >= pBand->nFirstToneIndex; nMidIdx-- )
         {
            if (!DSL_IsIndexInRfiNotch(nMidIdx, &sRfiBandList) && (pBat->nNSCData[nMidIdx] != 0))
               nMidNum++;

            /* not necessary to check if the tones are consecutive loaded */
      
            if ( nMidNum >= DSL_AVX_EAPS2_BAT_NUM_OF_GUARD_TONES )
               break;
         }
      }

      /* Check if cnt < DSL_AVX_EAPS2_BAT_NUM_OF_GUARD_TONES => switch to a lower pBand */
      if ( nMidNum < DSL_AVX_EAPS2_BAT_NUM_OF_GUARD_TONES ) continue;

      /* Find lowest 10 consecutive loaded tones */
      for ( nBeginIdx = nMidIdx; nBeginIdx >= pBand->nFirstToneIndex; nBeginIdx-- )
      {
         if (!DSL_IsIndexInRfiNotch(nBeginIdx, &sRfiBandList) && (pBat->nNSCData[nBeginIdx] != 0))
            nBeginNum++;
         else
            nBeginNum = 0;
      
         if ( nBeginNum >= DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE )
            break;
      }

      /* Check if cnt < DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE => switch to a lower pBand */
      if ( nBeginNum < DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE ) continue;

      break;
   }
   
   /* if the two groups to average could not be found, break with error */
   if ( nBeginNum < DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE ) 
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2BatApproximate: BAT not decreases" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   nBeginAvg = 0;
   nEndAvg = 0;

   for (n = 0; n < DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE; n++)
   {
      nBeginAvg += pBat->nNSCData[nBeginIdx + n];
      nEndAvg += pBat->nNSCData[nEndIdx - n];
   }

   nBeginAvg /= DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE;
   nEndAvg /= DSL_AVX_EAPS2_BAT_NUM_OF_TONES_TO_ANALYZE;

   nSlope = (nEndAvg - nBeginAvg) / (DSL_float_t) (nEndIdx - nBeginIdx);

   if (pBand == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2BatApproximate: pBand is not initialized!" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   nStartTone = pBand->nLastToneIndex;
   nStartToneValue = pBat->nNSCData[nStartTone];

   if (nNextProfile != DSL_G997_PROFILES_30A)
   {
      /* writes the whole structure, no memset needed */
      memcpy(pDestBat, pBat, sizeof(*pBat));
   }
   else
   {
      memset(pDestBat, 0, sizeof(*pDestBat));
      pDestBat->nNumData = pBat->nNumData;

      for (nTone = 0; nTone < DSL_MAX_NSC / 2; nTone++)
      {
         pDestBat->nNSCData[nTone] = pBat->nNSCData[nTone * 2];
      }

      nStartTone /= 2;
      nSlope *= 2;
   }

   for (nTone = nStartTone + 1; nTone < DSL_MAX_NSC; nTone++)
   {
      DSL_int_t nNextTone;

      if (!DSL_IsIndexInRfiNotch(nTone, &sRfiBandList))
      {
         nNextTone = nStartToneValue + nSlope * (nTone - nStartTone);

         if (nNextTone <= 0)
         {
            break;
         }
         else if (nNextTone > 0x0f)
         {
            nNextTone = 0x0f;
         }

         pDestBat->nNSCData[nTone] = nNextTone;
      }
      else
      {
         pDestBat->nNSCData[nTone] = 0;
      }
   }

   DSL_CarrierListInvert(pContext, &sBandListNext, &sBandListNextInverted);
   /* remove tones not in bandplan of next profile */
   for (nBand = 0; (nBand < sBandListNextInverted.nNumData) &&
         (nBand < DSL_MAX_NUMBER_OF_BANDS); nBand++)
      for (nTone = sBandListNextInverted.nBand[nBand].nFirstToneIndex;
            (nTone <= sBandListNextInverted.nBand[nBand].nLastToneIndex) &&
            (nTone < DSL_MAX_NSC); nTone++)
         pDestBat->nNSCData[nTone] = 0;

   
   /* FIXME printout */
   for (nTone = DSL_MAX_NSC -1; nTone > 0; nTone--)
      if (pDestBat->nNSCData[nTone])
         break;
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2BatApproximate estimates highest tone %d:" DSL_CRLF, nLine, nTone));
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: estimated BAT:" DSL_CRLF, nLine));
   for (nTone = nStartTone + 1; nTone < DSL_MAX_NSC; nTone++)
   {
      if (pDestBat->nNSCData[nTone])
      {
         DSL_DEBUG(DSL_DBG_MSG, (pContext, "(%d,%02d), ", 
            nTone, pDestBat->nNSCData[nTone]));
      }
   }
   DSL_DEBUG(DSL_DBG_MSG, (pContext, DSL_CRLF));

   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3SwitchTo8Check(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint_t deltaDataRateGap;
   DSL_boolean_t is8ASupported, is8BSupported;
   DSL_uint8_t nNextProfile, maxnomatp;
   DSL_int_t deltaLineRate, deltaLineRatePlus;

   DSL_int8_t memPortion = 0;
   DSL_uint32_t nDsMemPortion = 0;
   DSL_boolean_t bRtxUsedDs = DSL_FALSE, bRtxUsedUs = DSL_FALSE;
   DSL_dbi_t nDbiMemPortion;
   DSL_uint16_t nMaxDelayDs = 0, nMaxDelayUs = 0;
   DSL_uint8_t *pFeXtse = &pContext->G997.FeLineInventory[nLine].ATSECapabilities[0];   
   DSL_boolean_t bDoRetrain = DSL_FALSE;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2D3SwitchTo8Check" DSL_CRLF, nLine));

   deltaDataRateGap = DSL_UINT32_GET(DSL_DBI_EAPS2_DELTA_DATA_RATE_GAP);
   memPortion = (DSL_int8_t)DSL_INT8_GET(DSL_DBL_EAPS2_DS_MEM_PORTION);

   is8ASupported = (DSL_boolean_t)((nProfileMask & DSL_G997_PROFILES_8A) != 0);
   is8BSupported = (DSL_boolean_t)((nProfileMask & DSL_G997_PROFILES_8B) != 0);

   *bRetrain = DSL_FALSE;

   errorCode = DSL_AVX_MaxNomPsdMaxNomAtpGet(pContext, nLine, DSL_DOWNSTREAM, DSL_DEV_VDSL2, DSL_NULL, &maxnomatp);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_MaxNomPsdMaxNomAtpGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (is8ASupported)
   {
      if (is8BSupported)
      {
         if (DSL_MIN(DSL_AVX_APS_PreselectDataTable[AVX_VDSL_PROFILE_8B - 1].MaxnomatpDs, maxnomatp) >
             DSL_MIN(DSL_AVX_APS_PreselectDataTable[AVX_VDSL_PROFILE_8A - 1].MaxnomatpDs, maxnomatp))
         {
            nNextProfile = DSL_G997_PROFILES_8B;
            maxnomatp = DSL_MIN(DSL_AVX_APS_PreselectDataTable[AVX_VDSL_PROFILE_8B - 1].MaxnomatpDs, maxnomatp);
         }
         else
         {
            nNextProfile = DSL_G997_PROFILES_8A;
            maxnomatp = DSL_MIN(DSL_AVX_APS_PreselectDataTable[AVX_VDSL_PROFILE_8A - 1].MaxnomatpDs, maxnomatp);
         }
      }
      else
      {
         nNextProfile = DSL_G997_PROFILES_8A;
      }
   }
   else if (is8BSupported)
   {
      nNextProfile = DSL_G997_PROFILES_8B;
   }
   else
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: invalid profile mask 0x%02x!" DSL_CRLF, nLine, nProfileMask));
      return DSL_ERROR;
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRateCalculate(pContext, nLine, pBat, nProfile, nNextProfile, &deltaLineRate);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRateCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   /* calculate delta LR 8plus, rate portion of current BAT above 8MHz */
   errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                  pContext,
                  nLine, pBat, nProfile,
                  nNextProfile, nProfile,
                  &deltaLineRatePlus);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if ((DSL_UINT8_GET(DSL_DBL_ATSE_1) & pFeXtse[0]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_2) & pFeXtse[1]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_3) & pFeXtse[2]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_4) & pFeXtse[3]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_5) & pFeXtse[4]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_6) & pFeXtse[5]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_7) & pFeXtse[6]))
   {
      DSL_BandList_t  sBandList;   
      DSL_DEV_PsdDslMode_t nCommonAdslDevMode;      
      DSL_uint16_t nFreqMaxADSL, highestTone;
      DSL_uint8_t maxnomatpAdsl;

      highestTone = DSL_UINT16_GET(DSL_DBS_HIGHESTTONE_DS);      
   
      memset(&sBandList, 0, sizeof(sBandList));
      errorCode = DSL_DEV_CurrentBandListGet(pContext, nLine, DSL_DOWNSTREAM, DSL_DEV_VDSL2, &sBandList);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_DEV_CurrentBandListGet failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      errorCode = DSL_AVX_Eaps2D3HighestAdslCommonModeGet(pContext, nLine, &nCommonAdslDevMode);
      if ((errorCode != DSL_SUCCESS) || (nCommonAdslDevMode == DSL_DEV_XDSL_MODE_LAST))
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2D3HighestAdslCommonModeGet failed or no common ADSL mode found: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }   

      errorCode = DSL_AVX_MaxNomPsdMaxNomAtpGet(pContext, nLine, DSL_DOWNSTREAM, nCommonAdslDevMode, DSL_NULL, &maxnomatpAdsl);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_MaxNomPsdMaxNomAtpGet failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      if ((nCommonAdslDevMode == DSL_DEV_ADSL2_PLUS) ||
          (nCommonAdslDevMode == DSL_DEV_ADSL2_PLUS_ANNEX_M) ||   
          (nCommonAdslDevMode == DSL_DEV_ADSL2_PLUS_ANNEX_J))
      {
         nFreqMaxADSL = 2200;
      }
      else
      {
         nFreqMaxADSL = 1100;
      }
      
      if (!((((nFreqMaxADSL < (highestTone * 4.3125)) &&
           (highestTone < sBandList.nBand[2].nFirstToneIndex)) ||
          (highestTone < sBandList.nBand[2].nFirstToneIndex)) && 
          (maxnomatp >= maxnomatpAdsl)))
      {
         return DSL_SUCCESS;
      }
   }


   if (deltaLineRate - deltaLineRatePlus >= (DSL_int_t) deltaDataRateGap)
   {
      bDoRetrain = DSL_TRUE;

      if (( memPortion > 0 ) && ( memPortion <= 100 ))
      {
         DSL_G997_NSCData8_t *pNextBat;

         pNextBat = (DSL_G997_NSCData8_t *) DSL_Malloc(sizeof(DSL_G997_NSCData8_t));
         if (pNextBat == DSL_NULL)
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_Malloc(%d) failed!" DSL_CRLF, nLine, 
               (DSL_int_t)sizeof(DSL_G997_NSCData8_t)));
            return DSL_ERROR;
         }

         errorCode = DSL_AVX_Eaps2BatApproximate(pContext, nLine, nProfile, nNextProfile, pBat, pNextBat);
         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pNextBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2BatApproximate failed: %d" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         errorCode = DSL_AVX_Eaps2FixedItlvPartConfigVdslCheck(pContext,
                           nLine, pNextBat, nProfile, nNextProfile,
                           (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_DS)==(DSL_uint8_t)DSL_RTX_USED),
                           &bDoRetrain);

         /* don't need this anymore in any case */
         DSL_Free(pNextBat);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2FixedItlvPartConfigVdslCheck failed: %d" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }
      }
      else  if ( memPortion == -1 ) /* special value */
      {
         bRtxUsedDs = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_DS)==(DSL_uint8_t)DSL_RTX_USED);
         bRtxUsedUs = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBS_RTX_USED_US)==(DSL_uint8_t)DSL_RTX_USED);

         if ( bRtxUsedDs == DSL_FALSE ) /* IFEC mode */
         {
            nMaxDelayDs = DSL_UINT16_GET(DSL_DBC_MAX_I_DELAY_DS);
            nMaxDelayUs = DSL_UINT16_GET(DSL_DBC_MAX_I_DELAY_US);

            if ((nMaxDelayDs == 1) && (nMaxDelayUs != 1))
            {
               /* 100% of the memory can be used for US */
               nDsMemPortion = 0;
               goto MEMSPLIT_EXIT;
            }
            else if ((nMaxDelayUs == 1) && (nMaxDelayDs != 1))
            {
               /* 100% of the memory can be used for DS */
               nDsMemPortion = 100;
               goto MEMSPLIT_EXIT;
            }
            else if ((nMaxDelayUs == nMaxDelayDs) && (nMaxDelayUs == 1))
            {
               /* memsplit doesn't matter at all - take the memsplit from the DB */
               nDsMemPortion = (DSL_uint32_t)DSL_UINT16_GET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION);
               goto MEMSPLIT_EXIT;
            }
         }

         errorCode = DSL_AVX_Eaps2DynamicItlvPartNextProfileCalculate(pContext,
                           nLine, pBat, nProfile, nNextProfile,
                           bRtxUsedDs, bRtxUsedUs, &nDsMemPortion,
                           &bDoRetrain);
         if ( errorCode != DSL_SUCCESS )
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext, 
               "DSL[%02d]: DSL_AVX_Eaps2MemSplitCalculate for RTX failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         if ( bDoRetrain )
         {

MEMSPLIT_EXIT:
            if (bRtxUsedUs) nDbiMemPortion = DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION;
            else if (bRtxUsedDs) nDbiMemPortion = DSL_DBL_EAPS2_DS_RTX_MEM_PORTION;
            else nDbiMemPortion = DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION;

            DSL_UINT16_SET(nDbiMemPortion, nDsMemPortion);
         }
      }

      if (bDoRetrain)
      {
         *bRetrain = DSL_TRUE;
         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nNextProfile);
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2D3SwitchTo8Check: set new profile %d" DSL_CRLF, 
            nLine, nNextProfile));
      }
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2D3SwitchTo8Check out: bRetrain=%d" DSL_CRLF, nLine, *bRetrain));
      
   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3_17_30(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_uint32_t deltaDataRateGap;
   DSL_G997_NSCData8_t *pNextBat;
   DSL_int_t lineRate = 0;

   deltaDataRateGap = DSL_UINT32_GET(DSL_DBI_EAPS2_DELTA_DATA_RATE_GAP);

   pNextBat = (DSL_G997_NSCData8_t *) DSL_Malloc(sizeof(DSL_G997_NSCData8_t));
   if (pNextBat == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_Malloc(%d) failed!" DSL_CRLF, nLine, 
         (DSL_int_t)sizeof(DSL_G997_NSCData8_t)));
      return DSL_ERROR;
   }

   errorCode = DSL_AVX_Eaps2BatApproximate(pContext, nLine, 
                  nProfile, DSL_G997_PROFILES_30A, pBat, pNextBat);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pNextBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2BatApproximate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(pContext, nLine, 
                  pNextBat, nProfile, nProfile, DSL_G997_PROFILES_30A, &lineRate);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pNextBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   
   if (lineRate >= (DSL_int_t) deltaDataRateGap)
   {
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, DSL_G997_PROFILES_30A);
      *bRetrain = DSL_TRUE;

      errorCode = DSL_AVX_Eaps2CalculateNextProfileDsMemPortion(pContext, nLine, pBat, nProfile, DSL_G997_PROFILES_30A);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_Free(pNextBat);
         DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2CalculateNextProfileDsMemPortion failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }
   }

   DSL_Free(pNextBat);

   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3_12_30(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_uint32_t deltaDataRateGap;
   DSL_G997_NSCData8_t *pNextBat;
   DSL_int_t lineRate = 0;

   deltaDataRateGap = DSL_UINT32_GET(DSL_DBI_EAPS2_DELTA_DATA_RATE_GAP);

   pNextBat = (DSL_G997_NSCData8_t *) DSL_Malloc(sizeof(DSL_G997_NSCData8_t));
   if (pNextBat == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_Malloc(%d) failed!" DSL_CRLF, nLine, 
         (DSL_int_t)sizeof(DSL_G997_NSCData8_t)));
      return DSL_ERROR;
   }

   errorCode = DSL_AVX_Eaps2BatApproximate(pContext, nLine, nProfile, DSL_G997_PROFILES_30A, pBat, pNextBat);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pNextBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2BatApproximate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (nProfileMask & DSL_G997_PROFILES_17A)
   {
      DSL_int_t lineRate17Plus = 0;

      errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                     pContext, nLine, pNextBat,
                     DSL_G997_PROFILES_30A, DSL_G997_PROFILES_17A, DSL_G997_PROFILES_30A,
                     &lineRate17Plus);

      if (errorCode != DSL_SUCCESS)
      {
         DSL_Free(pNextBat);
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      if (lineRate17Plus == 0)
      {
         DSL_Free(pNextBat);
         return DSL_SUCCESS;
      }
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                  pContext, nLine, pNextBat,
                  DSL_G997_PROFILES_30A, nProfile, DSL_G997_PROFILES_30A,
                  &lineRate);

   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pNextBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (lineRate >= (DSL_int_t) deltaDataRateGap)
   {
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, DSL_G997_PROFILES_30A);
      *bRetrain = DSL_TRUE;

      errorCode = DSL_AVX_Eaps2CalculateNextProfileDsMemPortion(pContext, nLine, pBat, nProfile, DSL_G997_PROFILES_30A);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_Free(pNextBat);
         DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2CalculateNextProfileDsMemPortion failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }
   }

   DSL_Free(pNextBat);

   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3_12_17(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_uint32_t deltaDataRateGap;
   DSL_G997_NSCData8_t *pNextBat;
   DSL_int_t lineRate = 0;

   deltaDataRateGap = DSL_UINT32_GET(DSL_DBI_EAPS2_DELTA_DATA_RATE_GAP);

   pNextBat = (DSL_G997_NSCData8_t *) DSL_Malloc(sizeof(DSL_G997_NSCData8_t));
   if (pNextBat == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_Malloc(%d) failed!" DSL_CRLF, nLine, 
         (DSL_int_t)sizeof(DSL_G997_NSCData8_t)));
      return DSL_ERROR;
   }

   errorCode = DSL_AVX_Eaps2BatApproximate(pContext, nLine, nProfile, DSL_G997_PROFILES_17A, pBat, pNextBat);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pNextBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2BatApproximate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (nProfileMask & DSL_G997_PROFILES_30A)
   {
      DSL_int_t lineRate17Plus = 0;

      errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                     pContext, nLine, pNextBat,
                     DSL_G997_PROFILES_17A, DSL_G997_PROFILES_17A, DSL_G997_PROFILES_17A,
                     &lineRate17Plus);

      if (errorCode != DSL_SUCCESS)
      {
         DSL_Free(pNextBat);
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      if (lineRate17Plus > 0)
      {
         DSL_Free(pNextBat);
         return DSL_SUCCESS;
      }
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                  pContext, nLine, pNextBat,
                  DSL_G997_PROFILES_17A, nProfile, DSL_G997_PROFILES_17A,
                  &lineRate);

   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pNextBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }
   if (lineRate >= (DSL_int_t) deltaDataRateGap)
   {
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, DSL_G997_PROFILES_17A);
      *bRetrain = DSL_TRUE;

      errorCode = DSL_AVX_Eaps2CalculateNextProfileDsMemPortion(pContext, nLine, pBat, nProfile, DSL_G997_PROFILES_17A);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_Free(pNextBat);
         DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2CalculateNextProfileDsMemPortion failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }
   }

   DSL_Free(pNextBat);

   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3_8_XX(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_G997_NSCData8_t *pBat,
   DSL_uint8_t nProfile,
   DSL_uint8_t nTargetProfile,
   DSL_uint8_t nProfileMask,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_uint32_t deltaDataRateGap;
   DSL_G997_NSCData8_t *pNextBat;
   DSL_int_t lineRate = 0;
   DSL_int_t lineRatePlus = 0;
   DSL_boolean_t bDoRetrain = DSL_FALSE, freqHighestUsCheck = DSL_FALSE;
   DSL_uint32_t indexDs = 0, indexUs = 0;
   DSL_BandList_t sBandListDs, sBandListUs;
   DSL_uint16_t highestUsableTone = 0, highestTone = 0, us2StartTone = 0;
   DSL_uint8_t nUS0Disabling = (DSL_Us0Disabling_t)DSL_US0DISABLING_OFF;
   DSL_uint8_t nTargetProfileId;

#define DSL_DELTA_NUM_US_TONE_GAP 75

   deltaDataRateGap = DSL_UINT32_GET(DSL_DBI_EAPS2_DELTA_DATA_RATE_GAP);
   highestUsableTone = DSL_UINT16_GET(DSL_DBS_MAX_TONE_US);

   /* Get DS band list of the dedicated profile */
   errorCode = DSL_DEV_ConfiguredBandListGet(pContext, nLine, DSL_DOWNSTREAM, &sBandListDs);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_ConfiguredBandListGet for DS failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   /* Get US band list of the dedicated profile */
   errorCode = DSL_DEV_ConfiguredBandListGet(pContext, nLine, DSL_UPSTREAM, &sBandListUs);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_ConfiguredBandListGet for US failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   /* find the highest supported subcarrier of the current profile */
   indexUs = ((sBandListUs.nNumData < DSL_MAX_NUMBER_OF_BANDS)?sBandListUs.nNumData:DSL_MAX_NUMBER_OF_BANDS)-1;
   indexDs = ((sBandListDs.nNumData < DSL_MAX_NUMBER_OF_BANDS)?sBandListDs.nNumData:DSL_MAX_NUMBER_OF_BANDS)-1;
   highestTone = DSL_MAX(sBandListUs.nBand[indexUs].nLastToneIndex, sBandListDs.nBand[indexDs].nLastToneIndex);

   /* switch to target profile */
   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nTargetProfile);

   /* Get US band list of the dedicated profile */
   errorCode = DSL_DEV_ConfiguredBandListGet(pContext, nLine, DSL_UPSTREAM, &sBandListUs);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfile);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_DEV_ConfiguredBandListGet for US failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   /* Check US0 support */
   /* calculate target profile id */
   switch (nTargetProfile)
   {
      case DSL_G997_PROFILES_30A: nTargetProfileId = AVX_VDSL_PROFILE_30A-1; break;
      case DSL_G997_PROFILES_17A: nTargetProfileId = AVX_VDSL_PROFILE_17A-1; break;
      case DSL_G997_PROFILES_12A: nTargetProfileId = AVX_VDSL_PROFILE_12A-1; break;
      case DSL_G997_PROFILES_12B: nTargetProfileId = AVX_VDSL_PROFILE_12B-1; break;
      case DSL_G997_PROFILES_8A:  nTargetProfileId = AVX_VDSL_PROFILE_8A-1;  break;
      case DSL_G997_PROFILES_8B:  nTargetProfileId = AVX_VDSL_PROFILE_8B-1;  break;
      case DSL_G997_PROFILES_8C:  nTargetProfileId = AVX_VDSL_PROFILE_8C-1;  break;
      case DSL_G997_PROFILES_8D:  nTargetProfileId = AVX_VDSL_PROFILE_8D-1;  break;
      default:
         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfile);
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: Unknown target profile %u!" DSL_CRLF, nLine, nTargetProfile));
         return errorCode;
   }

   errorCode = DSL_VdslUS0DisablingGet(pContext, nLine, nTargetProfileId, &sBandListUs, &nUS0Disabling);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfile);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_VdslUS0DisablingGet failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   /* switch back to the profile 8 */
   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfile);

   /* determine if we should take into account the US0 or not */
   if ((DSL_Us0Disabling_t)nUS0Disabling == DSL_US0DISABLING_ON)
      indexUs = ((sBandListUs.nNumData < 2)?sBandListUs.nNumData:2)-1;
   else
      indexUs = ((sBandListUs.nNumData < 3)?sBandListUs.nNumData:3)-1;

   /* find the lower US2 band edge of the target profile */
   us2StartTone = sBandListUs.nBand[indexUs].nFirstToneIndex;

   if ((highestUsableTone > DSL_MAX(highestTone, us2StartTone)) &&
      ((highestUsableTone - DSL_MAX(highestTone, us2StartTone)) > DSL_DELTA_NUM_US_TONE_GAP))
   {
      freqHighestUsCheck = DSL_TRUE;
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: Do a profile switching if better US performance can be achieved without DS loss (highestUsableTone = %u)!" DSL_CRLF, nLine, highestUsableTone));
   }

   pNextBat = (DSL_G997_NSCData8_t *) DSL_Malloc(sizeof(DSL_G997_NSCData8_t));
   if (pNextBat == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_Malloc(%d) failed!" DSL_CRLF, nLine, 
         (DSL_int_t)sizeof(DSL_G997_NSCData8_t)));
      return DSL_ERROR;
   }

   errorCode = DSL_AVX_Eaps2BatApproximate(pContext, nLine, nProfile, nTargetProfile, pBat, pNextBat);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pNextBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2BatApproximate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                  pContext, nLine, pNextBat,
                  nProfile, nProfile, nTargetProfile,
                  &lineRatePlus);

   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
      return DSL_SUCCESS;
   }

   errorCode = DSL_AVX_Eaps2DeltaLineRateCalculate(pContext, nLine, pBat, nProfile, nTargetProfile, &lineRate);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRateCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   if (nTargetProfile == DSL_G997_PROFILES_30A)
   {
      if (nProfileMask & DSL_G997_PROFILES_17A)
      {
         DSL_int_t lineRate17Plus = 0;

         errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                        pContext, nLine, pNextBat,
                        nProfile, DSL_G997_PROFILES_17A, DSL_G997_PROFILES_30A,
                        &lineRate17Plus);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pNextBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         if ((lineRatePlus + lineRate >= (DSL_int_t) deltaDataRateGap) && (lineRate17Plus > 0))
         {
            bDoRetrain = DSL_TRUE;
         }
      }
      else if (nProfileMask & DSL_G997_PROFILES_12A)
      {
         DSL_int_t lineRate12Plus = 0;

         errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                        pContext, nLine, pNextBat,
                        nProfile, DSL_G997_PROFILES_12A, DSL_G997_PROFILES_30A,
                        &lineRate12Plus);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pNextBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         if ((lineRatePlus + lineRate >= (DSL_int_t) deltaDataRateGap) && (lineRate12Plus > 0))
         {
            bDoRetrain = DSL_TRUE;
         }
      }
      else if (lineRatePlus + lineRate >= (DSL_int_t) deltaDataRateGap)
      {
         bDoRetrain = DSL_TRUE;
      }
   }
   else if (nTargetProfile == DSL_G997_PROFILES_17A)
   {
      if (nProfileMask & DSL_G997_PROFILES_30A)
      {
         DSL_int_t lineRate17Plus = 0;

         errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                        pContext, nLine, pNextBat,
                        nProfile, DSL_G997_PROFILES_17A, DSL_G997_PROFILES_30A,
                        &lineRate17Plus);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pNextBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         if ((lineRate17Plus == 0) &&
             ((lineRatePlus + lineRate >= (DSL_int_t) deltaDataRateGap) ||
             ((lineRatePlus + lineRate >= 0) && (freqHighestUsCheck == DSL_TRUE))))
         {
            bDoRetrain = DSL_TRUE;
         }
      }
      else if ((lineRatePlus + lineRate >= (DSL_int_t) deltaDataRateGap) ||
              ((lineRatePlus + lineRate >= 0) && (freqHighestUsCheck == DSL_TRUE)))
      {
         bDoRetrain = DSL_TRUE;
      }
   }
   else if (nTargetProfile == DSL_G997_PROFILES_12A || nTargetProfile == DSL_G997_PROFILES_12B)
   {
      if (! (nProfileMask & DSL_G997_PROFILES_17A) && (nProfileMask & DSL_G997_PROFILES_30A))
      {
         DSL_int_t lineRate12Plus = 0;

         errorCode = DSL_AVX_Eaps2DeltaLineRatePlusCalculate(
                        pContext, nLine, pNextBat,
                        nProfile, DSL_G997_PROFILES_12A, DSL_G997_PROFILES_30A,
                        &lineRate12Plus);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pNextBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2DeltaLineRatePlusCalculate failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         if ((lineRate12Plus == 0) &&
             ((lineRatePlus + lineRate >= (DSL_int_t) deltaDataRateGap) ||
             ((lineRatePlus + lineRate >= 0) && (freqHighestUsCheck == DSL_TRUE))))
         {
            bDoRetrain = DSL_TRUE;
         }
      }
      else if ((lineRatePlus + lineRate >= (DSL_int_t) deltaDataRateGap) ||
              ((lineRatePlus + lineRate >= 0) && (freqHighestUsCheck == DSL_TRUE)))
      {
         bDoRetrain = DSL_TRUE;
      }
   }

   if (bDoRetrain == DSL_TRUE)
   {
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nTargetProfile);
      *bRetrain = DSL_TRUE;

      errorCode = DSL_AVX_Eaps2CalculateNextProfileDsMemPortion(pContext, nLine, pBat, nProfile, nTargetProfile);
      if ( errorCode != DSL_SUCCESS )
      {
         DSL_Free(pNextBat);
         DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_AVX_Eaps2CalculateNextProfileDsMemPortion failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }
   }

   DSL_Free(pNextBat);

   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D3Check(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_G997_NSCData8_t *pBat;
   DSL_uint8_t nProfileMask;
   DSL_uint8_t nProfile;
   DSL_uint32_t nBitsPerSymbol = 0;
   DSL_uint32_t *pBitsPerSymbol = DSL_NULL;
   DSL_uint32_t nMaxNetDataRate = 0, nActLineDataRate = 0, nActNetDataRate = 0, nDeltaDataRateGap = 0;
   DSL_uint8_t *pFeXtse = &pContext->G997.FeLineInventory[nLine].ATSECapabilities[0];

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2D3Check" DSL_CRLF, nLine));

   nProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);
   nProfileMask = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE);

   DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: Eaps2 D3: current 0x%02x, mask 0x%02x" DSL_CRLF, 
      nLine, nProfile, nProfileMask));

   nMaxNetDataRate = DSL_UINT32_GET(DSL_DBC_MAX_DATARATE_DS)/1000;
   nActLineDataRate = DSL_UINT32_GET(DSL_DBS_ACTLINERATE_DS)/1000;
   nActNetDataRate = DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_DS)/1000;
   nDeltaDataRateGap = DSL_UINT32_GET(DSL_DBI_EAPS2_DELTA_DATA_RATE_GAP);
   
   if ((nActLineDataRate > 0) && 
       ((DSL_uint32_t) DSL_ABS((DSL_int32_t)(nMaxNetDataRate - nActNetDataRate)) < 
         ((nActNetDataRate*nDeltaDataRateGap)/nActLineDataRate)))
   {
      *bRetrain = DSL_FALSE;
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: Final profile reached!" DSL_CRLF, nLine));
      return DSL_SUCCESS;
   }

   pBat = (DSL_G997_NSCData8_t *) DSL_Malloc(sizeof(DSL_G997_NSCData8_t));
   if (pBat == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_Malloc(%d) failed!" DSL_CRLF, nLine, 
         (DSL_int_t)sizeof(DSL_G997_NSCData8_t)));
      return DSL_ERROR;
   }

   if (DSL_DBG_MSG <= DSL_g_dbgLvl[DSL_DBG_BLOCK].nDbgLvl)
      pBitsPerSymbol = &nBitsPerSymbol;
   errorCode = DSL_AVX_BitAllocationTableGet(pContext, nLine, DSL_DOWNSTREAM, pBat, pBitsPerSymbol, DSL_NULL);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_Free(pBat);
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_BitAllocationTableGet failed: %d" DSL_CRLF, nLine, errorCode));
      return errorCode;
   }

   /* make sure that CPE capabilities were retrieved before switching to a lower profile */
   nRet = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   nRet = DSL_AVX_SendMsgStandardInfoFeVdsl2Get(pContext, nLine);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);
   
   if ((nProfile == DSL_G997_PROFILES_17A) && 
       (nProfileMask & DSL_G997_PROFILES_30A) &&
       (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET1_FE) & DSL_G997_PROFILES_30A))
   {
      errorCode = DSL_AVX_Eaps2D3_17_30(pContext, nLine, pBat, nProfile, nProfileMask, bRetrain);

      if (errorCode != DSL_SUCCESS)
      {
         DSL_Free(pBat);
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2D3_17_30 failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: Eaps2 D3: switch 17A to 30A %s" DSL_CRLF, nLine, *bRetrain ? "OK" : "NOK"));

      if (*bRetrain)
      {
         DSL_Free(pBat);
         return DSL_SUCCESS;
      }
   }

   if (nProfile == DSL_G997_PROFILES_12A || nProfile == DSL_G997_PROFILES_12B)
   {
      if ((nProfileMask & DSL_G997_PROFILES_30A) &&
          (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET1_FE) & DSL_G997_PROFILES_30A))
      {
         errorCode = DSL_AVX_Eaps2D3_12_30(pContext, nLine, pBat, nProfile, nProfileMask, bRetrain);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2D3_12_30 failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: Eaps2 D3: switch 12A to 30A %s" DSL_CRLF, nLine, *bRetrain ? "OK" : "NOK"));

         if (*bRetrain)
         {
            DSL_Free(pBat);
            return DSL_SUCCESS;
         }
      }

      if ((nProfileMask & DSL_G997_PROFILES_17A) &&
          (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET1_FE) & DSL_G997_PROFILES_17A))
      {
         errorCode = DSL_AVX_Eaps2D3_12_17(pContext, nLine, pBat, nProfile, nProfileMask, bRetrain);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2D3_12_17 failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: Eaps2 D3: switch 12A to 17A %s" DSL_CRLF, nLine, *bRetrain ? "OK" : "NOK"));

         if (*bRetrain)
         {
            DSL_Free(pBat);
            return DSL_SUCCESS;
         }
      }
   }

   if (nProfile == DSL_G997_PROFILES_8A || nProfile == DSL_G997_PROFILES_8B)
   {
      if ((nProfileMask & DSL_G997_PROFILES_30A) &&
          (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET1_FE) & DSL_G997_PROFILES_30A))
      {
         errorCode = DSL_AVX_Eaps2D3_8_XX(pContext, nLine, pBat, nProfile, DSL_G997_PROFILES_30A, nProfileMask, bRetrain);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2D3_8_XX failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: Eaps2 D3: switch %s to 30A %s" DSL_CRLF,
            nLine, DSL_AVX_ProfileName(nProfile), *bRetrain ? "OK" : "NOK"));

         if (*bRetrain)
         {
            DSL_Free(pBat);
            return DSL_SUCCESS;
         }
      }

      if ((nProfileMask & DSL_G997_PROFILES_17A) &&
          (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET1_FE) & DSL_G997_PROFILES_17A))
      {
         errorCode = DSL_AVX_Eaps2D3_8_XX(pContext, nLine, pBat, nProfile, DSL_G997_PROFILES_17A, nProfileMask, bRetrain);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2D3_8_XX failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: Eaps2 D3: switch %s to 17A %s" DSL_CRLF,
            nLine, DSL_AVX_ProfileName(nProfile), *bRetrain ? "OK" : "NOK"));

         if (*bRetrain)
         {
            DSL_Free(pBat);
            return DSL_SUCCESS;
         }
      }
      else if ((nProfileMask & (DSL_G997_PROFILES_12A | DSL_G997_PROFILES_12B)) &&
               (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET1_FE) & (DSL_G997_PROFILES_12A | DSL_G997_PROFILES_12B)))
      {
         DSL_uint8_t nTargetProfile;

         if (nProfileMask & DSL_G997_PROFILES_12A)
         {
            nTargetProfile = DSL_G997_PROFILES_12A;
         }
         else
         {
            nTargetProfile = DSL_G997_PROFILES_12B;
         }

         errorCode = DSL_AVX_Eaps2D3_8_XX(pContext, nLine, pBat, nProfile, nTargetProfile, nProfileMask, bRetrain);

         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2D3_8_XX failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: Eaps2 D3: switch %s to 12A %s" DSL_CRLF,
            nLine, DSL_AVX_ProfileName(nProfile), *bRetrain ? "OK" : "NOK"));

         if (*bRetrain)
         {
            DSL_Free(pBat);
            return DSL_SUCCESS;
         }
      }
   }

   if (nProfile != DSL_G997_PROFILES_8A && nProfile != DSL_G997_PROFILES_8B)
   {
      if ((nProfileMask & (DSL_G997_PROFILES_8A | DSL_G997_PROFILES_8B)) &&
          (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET1_FE) & (DSL_G997_PROFILES_8A | DSL_G997_PROFILES_8B)))
      {
         errorCode = DSL_AVX_Eaps2D3SwitchTo8Check(pContext, nLine, pBat, nProfile, nProfileMask, bRetrain);
         if (errorCode != DSL_SUCCESS)
         {
            DSL_Free(pBat);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2D3SwitchTo8Check failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: Eaps2 D3: switch %s to 8A/B %s" DSL_CRLF,
            nLine, DSL_AVX_ProfileName(nProfile), *bRetrain ? "OK" : "NOK"));

         if (*bRetrain)
         {
            DSL_Free(pBat);
            return DSL_SUCCESS;
         }
      }
   }

   if ( DSL_G997_IsAdslConfigured(pContext, nLine) && 
      ((DSL_UINT8_GET(DSL_DBL_ATSE_1) & pFeXtse[0]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_2) & pFeXtse[1]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_3) & pFeXtse[2]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_4) & pFeXtse[3]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_5) & pFeXtse[4]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_6) & pFeXtse[5]) ||
       (DSL_UINT8_GET(DSL_DBL_ATSE_7) & pFeXtse[6])))
   {
      errorCode = DSL_AVX_Eaps2D3AdslCheck(pContext, nLine, nProfile, pBat, bRetrain);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2D3AdslCheck failed: %d!" DSL_CRLF, nLine, errorCode));
      }
   }

   DSL_Free(pBat);

   if (*bRetrain)
   {
      return DSL_SUCCESS;
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D4Check(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain)
{
   static const DSL_int32_t nSlopeRequired = -4260; /* -4259,84 = -0.065 * 0x10000; */
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_int32_t nSlope = 0;
   DSL_uint8_t nProfileMask;
   DSL_uint32_t nMaxNetDataRate = 0, nActLineDataRate = 0, nActNetDataRate = 0, nDeltaDataRateGap = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2D4Check" DSL_CRLF, nLine));

   nMaxNetDataRate = DSL_UINT32_GET(DSL_DBC_MAX_DATARATE_DS)/1000;
   nActLineDataRate = DSL_UINT32_GET(DSL_DBS_ACTLINERATE_DS)/1000;
   nActNetDataRate = DSL_UINT32_GET(DSL_DBSC_ACT_DATARATE_DS)/1000;
   nDeltaDataRateGap = DSL_UINT32_GET(DSL_DBI_EAPS2_DELTA_DATA_RATE_GAP);
   
   if ((nActLineDataRate > 0) && 
       ((DSL_uint32_t) DSL_ABS((DSL_int32_t)(nMaxNetDataRate - nActNetDataRate)) < ((nActNetDataRate*nDeltaDataRateGap)/nActLineDataRate)))
   {
      *bRetrain = DSL_FALSE;
      DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: Final profile reached!" DSL_CRLF, nLine));
      return DSL_SUCCESS;
   }

   nProfileMask = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE);
   if (! (nProfileMask & (DSL_G997_PROFILES_8A | DSL_G997_PROFILES_8B)))
   {
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: Eaps2 D4: 8A/B unavailable, stay in ADSL" DSL_CRLF, nLine));
      return DSL_SUCCESS;
   }

   nRet = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   /* check for VDSL2 support */
   if ((DSL_UINT8_GET(DSL_DBS_SPAR1_5) & 0x20) == 0x00)
   {
      /* far end supports ADSL only, stay here */
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2D4Check: "
         "Hs FE Caps does not support VDSl2" DSL_CRLF ,
         nLine));

      *bRetrain = DSL_FALSE;
      return errorCode;
   }

   /* far end supports VDSL2 also,
      calculate slope from BAT and decide */
   nRet = DSL_AVX_EapsBatSlopeCalculate(pContext, nLine, &nSlope);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   if (nSlope <= nSlopeRequired)
   {
      /* slope is fine, stay here */
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2D4Check- "
         "BAT slope is ok for ADSL" DSL_CRLF ,
         nLine));
      *bRetrain = DSL_FALSE;
      return errorCode;
   }

   /* configure the lowest VDSL profile */
   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, 0);
   DSL_AVX_Eaps2NextHigherProfileSet(pContext, nLine);

   *bRetrain = DSL_TRUE;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2D4Check - "
      "BAT slope flat, try VDSL" DSL_CRLF ,
      nLine));

   return DSL_SUCCESS;
}

/**
   Do the Enhanced Auto Profile Selection 2 when SHOWTIME was entered.
   Based on some status parameters the line is reconfigured or not.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Specifies on which line the message was received, [I]
   \param bRetrain   Returns the decision to retrain or not, [O]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2ShowtimeDecision(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   static DSL_uint16_t nChannel = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2ShowtimeDecision" DSL_CRLF, nLine));

   /* request Operation State first (DSL-mode, Annex...) */
   nRet = DSL_AVX_SendMsgVtseStatusGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during VTSE Status Get!" DSL_CRLF, nLine);

   /* for ADSL-only mode */
   if (! DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      errorCode = DSL_AVX_Eaps2D4Check(pContext, nLine, bRetrain);

      if (*bRetrain == DSL_FALSE)
      {
         DSL_AVX_Eaps2FsmStateSet(pContext, nLine, DSL_EAPS2_FINISHED);
      }
   }
   
   /* VDSL D3 is done by DSL_AVX_OnDeltInventoryAvailable */
   DSL_UINT8_SET(DSL_DBS_DELT_INVENTORY_AVAILABLE, DSL_FALSE);

   return errorCode;
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

DSL_LOCAL DSL_void_t DSL_AVX_OnFeStatusAvailable(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_boolean_t bRestart = DSL_FALSE;
   DSL_Eaps2States_t nEaps2States = DSL_EAPS2_LAST;
   DSL_uint16_t nDsMemPortionRtx = 0, nDsMemPortionRtxDsUs = 0, nDsMemPortionIfec = 0;
   DSL_uint8_t nLastProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_OnFeStatusAvailable" DSL_CRLF, nLine));

   nDsMemPortionRtx = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION);
   nDsMemPortionRtxDsUs = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION);
   nDsMemPortionIfec = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION);

   nEaps2States = DSL_AVX_Eaps2FsmStateGet(pContext, nLine);

   errorCode = DSL_AVX_MemSplitRetrainCheck(pContext, nLine, &bRestart);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: Error during EAPS2 D5 check!" DSL_CRLF, nLine));
   }

   if (bRestart == DSL_FALSE)
   {
      if (nEaps2States == DSL_EAPS2_ACTIVATE)
      {
         DSL_AVX_Eaps2FsmStateSet(pContext, nLine, DSL_EAPS2_FINISHED);
         DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: Eaps2 finished" DSL_CRLF, nLine));

         /* reset valid profile mask */
         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_FAILED, 0);
         DSL_UINT8_SET(DSL_DBL_ADSL_PROFILE_FAILED, DSL_FALSE);
      }
   }
   else
   {
      /* retrain due to MemSplit optimization */
      if (nEaps2States == DSL_EAPS2_ACTIVATE)
      {
         /* Store last successful profile and MemSplit due to D5 */
         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_LAST, nLastProfile);

         DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION_LAST, nDsMemPortionRtx);
         DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION_LAST, nDsMemPortionRtxDsUs);
         DSL_UINT16_SET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION_LAST, nDsMemPortionIfec); 

         DSL_UINT8_SET(DSL_DBS_EAPS2_RETRAIN_MODE, DSL_FALSE);
         DSL_AVX_Eaps2Retrain(pContext, nLine, DSL_NULL);
      }
      else
      {
         /* MemSplit retrain could also be done without EAPS2*/
         DSL_UINT8_SET(DSL_DBS_MEMSPLIT_RETRAIN_MODE, DSL_TRUE);
         DSL_UINT8_SET(DSL_DBS_EAPS2_RETRAIN_MODE, DSL_FALSE);
         DSL_AVX_RequestIdle(pContext, nLine, DSL_FALSE);
      }
   }


#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
   return;
}

DSL_LOCAL DSL_void_t DSL_AVX_OnDeltInventoryAvailable(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   static const DSL_uint8_t nChannel = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_OnDeltInventoryAvailable" DSL_CRLF, nLine));

   /* do EAPS2 D3 and D5 checks, but only in VDSL case */
   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      DSL_Error_t errorCode = DSL_SUCCESS;
      DSL_boolean_t bRestart = DSL_FALSE;
      DSL_Eaps2States_t nEaps2States = DSL_EAPS2_LAST;
      DSL_boolean_t bD5CheckShifted = DSL_FALSE;
      DSL_uint16_t nDsMemPortionRtx = 0, nDsMemPortionRtxDsUs = 0, nDsMemPortionIfec = 0;
      DSL_uint8_t nLastProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);

      nDsMemPortionRtx = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION);
      nDsMemPortionRtxDsUs = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION);
      nDsMemPortionIfec = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION);

      nEaps2States = DSL_AVX_Eaps2FsmStateGet(pContext, nLine);
      if (nEaps2States == DSL_EAPS2_ACTIVATE)
      {
         /* get status and make decision */
         DSL_DBG_EAPS2_D3Mode_t nD3Mode;
         nD3Mode = (DSL_DBG_EAPS2_D3Mode_t)DSL_UINT8_GET(DSL_DBI_EAPS2_CFG_D3_MORE);

         if ((nD3Mode == DSL_DBG_EAPS2_D3_ALLWAYS) ||
            ((nD3Mode == DSL_DBG_EAPS2_D3_ONCE) && (DSL_UINT8_GET(DSL_DBS_EAPS2_RECONF_COUNT) == 0)))
            errorCode = DSL_AVX_Eaps2D3Check(pContext, nLine, &bRestart);

         if (errorCode == DSL_SUCCESS)
         {
            DSL_UINT8_SET(DSL_DBS_EAPS2_RECONF_COUNT, 1);
            if (bRestart == DSL_FALSE)
            {
               if ( DSL_UINT8_GET(DSL_DBL_EAPS2_D3_RETRAIN) == DSL_FALSE )
               {
                  DSL_uint8_t bMemSplitRetrain = DSL_FALSE;
                  DSL_int8_t nMemPortion = -1;

                  bMemSplitRetrain = DSL_UINT8_GET(DSL_DBS_EAPS2_RETRAIN_MODE);
                  nMemPortion = DSL_INT8_GET(DSL_DBL_EAPS2_DS_MEM_PORTION);

                  if (bMemSplitRetrain && nMemPortion == -1)
                  {
                     bD5CheckShifted = DSL_TRUE;
                     DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: Eaps2 D5 check shifted" DSL_CRLF, nLine));
                  }
               }

               DSL_UINT8_SET(DSL_DBL_EAPS2_D3_RETRAIN, DSL_FALSE);
            }
            else
            {
               /* Store last successful profile and MemSplit due to D3 */
               DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_LAST, nLastProfile);

               DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION_LAST, nDsMemPortionRtx);
               DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION_LAST, nDsMemPortionRtxDsUs);
               DSL_UINT16_SET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION_LAST, nDsMemPortionIfec); 

               DSL_UINT8_SET(DSL_DBL_EAPS2_D3_RETRAIN, DSL_TRUE);
            }
         }

         if (bD5CheckShifted == DSL_FALSE)
         {
            if (bRestart == DSL_FALSE)
            {
               DSL_AVX_Eaps2FsmStateSet(pContext, nLine, DSL_EAPS2_FINISHED);
               DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: Eaps2 finished" DSL_CRLF, nLine));

               /* reset valid profile mask */
               DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_FAILED, 0);
               DSL_UINT8_SET(DSL_DBL_ADSL_PROFILE_FAILED, DSL_FALSE);
            }
            else
            {
               DSL_UINT8_SET(DSL_DBS_EAPS2_RETRAIN_MODE, DSL_FALSE);
               DSL_AVX_Eaps2Retrain(pContext, nLine, DSL_NULL);
            }
         }
      }
      else if (nEaps2States == DSL_EAPS2_DISABLED)
      {
         if ((DSL_MemPartRetrain_t)DSL_UINT8_GET(DSL_DBL_MEMSPLIT_RETRAIN_CFG) == DSL_MEMPART_RETRAIN_ON)
         {
            errorCode = DSL_AVX_MemSplitRetrainCheck(pContext, nLine, &bRestart);
            if (errorCode != DSL_SUCCESS)
            {
               DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: Error during EAPS2 D5 check!" DSL_CRLF, nLine));
            }
         }
      }
   }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
   return;
}

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_avinax.h'
*/
DSL_Error_t DSL_AVX_Eaps2ProfileCheck(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_BandPlanConfig_t sBandPlanConfig;
   DSL_AVX_FwVersion_t *pFwVersion;

   DSL_uint8_t nProfileMask, nOriginalMask;
   DSL_uint8_t nProfile;
   int n;

   DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2ProfileCheck" DSL_CRLF, nLine));

   nProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);
   if ((nProfile == 0) && DSL_G997_IsAdslConfigured(pContext, nLine))
   {
      errorCode = DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2InitialProfileSet failed: %d!" DSL_CRLF, nLine, errorCode));
      }

      return errorCode;
   }

   pFwVersion = &pContext->DeviceContext.Ver[nLine].nFwVer;

   nProfileMask = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE);
   nOriginalMask = nProfileMask;

   if ((pFwVersion->nApplication != DSL_APP_VDSL2_ADSL_VINAX_L) &&
       (pFwVersion->nApplication != DSL_APP_VDSL2_ADSL_VINAX_L_V))
   {
      if (nProfileMask & 0x80)
      {
         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: vdsl profile 0x%02x is unsupported by firmware!" DSL_CRLF, nLine, 0x80));

         nProfileMask &= 0x7f;
      }
   }

   nProfile = 1;
   for (n = 0; n < 8; n++)
   {
      if (nProfile & nProfileMask)
      {
         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfile);

         errorCode = DSL_VdslBandPlanFromClassLimitGet(pContext, nLine, &sBandPlanConfig);
         if (errorCode != DSL_SUCCESS || DSL_DEV_BandPlanSupportedCheck(pContext, &sBandPlanConfig) == DSL_FALSE)
         {
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "DSL[%02d]: vdsl profile 0x%02x is unsupported!" DSL_CRLF, nLine, nProfile));

            nProfileMask ^= nProfile;
         }
      }

      nProfile <<= 1;
   }

   if (nProfileMask != nOriginalMask)
   {
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE, nProfileMask);
   }

   if (nProfileMask == 0)
   {
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, 0);

      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: vdsl profile mask is empty" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   /* next function initializes DSL_DBL_VDSL_PROFILE_CURRENT */
   errorCode = DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
   if (errorCode != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2InitialProfileSet failed: %d!" DSL_CRLF, nLine, errorCode));
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_Eaps2ProfileCheck: 0x%02x -> 0x%02x" DSL_CRLF, nLine, nOriginalMask, nProfileMask));

   return DSL_SUCCESS;
}

/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_device.h'
*/
DSL_Error_t DSL_AVX_Eaps2CurrentProfileGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_uint8_t *pProfile)
{
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_int_t nChannel = 0;
   DSL_uint8_t nProfile;

   nProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);

   if (nProfile == 0)
   {
      /* profile check */
      errorCode = DSL_AVX_Eaps2ProfileCheck(pContext, nLine);

      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2ProfileCheck failed: %d!" DSL_CRLF, nLine, errorCode));
         return errorCode;
      }

      nProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);
   }

   *pProfile = nProfile;

   return errorCode;
#else
   return DSL_ERR_NOT_SUPPORTED;
#endif /* defined(INCLUDE_DSL_API_VDSL_SUPPORT) */
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2D2CheckSend(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t cdCheck)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_boolean_t currentCdCheck;
   AVX_CmdApsControlSet_t sCmd;

   currentCdCheck = (DSL_boolean_t)DSL_UINT8_GET(DSL_DBS_EAPS2_D2_CHECK);

   cdCheck = (DSL_boolean_t)(cdCheck && currentCdCheck);

   {
      memset(&sCmd, 0, sizeof(sCmd));

      if (cdCheck == DSL_FALSE)
      {
         sCmd.Control_Dis |= AVX_8827_APS_CDCHECK_DIS_MASK;
      }
      else
      {
         sCmd.Control_Ena |= AVX_8827_APS_CDCHECK_ENA_MASK | AVX_8827_APS_CDCHECK_ABORT_ENA_MASK;
      }

      errorCode = DSL_AVX_SendMessage(pContext,
                     nLine, MSGID_EXT(AVX_CMD_APS_CONTROL_SET),
                     sizeof(sCmd), (DSL_uint8_t *) &sCmd,
                     0, DSL_NULL);

      if (errorCode != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext,
            "DSL[%02d]: DSL_AVX_SendMessage AVX_CMD_APS_CONTROL failed" DSL_CRLF, nLine));
         return errorCode;
      }

      DSL_UINT8_SET(DSL_DBS_EAPS2_D2_CHECK, cdCheck);
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2OnFail(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain)
{
   const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS, nRet;
   DSL_Eaps2States_t nState;
   DSL_uint8_t nCurrentProfile;
   DSL_boolean_t bReconf = DSL_FALSE, bCapsValid = DSL_TRUE, 
               bAdslProfileFailed = DSL_FALSE, bVectoringSupported = DSL_FALSE;
   DSL_uint16_t nSubErrorCode;
   DSL_uint8_t nFwFailCount = 0, nFailCount = 0;
   AVX_AckModemFsmStateGet_t sAck;
   DSL_DEV_LineState_t nPreLineState = DSL_LINESTATUS_NOT_INITIALIZED;
   DSL_uint8_t nLastProfile = 0xFF /* set to a special value */, nProfileFailed;
   DSL_uint16_t nLastFwFailCode = 0;

   nState = DSL_AVX_Eaps2FsmStateGet(pContext, nLine);
   nCurrentProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);
   bAdslProfileFailed = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_ADSL_PROFILE_FAILED));

   /* if line is stopped for retrain also FAIL will be reported,
      ignore this */
   if ((nState == DSL_EAPS2_DISABLED) || (nState == DSL_EAPS2_RETRAIN))
      return errorCode;

   nSubErrorCode = (DSL_uint16_t)DSL_UINT8_GET(DSL_DBS_DEV_LAST_SUB_ERROR_CODE);
   nLastFwFailCode = DSL_UINT16_GET(DSL_DBS_DEV_LAST_FW_FAIL_CODE);
   
   /* skip reset done by DMS or PowerSavings */
   if (((nSubErrorCode == AVX_S_OK) && (DSL_UINT8_GET(DSL_DBS_DEV_LAST_EXCEPTION) == AVX_E_UNKNOWN) && 
        (nLastFwFailCode == 0x197)) || 
       (nLastFwFailCode == 0x232))
   {
      /* DSLCOSW-2985:  
         0x0232 Special power mode triggered by DSL API followed by IDLE 
            -> ignore
         0x0233 Special power mode triggered by DSL API followed by SILENT 
            -> handle as FW-fail below*/
      DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2OnFail: "
         "FwFailCode 0x%x ignored." DSL_CRLF, nLine, nLastFwFailCode));
      return errorCode;
   }

   if (nState == DSL_EAPS2_FINISHED)
   {
      DSL_AVX_Eaps2FsmReset(pContext, nLine);
      DSL_AVX_Eaps2FsmStateSet(pContext, nLine, DSL_EAPS2_RETRAIN);
      DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
      bReconf = DSL_TRUE;
   }
   else
   {
      /* make sure that CPE capabilities were retrieved before switching to a lower profile */
      nRet = DSL_AVX_SendMsgHsFeCapsGet(pContext, nLine);
      DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

      nFailCount = DSL_UINT8_GET(DSL_DBS_EAPS2_FAIL_COUNT);
      nFwFailCount = DSL_UINT8_GET(DSL_DBS_EAPS2_FW_FAIL_COUNT);

      if (( nSubErrorCode == AVX_S_APS_XDSL_MODE ) ||
          ( nSubErrorCode == AVX_S_HW_MODE ) ||
          (nLastFwFailCode == 0x233))
      {
         nFwFailCount++;

         DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2OnFail: "
            "EAPS2 nFwFailCount = %u" DSL_CRLF, nLine, nFwFailCount));
      }
      else if ( nSubErrorCode == AVX_S_MODE )
      {
         DSL_uint8_t *pFeXtse = &pContext->G997.FeLineInventory[nLine].ATSECapabilities[0];

         /* current opmode is VDSL2 and this is supporting by CPE */
         if ((DSL_UINT8_GET(DSL_DBS_SPAR1_5) & 0x20) && nCurrentProfile)
         {
            nRet = DSL_AVX_SendMsgStandardInfoFeVdsl2Get(pContext, nLine);
            if (nRet < DSL_SUCCESS)
               bCapsValid = DSL_FALSE;

            if (bCapsValid)
            {
               nRet = DSL_AVX_SendMsgModemStateGet( pContext, nLine, &sAck);
               if ((nRet < DSL_SUCCESS) || (DSL_AVX_PARA32_GET(sAck.ModemState) >= AVX_INIT_HS_MASK))
                  bCapsValid = DSL_FALSE;
            }

            /* Since the FW is clearing previous CPE caps. after getting to the GHS
               check if the CPE caps. are still reliable
               also check if the current profile is supporting by CPE */
            if ((bCapsValid == DSL_FALSE) ||
                (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET1_FE) & nCurrentProfile))
            {
               nFailCount++;

               DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2OnFail: "
                  "EAPS2 ('common' mode) nFailCount = %u" DSL_CRLF, nLine, nFailCount));
            }
            else
            {
               DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2OnFail: "
                  "EAPS2 ('no common' mode) switch to a lower profile" DSL_CRLF, nLine));
                  
               /* reconfigure with the lower profile */
               bReconf = DSL_TRUE;
               
               /* determine vectored mode G.993.5 or vectoring friendly mode G.993.2 Annex X/Y */
               if ((DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET6_FE) & (AVX_03CC_VECTORING_US_SUP_MASK | AVX_03CC_VECTORING_DS_SUP_MASK)) ||
                   (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET7_FE) & (AVX_03CC_VECTORFRIENDLY_USDS_SUP_MASK | AVX_03CC_VECTORFRIENDLY_DS_SUP_MASK)))
               {
                  bVectoringSupported = DSL_TRUE;
               }

               /* vectoring configured, but CPE doesn't support not vectored nor vectoring friendly modes */
               if (DSL_G997_IsVdslConfigured(pContext, nLine) && ! bVectoringSupported)
               {
                  if (DSL_G997_IsAdslConfigured(pContext, nLine))
                  {
                     DSL_AVX_VdslDisable(pContext, nLine);
                  }
               }
               else
               {
                  /* Find out the next lower profile */
                  DSL_AVX_Eaps2NextLowerProfileSet(pContext, nLine, DSL_TRUE);
               }
            }
         }
         else if (((DSL_UINT8_GET(DSL_DBL_ATSE_1) & pFeXtse[0]) ||
                   (DSL_UINT8_GET(DSL_DBL_ATSE_2) & pFeXtse[1]) ||
                   (DSL_UINT8_GET(DSL_DBL_ATSE_3) & pFeXtse[2]) ||
                   (DSL_UINT8_GET(DSL_DBL_ATSE_4) & pFeXtse[3]) ||
                   (DSL_UINT8_GET(DSL_DBL_ATSE_5) & pFeXtse[4]) ||
                   (DSL_UINT8_GET(DSL_DBL_ATSE_6) & pFeXtse[5]) ||
                   (DSL_UINT8_GET(DSL_DBL_ATSE_7) & pFeXtse[6])) && nCurrentProfile)
         {
            /* current opmode is VDSL2 but this is not supporting by CPE,
               ADSL is configured and supported by CPE */

            if (bAdslProfileFailed == DSL_TRUE)
            {
               /* ADSL mode was failed before, restart */
               DSL_AVX_VdslRestore(pContext, nLine);
               errorCode = DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
            }
            else
            {
               /* disable VDSL */
               DSL_AVX_VdslDisable(pContext, nLine);
            }
            
            /* reconfigure in ADSL */
            bReconf = DSL_TRUE;

            DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2OnFail: "
               "EAPS2 ('no common' mode) switch to a lower profile" DSL_CRLF, nLine));
         }
         else
         {
            nFailCount++;

            DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2OnFail: "
               "EAPS2 ('no common' mode) nFailCount = %u" DSL_CRLF, nLine, nFailCount));
         }
      }
      else
      {
         nFailCount++;

         DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2OnFail: "
            "EAPS2 nFailCount = %u" DSL_CRLF, nLine, nFailCount));
      }

      DSL_UINT8_SET(DSL_DBS_EAPS2_FW_FAIL_COUNT, nFwFailCount);
      DSL_UINT8_SET(DSL_DBS_EAPS2_FAIL_COUNT, nFailCount);

      if ((nFwFailCount < 10) && (nFailCount < 3))
      {
         if (nSubErrorCode == AVX_S_APS_XDSL_MODE)
         {
            nCurrentProfile = DSL_UINT8_GET(DSL_DBS_EAPS2_D2_CHECK_PROFILE);

            DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2OnFail: "
               "EAPS2 mode switch due to AVX_S_APS_XDSL_MODE, "
               "new profile 0x%x" DSL_CRLF, nLine, nCurrentProfile));
            /* Update the current profile in case of a reconfiguration due 
               to AVX_APS_XDSL_MODE */
            DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nCurrentProfile);

            /* empty profile means ADSL */
            if (!nCurrentProfile && DSL_G997_IsAdslConfigured(pContext, nLine))
            {
               if (bAdslProfileFailed == DSL_TRUE)
               {
                  /* ADSL mode was failed before, restart */
                  DSL_AVX_VdslRestore(pContext, nLine);
                  errorCode = DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
               }
               else
               {
                  /* disable VDSL */
                  DSL_AVX_VdslDisable(pContext, nLine);
               }
            }

            bReconf = DSL_TRUE;
         }
      }
      else
      {
         DSL_DEBUG( DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_Eaps2OnFail: "
            "EAPS2 mode switch due to fail count, nFwFailCount = %u, nFailCount = %u" DSL_CRLF, 
            nLine, nFwFailCount, nFailCount));

         bReconf = DSL_TRUE;
         
         nPreLineState = (DSL_DEV_LineState_t)(DSL_UINT32_GET(DSL_DBS_PRE_LINESTATE));
         nLastProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_LAST);

         /* set profile to the failed profile mask */
         nProfileFailed = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_FAILED);
         nProfileFailed |= nCurrentProfile;
         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_FAILED, nProfileFailed);

         if (!nCurrentProfile && DSL_G997_IsAdslConfigured(pContext, nLine))
         {
            /* if the failed profile was ADSL - mark this as invalid */
            DSL_UINT8_SET(DSL_DBL_ADSL_PROFILE_FAILED, DSL_TRUE);
         }

         /* Check if APS Showtime Retrain (D3 | D4 | D5) - the last profile shouldn't be equal to a special value */
         if (( nPreLineState == DSL_LINESTATUS_SHOWTIME_TC_SYNC ) && ( nLastProfile != 0xFF ))
         {
            DSL_uint16_t nDsMemPortionIfec = 0, nDsMemPortionRtx = 0, nDsMemPortionRtxDsUs = 0;

            nDsMemPortionRtx = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION_LAST);
            nDsMemPortionRtxDsUs = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION_LAST);
            nDsMemPortionIfec = DSL_UINT16_GET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION_LAST);

            /* Switch to the last succesfull profile & MemSplit */
            DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nLastProfile);

            DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_MEM_PORTION, nDsMemPortionRtx);
            DSL_UINT16_SET(DSL_DBL_EAPS2_DS_RTX_US_MEM_PORTION, nDsMemPortionRtxDsUs);
            DSL_UINT16_SET(DSL_DBL_EAPS2_DS_IFEC_MEM_PORTION, nDsMemPortionIfec); 
            
            /* Reset last profile to a special value */
            DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_LAST, 0xFF);
         }
         /* current opmode is VDSL2 and this is supporting by CPE */
         else if (((DSL_DEV_LineState_t)(DSL_UINT32_GET(DSL_DBS_PRE_LINESTATE)) >= DSL_LINESTATUS_FULL_INIT) &&
              ((DSL_UINT8_GET(DSL_DBS_SPAR1_5) & 0x20) && nCurrentProfile))
         {
            /* Reset Capabilities flag to the inital state */
            bCapsValid = DSL_TRUE;

            nRet = DSL_AVX_SendMsgStandardInfoFeVdsl2Get(pContext, nLine);
            if (nRet < DSL_SUCCESS)
               bCapsValid = DSL_FALSE;

            if (bCapsValid)
            {
               nRet = DSL_AVX_SendMsgModemStateGet( pContext, nLine, &sAck);
               if ((nRet < DSL_SUCCESS) || (DSL_AVX_PARA32_GET(sAck.ModemState) >= AVX_INIT_HS_MASK))
                  bCapsValid = DSL_FALSE;
            }

            /* Since the FW is clearing previous CPE caps. after getting to the GHS
               check if the CPE caps. are still reliable */
            if (bCapsValid)
            {
               /* Reset vectoring support flag */
               bVectoringSupported = DSL_FALSE;

               /* determine vectored mode G.993.5 or vectoring friendly mode G.993.2 Annex X/Y */
               if ((DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET6_FE) & (AVX_03CC_VECTORING_US_SUP_MASK | AVX_03CC_VECTORING_DS_SUP_MASK)) ||
                   (DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET7_FE) & (AVX_03CC_VECTORFRIENDLY_USDS_SUP_MASK | AVX_03CC_VECTORFRIENDLY_DS_SUP_MASK)))
               {
                  bVectoringSupported = DSL_TRUE;
               }

               /* vectoring configured, but CPE doesn't support not vectored nor vectoring friendly modes */
               if (DSL_G997_IsVdslConfigured(pContext, nLine) && ! bVectoringSupported)
               {
                  if (DSL_G997_IsAdslConfigured(pContext, nLine))
                  {
                     DSL_AVX_VdslDisable(pContext, nLine);
                  }
               }
               else
               {
                  /* Find out the next lower profile */
                  DSL_AVX_Eaps2NextLowerProfileSet(pContext, nLine, DSL_TRUE);
               }
            }
            else
            {
               /* Find out the next lower profile */
               DSL_AVX_Eaps2NextLowerProfileSet(pContext, nLine, DSL_FALSE);
            }
         }
         else
         {
            /* Find out the next lower profile */
            DSL_AVX_Eaps2NextLowerProfileSet(pContext, nLine, DSL_FALSE);
         }
      }
   }

   if (bReconf) 
   {  
      DSL_UINT8_SET(DSL_DBS_EAPS2_FW_FAIL_COUNT, 0);
      DSL_UINT8_SET(DSL_DBS_EAPS2_FAIL_COUNT, 0);

      errorCode = DSL_AVX_Eaps2Retrain(pContext, nLine, bRetrain);
   }

   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2Retrain(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t *bRetrain)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
#ifdef INCLUDE_DSL_API_AVINAX_MELT
   const DSL_uint8_t nChannel = 0;
   DSL_Error_t meltIdle;
#endif

   DSL_AVX_Eaps2FsmStateSet(pContext, nLine, DSL_EAPS2_RETRAIN);

#ifdef INCLUDE_DSL_API_AVINAX_MELT
   meltIdle = DSL_MELT_LineIdle(pContext->pMELT_Ctx, nLine);
   if ((meltIdle == DSL_SUCCESS) ||
       (((DSL_MELT_Priority_t) DSL_UINT8_GET(DSL_DBL_MELT_PRIORITY)) == DSL_MELT_PRIORITY_DSL_TRAINING))
#endif /* INCLUDE_DSL_API_AVINAX_MELT */
   {
      if (bRetrain != DSL_NULL)
      {
         *bRetrain = DSL_TRUE;
      }
      else
      {
         return DSL_AVX_RequestIdle(pContext, nLine, DSL_FALSE);
      }
   }
#ifdef INCLUDE_DSL_API_AVINAX_MELT
   else
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: EAPS2 - showtime reached: MELT was activated, "
         "and EPS2 statemachine is interrupted! "
         "(meltIdle=%d, MELT_PRIORITY=%d)" DSL_CRLF,
      nLine, meltIdle, DSL_UINT8_GET(DSL_DBL_MELT_PRIORITY)));
   }
#endif /* INCLUDE_DSL_API_AVINAX_MELT */

   return errorCode;
}
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if defined(INCLUDE_DSL_API_VINAX_R3)
/**
   For a detailed description of the function, its arguments and return value
   please refer to the description in the header file 'lib_dsl_g997_dev.h'
*/
DSL_Error_t DSL_AVX_Eaps2InitialProfileSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS, nRet;
   DSL_uint8_t nProfiles;
   DSL_uint8_t lastBitPos;
   DSL_boolean_t bOpModePreselection;
   DSL_DBG_EAPS2_InitProfile_t nInitialProfile;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_Eaps2InitialProfileSet" DSL_CRLF, nLine));

   bOpModePreselection =
      (DSL_boolean_t)DSL_UINT8_GET(DSL_DBI_EAPS2_OPERATING_MODE_PRESELECTION);
   nInitialProfile     =
      (DSL_DBG_EAPS2_InitProfile_t)DSL_UINT32_GET(DSL_DBI_EAPS2_INIT_PROFILE);

   nProfiles = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE);
   if (nProfiles == 0)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: Vdsl profile bitmask is zero!" DSL_CRLF, nLine));
      return DSL_ERROR;
   }

   if ((nInitialProfile == DSL_DBG_EAPS2_INIT_OFF) ||
      (nInitialProfile == DSL_DBG_EAPS2_INIT_ADSL))
   {
      if (bOpModePreselection)
      {
         /* calculate highest prio profile from table */
         DSL_AVX_APS_PreselectDataTable_t sPreselectTable;
         DSL_uint_t nWeights[AVX_VDSL_PROFILE_30A];
         DSL_uint_t nMaxWeights = 0;
         DSL_AVX_APS_PreselectData_t nEntryMax;
         DSL_int_t i, j;

         memset(&nWeights[0], 0, sizeof(nWeights));
         memset(&nEntryMax, 0, sizeof(nEntryMax));

         nRet = DSL_AVX_Eaps2PreselectionTableGet(pContext, nLine, &sPreselectTable);
         DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

         /* get the max of each parameter */
         for (i=0; i<AVX_VDSL_PROFILE_30A; i++)
         {
            nEntryMax.US0Usage     =
               DSL_MAX(nEntryMax.US0Usage    , sPreselectTable.Entry[i].US0Usage);
            nEntryMax.MaxnomatpDs  =
               DSL_MAX(nEntryMax.MaxnomatpDs , sPreselectTable.Entry[i].MaxnomatpDs);
            nEntryMax.MaxFrequency =
               DSL_MAX(nEntryMax.MaxFrequency, sPreselectTable.Entry[i].MaxFrequency);
         }

         DSL_DEBUG(DSL_DBG_MSG, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2InitialProfileSet: weighted preselction table: " DSL_CRLF
            " US0 | MAXNOMATP | f-Max | weight " DSL_CRLF, nLine));

         /* rate each profile for its maxima */
         for (i=0; i<AVX_VDSL_PROFILE_30A; i++)
         {
            if (nEntryMax.US0Usage == sPreselectTable.Entry[i].US0Usage)
               nWeights[i]++;
            if (nEntryMax.MaxnomatpDs == sPreselectTable.Entry[i].MaxnomatpDs)
               nWeights[i]++;
            if (nEntryMax.MaxFrequency == sPreselectTable.Entry[i].MaxFrequency)
               nWeights[i]++;
            nMaxWeights = DSL_MAX(nMaxWeights, nWeights[i]);
            DSL_DEBUG(DSL_DBG_MSG, (pContext,
               "%01d  |    %03d    | %04d | %01d" DSL_CRLF,
               sPreselectTable.Entry[i].US0Usage,
               sPreselectTable.Entry[i].MaxnomatpDs,
               sPreselectTable.Entry[i].MaxFrequency,
               nWeights[i]  ));
         }

         /* separate three cases:
            - there is is one profile with max in all DSL_EAPS2_PRESELECT_MAX_WEIGHT 
               params the same time: take it
            - there are more profiles with weight DSL_EAPS2_PRESELECT_MAX_WEIGHT: 
               use the lowest profile with weight DSL_EAPS2_PRESELECT_MAX_WEIGHT
            - there is no profile with weight DSL_EAPS2_PRESELECT_MAX_WEIGHT:
               use the highest profile
         */
         if (nMaxWeights == DSL_EAPS2_PRESELECT_MAX_WEIGHT)
         {
            /* if profiles with maximum weight in all params exist, take the lowest. */
            nProfiles = 0;
            for (i=0; i<AVX_VDSL_PROFILE_30A; i++)
               if (nWeights[i] == nMaxWeights)
               {
                  nProfiles = 1 << i;
                  break;
               }
         }
         else
         {
            /* no profile with max in all params, take the highest available */
            nProfiles = 0;
            for (i=AVX_VDSL_PROFILE_30A-1; i>=0; i--)
            {
               if (sPreselectTable.Entry[i].MaxnomatpDs)
               {
                  if (sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_12B)
                  {
                     /* Determine the maximum ATP value of the profiles range: 12A to 12B */
                     memset(&nEntryMax, 0, sizeof(nEntryMax));
                     for (j=(AVX_VDSL_PROFILE_12A-1); j<=(AVX_VDSL_PROFILE_12B-1); j++)
                     {
                        nEntryMax.MaxnomatpDs = DSL_MAX(nEntryMax.MaxnomatpDs, sPreselectTable.Entry[j].MaxnomatpDs);
                     }

                     /* Find the profiles with the maximum ATP value */
                     for (j=(AVX_VDSL_PROFILE_12A-1); j<=(AVX_VDSL_PROFILE_12B-1); j++)
                     {
                        if ( nEntryMax.MaxnomatpDs == sPreselectTable.Entry[j].MaxnomatpDs )
                        {
                           /* Count the number of profiles where the US0 is enabled and the max ATP found */
                           if (sPreselectTable.Entry[j].US0Usage)
                              nEntryMax.US0Usage++;
                        }
                     }

                     /* Find the profile with the maximum ATP value, US0 enabled and lowest ID */
                     for (j=(AVX_VDSL_PROFILE_12A-1); j<=(AVX_VDSL_PROFILE_12B-1); j++)
                     {
                        if ( nEntryMax.MaxnomatpDs == sPreselectTable.Entry[j].MaxnomatpDs )
                        {
                           if (nEntryMax.US0Usage == 0)
                           {
                              /* single profile with the max ATP */
                              nProfiles = 1 << (sPreselectTable.Entry[j].vdslProfile - 1);
                              break;
                           }

                           if (sPreselectTable.Entry[j].US0Usage)
                           {
                              /* first found will have the lowest ID
                                 or will be a single profile with the maxATP & US0 enabled */
                              nProfiles = 1 << (sPreselectTable.Entry[j].vdslProfile - 1);
                              break;
                           }
                        }
                     }
                  }
                  else if ((sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_8D) ||
                           (sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_8C) ||
                           (sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_8B))
                  {
                     /* Determine the maximum ATP value of the profiles range: 8A to 8D */
                     memset(&nEntryMax, 0, sizeof(nEntryMax));
                     for (j=(AVX_VDSL_PROFILE_8A-1); j<=(AVX_VDSL_PROFILE_8D-1); j++)
                     {
                        nEntryMax.MaxnomatpDs = DSL_MAX(nEntryMax.MaxnomatpDs, sPreselectTable.Entry[j].MaxnomatpDs);
                     }

                     /* Find the profiles with the maximum ATP value */
                     for (j=(AVX_VDSL_PROFILE_8A-1); j<=(AVX_VDSL_PROFILE_8D-1); j++)
                     {
                        if ( nEntryMax.MaxnomatpDs == sPreselectTable.Entry[j].MaxnomatpDs )
                        {
                           /* Count the number of profiles where the US0 is enabled and the max ATP found */
                           if (sPreselectTable.Entry[j].US0Usage)
                              nEntryMax.US0Usage++;
                        }
                     }

                     /* Find the profile with the maximum ATP value, US0 enabled and lowest ID */
                     for (j=(AVX_VDSL_PROFILE_8A-1); j<=(AVX_VDSL_PROFILE_8D-1); j++)
                     {
                        if ( nEntryMax.MaxnomatpDs == sPreselectTable.Entry[j].MaxnomatpDs )
                        {
                           if (nEntryMax.US0Usage == 0)
                           {
                              /* single profile with the max ATP */
                              nProfiles = 1 << (sPreselectTable.Entry[j].vdslProfile - 1);
                              break;
                           }

                           if (sPreselectTable.Entry[j].US0Usage)
                           {
                              /* first found will have the lowest ID
                                 or will be a single profile with the maxATP & US0 enabled */
                              nProfiles = 1 << (sPreselectTable.Entry[j].vdslProfile - 1);
                              break;
                           }
                        }
                     }
                  }
                  else
                  {
                     nProfiles = 1 << i;
                  }
                  break;
               }
            }
         }

         if (nProfiles == 0)
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_Eaps2InitialProfileSet(%d): "
               "could not determine best profile from preselction table!"
               DSL_CRLF, nLine, nProfiles));
            return DSL_ERROR;
         }
      }
      else
      {
         /* no preselection, just take highest */
         lastBitPos = DSL_LastPositionFromMaskGet(nProfiles);
         if (lastBitPos == 0xFF)
         {
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
                  "DSL[%02d]: DSL_LastPositionFromMaskGet(%d) failed!" DSL_CRLF, nLine, nProfiles));
            return DSL_ERROR;
         }
         nProfiles = 1 << lastBitPos;
      }
   }
   else
   {
      DSL_uint8_t nProfile = 0;

      switch(nInitialProfile)
      {
         case DSL_DBG_EAPS2_INIT_30A: nProfile = 0x1<<DSL_PROFILE_30A; break;
         case DSL_DBG_EAPS2_INIT_17A: nProfile = 0x1<<DSL_PROFILE_17A; break;
         case DSL_DBG_EAPS2_INIT_12A: nProfile = 0x1<<DSL_PROFILE_12A; break;
         case DSL_DBG_EAPS2_INIT_12B: nProfile = 0x1<<DSL_PROFILE_12B; break;
         case DSL_DBG_EAPS2_INIT_8A:  nProfile = 0x1<<DSL_PROFILE_8A;  break;
         case DSL_DBG_EAPS2_INIT_8B:  nProfile = 0x1<<DSL_PROFILE_8B;  break;
         case DSL_DBG_EAPS2_INIT_8C:  nProfile = 0x1<<DSL_PROFILE_8C;  break;
         case DSL_DBG_EAPS2_INIT_8D:  nProfile = 0x1<<DSL_PROFILE_8D;  break;

         case DSL_DBG_EAPS2_INIT_ADSL:
         case DSL_DBG_EAPS2_INIT_OFF:
         default:
            break;
      }

      if ((nProfile & nProfiles) == 0)
      {
         DSL_DEBUG(DSL_DBG_WRN, (pContext,
            "DSL[%02d]: DSL_AVX_Eaps2InitialProfileSet - Warning, "
            "initial profile was not in configured set" DSL_CRLF, nLine));
      }
      nProfiles = nProfile;
   }

   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nProfiles);
   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: nProfile = 0x%X" DSL_CRLF, nLine, nProfiles));

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_Eaps2InitialProfileSet" DSL_CRLF, nLine));

   return errorCode;
}

/**
   Perform lower profile selection for the Enhanced Auto Profile Switching.
   The best lower brofile will be choosen according to a priority:
   - Highest MaxNomAtp
   - US0 enabled
   - Lower profile ID

   \param pContext      Pointer to dsl library context structure, [I]
   \param nLine         index of selected line, [I]
   \param bCPECapsCheck flag indicates to perform or not check of
                        the profiles supporting by CPE, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2NextLowerProfileSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_boolean_t bCPECapsCheck)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS, nRet;
   DSL_uint8_t nCurrentProfile, nNextProfile, nCpeProfiles, nAllowedProfiles, nProfileFailed;
   DSL_boolean_t bAdslProfileFailed = DSL_FALSE;
   DSL_AVX_APS_PreselectDataTable_t sPreselectTable;
   DSL_uint8_t nWeights[AVX_VDSL_PROFILE_30A];
   DSL_uint_t nMaxWeights = 0;
   DSL_int_t i, j;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_Eaps2NextLowerProfileSet" DSL_CRLF, nLine));

   nCurrentProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);
   nProfileFailed = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_FAILED);
   bAdslProfileFailed = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_ADSL_PROFILE_FAILED));

   if (nCurrentProfile == 0)
   {
      if (nProfileFailed == DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE)) /* the bAdslProfileFailed is not valid here anyway */
      {
         /* if there is no valid profiles anymore - restore the valid profile mask 
            to allow all configured and try again */
         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_FAILED, 0);
         DSL_UINT8_SET(DSL_DBL_ADSL_PROFILE_FAILED, DSL_FALSE);
      }

      /* current mode was already ADSL, restart */
      DSL_AVX_VdslRestore(pContext, nLine);
      nRet = DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
      DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
      return errorCode;
   }

   nCpeProfiles = (DSL_uint8_t)DSL_UINT16_GET(DSL_DBS_VDSL2_CAPABILITY_OCTET1_FE);

   nRet = DSL_AVX_Eaps2PreselectionTableGet(pContext, nLine, &sPreselectTable);
   DSL_CHECK_ERROR_CODE(nRet, DSL_TRUE, errorCode);

   /* find out the allowed profiles: lower then the current one */
   nAllowedProfiles = 0;
   switch (nCurrentProfile)
   {
      case DSL_G997_PROFILES_30A: nAllowedProfiles |= DSL_G997_PROFILES_17A;
      case DSL_G997_PROFILES_17A: nAllowedProfiles |= DSL_G997_PROFILES_12A |
                                                      DSL_G997_PROFILES_12B |
                                                      DSL_G997_PROFILES_8A |
                                                      DSL_G997_PROFILES_8B |
                                                      DSL_G997_PROFILES_8C |
                                                      DSL_G997_PROFILES_8D;
                                  break;
      case DSL_G997_PROFILES_12A:
      case DSL_G997_PROFILES_12B: nAllowedProfiles |= DSL_G997_PROFILES_12A |
                                                      DSL_G997_PROFILES_12B;
      case DSL_G997_PROFILES_8A:
      case DSL_G997_PROFILES_8B:
      case DSL_G997_PROFILES_8C:
      case DSL_G997_PROFILES_8D: nAllowedProfiles |=  DSL_G997_PROFILES_8A |
                                                      DSL_G997_PROFILES_8B |
                                                      DSL_G997_PROFILES_8C |
                                                      DSL_G997_PROFILES_8D;
                                  break;
   }

   /* exclude profiles wich were not able to reach showtime */
   nAllowedProfiles &= ~nProfileFailed;

   /* find out the lower profile */
   nNextProfile = 0;
   for ( i = AVX_VDSL_PROFILE_30A-1; i >= 0; i-- )
   {
      /* skip not allowed profiles */
      if (((1 << i) & nAllowedProfiles) == 0)
         continue;

      /* skip unsupported by CPE profile */
      if (bCPECapsCheck && ((nCpeProfiles & (1 << i)) == 0))
         continue;

      if ((sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_12A) ||
          (sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_12B))
      {
         /* Sort the profiles by the weights, the prio of sorting is:
            - Maximum ATP
            - US0 enabled
            - lowest ID

            The structure of weight is:
            Bit15 .. 12: Reserved
            Bit11 .. 4 : ATP Priority
            Bit3       : US0 Priority
            Bit2 .. 0  : ID Priority
          */
         memset(&nWeights, 0, sizeof(nWeights));
         for (j=(AVX_VDSL_PROFILE_12A-1); j<=(AVX_VDSL_PROFILE_12B-1); j++)
         {
            /* skip not allowed profiles */
            if (((1 << j) & nAllowedProfiles) == 0)
               continue;

            /* skip unsupported by CPE profile */
            if (bCPECapsCheck && ((nCpeProfiles & (1 << j)) == 0))
               continue;

            /* skip not configured profiles */
            if (sPreselectTable.Entry[j].MaxnomatpDs == 0)
               continue;

            /* calculate ATP priority */
            nWeights[j] |= ((sPreselectTable.Entry[j].MaxnomatpDs & 0x00FF) << 4);

            /* calculate US0 priority */
            nWeights[j] |= ((sPreselectTable.Entry[j].US0Usage & 0x0001) << 3);

            /* calculate ID priority */
            nWeights[j] |= (AVX_VDSL_PROFILE_12B - j);
         }

         nMaxWeights = 0;
         for (j=(AVX_VDSL_PROFILE_12A-1); j<=(AVX_VDSL_PROFILE_12B-1); j++)
         {
            /* skip not allowed profiles */
            if (((1 << j) & nAllowedProfiles) == 0)
               continue;

            /* skip unsupported by CPE profile */
            if (bCPECapsCheck && ((nCpeProfiles & (1 << j)) == 0))
               continue;

            /* skip not configured profiles */
            if (sPreselectTable.Entry[j].MaxnomatpDs == 0)
               continue;

            /* get the maximum weight of the profiles lower then the current one */
            if ( nMaxWeights < nWeights[j] )
            {
               nMaxWeights = nWeights[j];
               nNextProfile = 1 << (sPreselectTable.Entry[j].vdslProfile - 1);
            }
         }

         if (nNextProfile) break;
      }
      else if ((sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_8A) ||
               (sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_8B) ||
               (sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_8C) ||
               (sPreselectTable.Entry[i].vdslProfile==AVX_VDSL_PROFILE_8D))
      {
         /* Sort the profiles by the weights, the prio of sorting is:
            - Maximum ATP
            - US0 enabled
            - lowest ID

            The structure of weight is:
            Bit15 .. 12: Reserved
            Bit11 .. 4 : ATP Priority
            Bit3       : US0 Priority
            Bit2 .. 0  : ID Priority
          */
         memset(&nWeights, 0, sizeof(nWeights));
         for (j=(AVX_VDSL_PROFILE_8A-1); j<=(AVX_VDSL_PROFILE_8D-1); j++)
         {
            /* skip not allowed profiles */
            if (((1 << j) & nAllowedProfiles) == 0)
               continue;

            /* skip unsupported by CPE profile */
            if (bCPECapsCheck && ((nCpeProfiles & (1 << j)) == 0))
               continue;

            /* skip not configured profiles */
            if (sPreselectTable.Entry[j].MaxnomatpDs == 0)
               continue;

            /* calculate ATP priority */
            nWeights[j] |= ((sPreselectTable.Entry[j].MaxnomatpDs & 0x00FF) << 4);

            /* calculate US0 priority */
            nWeights[j] |= ((sPreselectTable.Entry[j].US0Usage & 0x0001) << 3);

            /* calculate ID priority */
            nWeights[j] |= (AVX_VDSL_PROFILE_8D - j);
         }

         nMaxWeights = 0;
         for (j=(AVX_VDSL_PROFILE_8A-1); j<=(AVX_VDSL_PROFILE_8D-1); j++)
         {
            /* skip not allowed profiles */
            if (((1 << j) & nAllowedProfiles) == 0)
               continue;

            /* skip unsupported by CPE profile */
            if (bCPECapsCheck && ((nCpeProfiles & (1 << j)) == 0))
               continue;

            /* skip not configured profiles */
            if (sPreselectTable.Entry[j].MaxnomatpDs == 0)
               continue;

            /* get the maximum weight of the profiles lower then the current one */
            if ( nMaxWeights < nWeights[j] )
            {
               nMaxWeights = nWeights[j];
               nNextProfile = 1 << (sPreselectTable.Entry[j].vdslProfile - 1);
            }
         }

         if (nNextProfile) break;
      }
      else
      {
         /* skip not configured profiles */
         if (sPreselectTable.Entry[i].MaxnomatpDs == 0)
            continue;

         if (i > 0) nNextProfile = 1 << (i - 1);

         break;
      }
   }

   if (nNextProfile || DSL_G997_IsAdslConfigured(pContext, nLine))
   {
      /* set next lower profile found, or even 0 if ADSL present */
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nNextProfile);
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2NextLowerProfileSet: 0x%x" DSL_CRLF, nLine, nNextProfile));

      if (nNextProfile == 0) /* here the ADSL was configured */
      {
         if (bAdslProfileFailed == DSL_FALSE)
         {
            /* switch to ADSL */
            DSL_AVX_VdslDisable(pContext, nLine);
            return errorCode;
         }

         if (nProfileFailed == DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE))
         {
            /* if there is no valid vdsl profiles anymore - reset the vdsl failed profile
               mask to allow all configured */
            DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_FAILED, 0);
         }

         /* if there is no valid adsl profiles anymore - reset the adsl failed flag */
         DSL_UINT8_SET(DSL_DBL_ADSL_PROFILE_FAILED, DSL_FALSE);
      }
   }
   else /* here the ADSL wasn't configured */
   {
      if (nProfileFailed == DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE))
      {
         /* if there is no valid vdsl profiles anymore - reset the vdsl failed profile
            mask to allow all configured and try again */
         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_FAILED, 0);
      }
   }

   if (nNextProfile == 0)
   {
      /* no lower VDSL profile nor ADSL available, restart */
      DSL_AVX_VdslRestore(pContext, nLine);

      nRet = DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
      DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_Eaps2NextLowerProfileSet" DSL_CRLF, nLine));

   return errorCode;
}

/**
   Perform higher profile selection for the Enhanced Auto Profile Switching.

   \param pContext      Pointer to dsl library context structure, [I]
   \param nLine         index of selected line, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2NextHigherProfileSet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint8_t nProfiles, nCurrentProfile, nNextProfile, nProfileFailed;
   DSL_boolean_t bAdslProfileFailed = DSL_FALSE;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_AVX_Eaps2NextHigherProfileSet" DSL_CRLF, nLine));

   nCurrentProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);
   nProfiles = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE);
   nProfileFailed = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_FAILED);

   /* scan higher bits */
   if (nCurrentProfile == 0)
      nCurrentProfile = 1;
   else
      nCurrentProfile = nCurrentProfile<<1;
   for (nNextProfile = nCurrentProfile; nNextProfile > 0; nNextProfile = nNextProfile<<1)
      if ((nProfiles & ~nProfileFailed) & nNextProfile)
         break;

   if (nNextProfile || DSL_G997_IsAdslConfigured(pContext, nLine))
   {
      /* set next higher profile found, or wrap around to ADSL if present */
      DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nNextProfile);
      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]: DSL_AVX_Eaps2NextHigherProfileSet: 0x%x" DSL_CRLF, nLine, nNextProfile));
      if (nNextProfile)
      {
         DSL_AVX_VdslRestore(pContext, nLine);
      }
      else
      {
         bAdslProfileFailed = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_ADSL_PROFILE_FAILED));
         if (bAdslProfileFailed == DSL_TRUE)
         {
            /* ADSL mode was failed before, restart */
            DSL_AVX_VdslRestore(pContext, nLine);
            errorCode = DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
         }
         else
         {
            /* disable VDSL */
            DSL_AVX_VdslDisable(pContext, nLine);
         }
      }
   }
   else
   {
      /* no higher profile nor ADSL available, restart */
      DSL_AVX_VdslRestore(pContext, nLine);
      errorCode = DSL_AVX_Eaps2InitialProfileSet(pContext, nLine);
   }

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_AVX_Eaps2NextHigherProfileSet" DSL_CRLF, nLine));

   return errorCode;
}
#endif /* defined(INCLUDE_DSL_API_VINAX_R3) */


#if defined(INCLUDE_DSL_API_VINAX_R3)
/**
   This functions returns the VDSL2 profile preselection table.
   Each supported profile gets an entry:
      Profile | US0 | MAXNOMATP | f-Max
   User limits e.g. for MAXNOMATP are considered,
   unsupported profiles are removed.
*/
DSL_LOCAL DSL_Error_t DSL_AVX_Eaps2PreselectionTableGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   DSL_AVX_APS_PreselectDataTable_t *pPreselectTable)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint8_t nProfiles, nMaxNomAtp, nUS0Disabling = (DSL_Us0Disabling_t)DSL_US0DISABLING_OFF;
   DSL_BandList_t sBandListDs, sBandListUs;
   DSL_uint16_t nMaxFreqDs, nMaxFreqUs;
   DSL_int_t i, j;
   DSL_uint8_t nCurrentProfile, nConfiguredProfile = AVX_VDSL_PROFILE_30A;

   DSL_CHECK_POINTER(pContext, pPreselectTable);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: IN - DSL_DEV_Eaps2PreselectionTableGet" DSL_CRLF, nLine));

   /* get the default table */
   memcpy(&pPreselectTable->Entry[0] ,
      &DSL_AVX_APS_PreselectDataTable[0], sizeof(pPreselectTable->Entry));

   /* remove unselected profiles */
   nProfiles = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE);
   nCurrentProfile = DSL_UINT8_GET(DSL_DBL_VDSL_PROFILE_CURRENT);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: Profile | US0 | MAXNOMATP | f-Max " DSL_CRLF, nLine));
   for (i=0; i<AVX_VDSL_PROFILE_30A; i++)
   {
      if (((0x1<<i)&nProfiles) == 0)
      {
         memset(&pPreselectTable->Entry[i], 0, sizeof(pPreselectTable->Entry[0]));
      }
      else
      {
         /* Indexes of the pPreselectTable->Entry[] are always bellow the AVX_VDSL_PROFILE_XX ids */
         switch (i+1)
         {
            case AVX_VDSL_PROFILE_8A: nConfiguredProfile = DSL_G997_PROFILE_8A; break;
            case AVX_VDSL_PROFILE_8B: nConfiguredProfile = DSL_G997_PROFILE_8B; break;
            case AVX_VDSL_PROFILE_8C: nConfiguredProfile = DSL_G997_PROFILE_8C; break;
            case AVX_VDSL_PROFILE_8D: nConfiguredProfile = DSL_G997_PROFILE_8D; break;
            case AVX_VDSL_PROFILE_12A: nConfiguredProfile = DSL_G997_PROFILE_12A; break;
            case AVX_VDSL_PROFILE_12B: nConfiguredProfile = DSL_G997_PROFILE_12B; break;
            case AVX_VDSL_PROFILE_17A: nConfiguredProfile = DSL_G997_PROFILE_17; break;
            case AVX_VDSL_PROFILE_30A: nConfiguredProfile = DSL_G997_PROFILE_30A; break;
            default: break;
         }

         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nConfiguredProfile);

         errorCode = DSL_AVX_MaxNomPsdMaxNomAtpGet(pContext, nLine, DSL_DOWNSTREAM, DSL_DEV_VDSL2, DSL_NULL, &nMaxNomAtp);
         if (errorCode != DSL_SUCCESS)
         {
            DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nCurrentProfile);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_AVX_MaxNomPsdMaxNomAtpGet failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         /* Get band list of the dedicated profile */
         errorCode = DSL_DEV_ConfiguredBandListGet(pContext, nLine, DSL_DOWNSTREAM, &sBandListDs);
         if (errorCode != DSL_SUCCESS)
         {
            DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nCurrentProfile);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_DEV_ConfiguredBandListGet for DS failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         errorCode = DSL_DEV_ConfiguredBandListGet(pContext, nLine, DSL_UPSTREAM, &sBandListUs);
         if (errorCode != DSL_SUCCESS)
         {
            DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nCurrentProfile);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_DEV_ConfiguredBandListGet for US failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }

         /* Check US0 support */
         errorCode = DSL_VdslUS0DisablingGet(pContext, nLine, i, &sBandListUs, &nUS0Disabling);
         if (errorCode != DSL_SUCCESS)
         {
            DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nCurrentProfile);
            DSL_DEBUG(DSL_DBG_ERR, (pContext,
               "DSL[%02d]: DSL_VdslUS0DisablingGet failed: %d!" DSL_CRLF, nLine, errorCode));
            return errorCode;
         }
         DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nCurrentProfile);

         if ((DSL_Us0Disabling_t)nUS0Disabling == DSL_US0DISABLING_ON)
         {
            pPreselectTable->Entry[i].US0Usage = 0;
         }

         /* Check MAXNOMATP */
         pPreselectTable->Entry[i].MaxnomatpDs = DSL_MIN(pPreselectTable->Entry[i].MaxnomatpDs, nMaxNomAtp);

         /* Check Max Frequency */
         nMaxFreqUs = pPreselectTable->Entry[i].MaxFrequency;
         for ( j = ((sBandListUs.nNumData < DSL_MAX_NUMBER_OF_BANDS)?sBandListUs.nNumData:DSL_MAX_NUMBER_OF_BANDS)-1; j >= 0; j-- )
         {
            /* Choose the lowest MaxFrequency between the preselected one and the highest tone of the Band Borders */
            if (nMaxFreqUs > sBandListUs.nBand[j].nLastToneIndex)
            {
               /* trucate MaxFrequency by the last tone of the band */
               nMaxFreqUs = sBandListUs.nBand[j].nLastToneIndex;
               break;
            }
            else if (nMaxFreqUs > sBandListUs.nBand[j].nFirstToneIndex)
            {
               /* leave MaxFrequency unchanged */
               break;
            }
         }

         nMaxFreqDs = pPreselectTable->Entry[i].MaxFrequency;
         for ( j = ((sBandListDs.nNumData < DSL_MAX_NUMBER_OF_BANDS)?sBandListDs.nNumData:DSL_MAX_NUMBER_OF_BANDS)-1; j >= 0; j-- )
         {
            /* Choose the lowest MaxFrequency between the preselected one and the highest tone of the Band Borders */
            if (nMaxFreqDs > sBandListDs.nBand[j].nLastToneIndex)
            {
               /* trucate MaxFrequency by the last tone of the band */
               nMaxFreqDs = sBandListDs.nBand[j].nLastToneIndex;
               break;
            }
            else if (nMaxFreqDs > sBandListDs.nBand[j].nFirstToneIndex)
            {
               /* leave MaxFrequency unchanged */
               break;
            }
         }

         pPreselectTable->Entry[i].MaxFrequency = DSL_MAX(nMaxFreqDs, nMaxFreqUs);
      }

      DSL_DEBUG(DSL_DBG_MSG, (pContext,
         "DSL[%02d]:       %01d |  %01d  |    %03d    | %04d " DSL_CRLF, nLine,
         pPreselectTable->Entry[i].vdslProfile,
         pPreselectTable->Entry[i].US0Usage,
         pPreselectTable->Entry[i].MaxnomatpDs,
         pPreselectTable->Entry[i].MaxFrequency  ));
   }
   
   DSL_UINT8_SET(DSL_DBL_VDSL_PROFILE_CURRENT, nCurrentProfile);

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: OUT - DSL_DEV_Eaps2PreselectionTableGet" DSL_CRLF, nLine));

   return errorCode;
}
#endif /* defined(INCLUDE_DSL_API_VINAX_R3) */

#ifdef DSL_DELAYED_CALLBACK_ENABLED
DSL_Error_t DSL_AVX_DelayedCallbackAdd(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   DSL_uint8_t nChannel,
   DSL_AccessDir_t nAccessDir,
   DSL_ATUDir_t nATUDir,
   DSL_CallbackType_t nCallbackType,
   DSL_time_t nTimeout,
   DSL_CB_DATA_Union_t *pData)
{
   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_AVX_DelayedCallback_t *pDelayedCallback;
   DSL_AVX_DelayedCallback_t *pLastCallback;
   DSL_uint16_t nDev = 0;

   DSL_GET_DEVICE_NUMBER(nLine, nDev);

   pDelayedCallback = (DSL_AVX_DelayedCallback_t *) DSL_Malloc(sizeof(*pDelayedCallback));
   if (pDelayedCallback == DSL_NULL)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext,
         "DSL[%02d]: DSL_Malloc(%d) failed" DSL_CRLF, nLine, sizeof(*pDelayedCallback)));
      return DSL_ERROR;
   }

   memset(pDelayedCallback, 0, sizeof(*pDelayedCallback));
   pDelayedCallback->nLine = nLine;
   pDelayedCallback->nChannel = nChannel;
   pDelayedCallback->nAccessDir = nAccessDir;
   pDelayedCallback->nATUDir = nATUDir;
   pDelayedCallback->nCallbackType = nCallbackType;
   pDelayedCallback->cbData = *pData;
   pDelayedCallback->pNextCallback = DSL_NULL;

   if (DSL_SemaphoreGet(&pContext->DelayedCallbackSemaphore, 0xFFFFFFFF) != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_SemaphoreGet failed!" DSL_CRLF, nLine));

      DSL_Free(pDelayedCallback);
      return DSL_ERROR;
   }

   pLastCallback = pContext->pDelayedCallback;
   if (pLastCallback == DSL_NULL)
   {
      pContext->pDelayedCallback = pDelayedCallback;
   }
   else
   {
      while (pLastCallback->pNextCallback != DSL_NULL)
      {
         pLastCallback = pLastCallback->pNextCallback;
      }

      pLastCallback->pNextCallback = pDelayedCallback;
   }

   pDelayedCallback->nTimeoutID = DSL_Timeout_AddEvent(
                  pContext,
                  nDev,
                  nLine,
                  (DSL_int_t) DSL_TIMEOUTEVENT_CALLBACK,
                  (DSL_uint32_t) nTimeout);

   if (pDelayedCallback->nTimeoutID == 0)
   {
      if (pLastCallback == DSL_NULL)
      {
         pContext->pDelayedCallback = DSL_NULL;
      }
      else
      {
         pLastCallback->pNextCallback = DSL_NULL;
      }

      DSL_Free(pDelayedCallback);

      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_Timeout_AddEvent failed!" DSL_CRLF, nLine));
      errorCode = DSL_ERROR;
   }

   DSL_SemaphoreSet(&pContext->DelayedCallbackSemaphore);

   return errorCode;
}
#endif /* def DSL_DELAYED_CALLBACK_ENABLED */

#ifdef DSL_DELAYED_CALLBACK_ENABLED
DSL_LOCAL DSL_Error_t DSL_AVX_OnDelayedCallbackEvent(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   DSL_ulong_t nTimeoutID)
{
   DSL_AVX_DelayedCallback_t *pDelayedCallback;
   DSL_AVX_DelayedCallback_t *pDelayedCallbackPrev;

   if (DSL_SemaphoreGet(&pContext->DelayedCallbackSemaphore, 0xFFFFFFFF) != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_SemaphoreGet failed!" DSL_CRLF, nLine));

      return DSL_ERROR;
   }

   pDelayedCallbackPrev = DSL_NULL;
   pDelayedCallback = pContext->pDelayedCallback;

   while (pDelayedCallback != DSL_NULL)
   {
      if (pDelayedCallback->nTimeoutID == nTimeoutID)
      {
         /* remove pDelayedCallback entry */
         if (pDelayedCallbackPrev == DSL_NULL)
         {
            pContext->pDelayedCallback = pDelayedCallback->pNextCallback;
         }
         else
         {
            pDelayedCallbackPrev->pNextCallback = pDelayedCallback->pNextCallback;
         }

         pDelayedCallback->pNextCallback = DSL_NULL;
         break;
      }

      pDelayedCallbackPrev = pDelayedCallback;
      pDelayedCallback = pDelayedCallback->pNextCallback;
   }

   DSL_SemaphoreSet(&pContext->DelayedCallbackSemaphore);

   if (pDelayedCallback != DSL_NULL)
   {
      if (pContext->pEventCallback != DSL_NULL)
      {
         (void) pContext->pEventCallback(pContext,
            pDelayedCallback->nLine,
            pDelayedCallback->nChannel,
            pDelayedCallback->nAccessDir,
            pDelayedCallback->nATUDir,
            pDelayedCallback->nCallbackType,
            &pDelayedCallback->cbData);
      }

      DSL_Free(pDelayedCallback);
   }

   return DSL_SUCCESS;
}
#endif /* def DSL_DELAYED_CALLBACK_ENABLED */

#if (DSL_FAILURE_PRIORITIZATION > 0)
DSL_LOCAL DSL_void_t DSL_AVX_FailureEventRaiseCallback(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   DSL_FailureMask_t nFailureMask)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_uint32_t dataPathMaskNe = 0;
   DSL_uint32_t dataPathMaskFe = 0;
   DSL_uint32_t lineMaskNe = 0;
   DSL_uint32_t lineMaskFe = 0;

   DSL_FailureInfo_t *pInfo;
   DSL_uint_t n;

   if (nFailureMask && pContext->pEventCallback != DSL_NULL)
   {
      if ((DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_TC_SYNC)  ||
         (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_SHOWTIME_NO_SYNC)  ||
         (DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_MELT_PARK ) ||
         (DSL_UINT8_GET(DSL_DBS_DEV_LAST_EXCEPTION) != 0))
      {
         pInfo = DSL_FailureInfo_Table;
         for (n = 0; n < DSL_ARRAY_LENGTH(DSL_FailureInfo_Table); n++, pInfo++)
         {
            if (nFailureMask & (1 << pInfo->nFailure))
            {
               if (pInfo->nFailureType == DSL_FAILURE_TYPE_LINE)
               {
                  if (pInfo->nDir == DSL_NEAR_END)
                     lineMaskNe |= pInfo->g997mask & DSL_UINT32_GET(DSL_DBL_LFM_NE);
                  else
                     lineMaskFe |= pInfo->g997mask & DSL_UINT32_GET(DSL_DBL_LFM_FE);
               }
               else
               {
                  if (pInfo->nDir == DSL_NEAR_END)
                     dataPathMaskNe |= pInfo->g997mask & DSL_UINT32_GET(DSL_DBC_DPFM_NE);
                  else
                     dataPathMaskFe |= pInfo->g997mask & DSL_UINT32_GET(DSL_DBC_DPFM_FE);
               }
            }
         }

         if (lineMaskNe)
         {
            DSL_CB_DATA_LineFailures_t lineFailures;

            lineFailures.nLineFailures = DSL_UINT32_GET(DSL_DBS_LF_NE);
            lineFailures.nMaskLineFailures = lineMaskNe;

            (void) pContext->pEventCallback(pContext,
                                        nLine,
                                        DSL_CHANNEL_NA,
                                        DSL_ACCESSDIR_NA,
                                        DSL_NEAR_END,
                                        DSL_CBI_LINE_FAILURES,
                                        (DSL_CB_DATA_Union_t *) &lineFailures);
         }

         if (lineMaskFe)
         {
            DSL_CB_DATA_LineFailures_t lineFailures;

            lineFailures.nLineFailures = DSL_UINT32_GET(DSL_DBS_LF_FE);
            lineFailures.nMaskLineFailures = lineMaskFe;

            (void) pContext->pEventCallback(pContext,
                                        nLine,
                                        DSL_CHANNEL_NA,
                                        DSL_ACCESSDIR_NA,
                                        DSL_FAR_END,
                                        DSL_CBI_LINE_FAILURES,
                                        (DSL_CB_DATA_Union_t *) &lineFailures);
         }

         if (dataPathMaskNe)
         {
            DSL_CB_DATA_DataPathFailures_t dataPathFailures;

            dataPathFailures.nDataPathFailures = DSL_UINT32_GET(DSL_DBSC_DPF_NE);
            dataPathFailures.nMaskDataPathFailures = dataPathMaskNe;

            (void) pContext->pEventCallback(pContext,
                     nLine,
                     DSL_CHANNEL_NA,
                     DSL_ACCESSDIR_NA,
                     DSL_NEAR_END,
                     DSL_CBI_DATA_PATH_FAILURES,
                     (DSL_CB_DATA_Union_t *) &dataPathFailures);
         }

         if (dataPathMaskFe)
         {
            DSL_CB_DATA_DataPathFailures_t dataPathFailures;

            dataPathFailures.nDataPathFailures = DSL_UINT32_GET(DSL_DBSC_DPF_FE);
            dataPathFailures.nMaskDataPathFailures = dataPathMaskFe;

            (void) pContext->pEventCallback(pContext,
                     nLine,
                     DSL_CHANNEL_NA,
                     DSL_ACCESSDIR_NA,
                     DSL_FAR_END,
                     DSL_CBI_DATA_PATH_FAILURES,
                     (DSL_CB_DATA_Union_t *) &dataPathFailures);
         }
      }
   }
}

DSL_LOCAL DSL_Error_t DSL_AVX_OnFailureEvent(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   DSL_ulong_t nTimeoutID)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS;

   DSL_FailureMask_t nNewFailureMask = 0;
   DSL_FailureMask_t nFailureMask;
#if 0
   DSL_FailureInfo_t *pLowestPrio = DSL_NULL;
#endif
   DSL_FailureInfo_t *pInfo;
   DSL_uint_t n;

   nFailureMask = (DSL_FailureMask_t) DSL_UINT32_GET(DSL_DBS_FAILURE_MASK);

   pInfo = DSL_FailureInfo_Table;
   for (n = 0; n < DSL_ARRAY_LENGTH(DSL_FailureInfo_Table); n++, pInfo++)
   {
#if 0
      if (pLowestPrio != DSL_NULL && pInfo->nFailurePrio > pLowestPrio->nFailurePrio)
      {
         break;
      }
#endif

      if (nFailureMask & (1 << pInfo->nFailure))
      {
         DSL_pmDeviceType_t pmDeviceType;

         nNewFailureMask |= (1 << pInfo->nFailure);

#if 0
         if (pLowestPrio != DSL_NULL)
         {
            pLowestPrio = pInfo;
         }
#endif

         if (pInfo->nDir == DSL_NEAR_END)
         {
            pmDeviceType = DSL_PM_LTU;
         }
         else
         {
            pmDeviceType = DSL_PM_NTU;
         }

         if (pInfo->nFailureType == DSL_FAILURE_TYPE_LINE)
         {
            DSL_DEV_LineEpAdditPMCountersUpdate(pContext, nLine, pmDeviceType, pInfo->g997mask, DSL_TRUE);
         }
         else if (pInfo->nFailureType == DSL_FAILURE_TYPE_DATA_PATH)
         {
            DSL_DEV_DataPathEpAdditPMCountersUpdate(pContext, nLine, nChannel, pmDeviceType, pInfo->g997mask, DSL_TRUE);
         }

         break;
      }
   }

   DSL_AVX_FailureEventRaiseCallback(pContext, nLine, nNewFailureMask);

   DSL_UINT32_SET(DSL_DBS_FAILURE_MASK, 0);

   return DSL_SUCCESS;
}

DSL_LOCAL DSL_Error_t DSL_AVX_FailureEventReset(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine,
   DSL_FailureMask_t nFailureMask)
{
   static const DSL_uint8_t nChannel = 0;

   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;

   DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_FAILURE_TIMEOUT_ID);

   if (nFailureMask)
   {
      nRet = DSL_TimerDB_Add(pContext, nLine, DSL_DBS_FAILURE_TIMEOUT_ID, DSL_TIMEOUTEVENT_FAILURE, DSL_FAILURE_TIMEOUT);
      if (nRet != DSL_SUCCESS)
      {
         DSL_DEBUG(DSL_DBG_ERR, (pContext, "DSL[%02d]: DSL_TimerDB_Add failed!" DSL_CRLF, nLine));

         /* Raise callback anyway */
         DSL_AVX_FailureEventRaiseCallback(pContext, nLine, nFailureMask);

         nFailureMask = 0;
      }
   }

   DSL_UINT32_SET(DSL_DBS_FAILURE_MASK, nFailureMask);

   return DSL_SUCCESS;
}
#endif

DSL_Error_t DSL_AVX_OnPmsfReqStatusGet(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtPmsfReqStatusGet_t *pStatus
)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_CB_DATA_PowerManagementState_t pmMode;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_OnPmsfReqStatusGet PmsfStatus: 0x%02x, "
      "FailReason: 0x%02x" DSL_CRLF, nLine, pStatus->PmsfStatus, pStatus->FailReason));

   if ((pStatus->PmsfStatus & (L2_REJECT)) &&
         (DSL_INT8_GET(DSL_DBS_ACT_PMSTATUS) != DSL_G997_PMS_L2)) /* ignore L2_REJECT in L2 state*/
   {
      /* If L2 error is indicated and L2 fallback mode is not enabled 
         and fallback timer is not already running: start fallback timer  */ 
      if (DSL_INT8_GET(DSL_DBL_IFS_L2_AMD4_ENABLE) != 2)
      {
         if (((DSL_boolean_t)DSL_UINT8_GET(DSL_DBS_L2_HANDLING_FALLBACK_ENABLED) == DSL_FALSE) &&
          (DSL_ULONG_GET(DSL_DBS_L2_HANDLING_FALLBACK_TIMEOUT_ID) == 0))
         {
            DSL_TimerDB_Add(pContext, nLine,
                            DSL_DBS_L2_HANDLING_FALLBACK_TIMEOUT_ID,
                            DSL_TIMEOUTEVENT_L2_HANDLING_FALLBACK,
                            DSL_DEV_TIMEOUT_L2_HANDLING_FALLBACK * DSL_TIMEOUT_FACTOR);
         }
      }
   }

   if (pContext->pEventCallback != DSL_NULL)
   {
      DSL_boolean_t bSemMask = DSL_FALSE;

      bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_PM_STATE));
      if (bSemMask == DSL_FALSE)
      {
         pmMode.nPowerManagementState = (DSL_G997_PowerManagementState_t)DSL_INT8_GET(DSL_DBS_ACT_PMSTATUS);
         pmMode.nPmsFailure = (DSL_PmsFailure_t)pStatus->PmsfStatus;
         pmMode.nPmsSubFailure = (DSL_PmsSubFailure_t)pStatus->FailReason;

         (void)(pContext->pEventCallback)( (DSL_void_t*)pContext,
            nLine,
            DSL_CHANNEL_NA,
            DSL_ACCESSDIR_NA,
            DSL_ATUDIR_NA,
            DSL_CBS_LINE_POWERMANAGEMENT_STATE,
            (DSL_CB_DATA_Union_t *)&pmMode );
      }
   }
   
   return errorCode;

}

/**
   Enable/Disable the power saving configurations for al lines if app
   conditions are met.

   \param pContext Pointer to dsl library context structure, [I]
   \param nTriggerLine    Triggering line for this function, [I]
   \param bL3Exit   Enable/Disable L3 bits, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_Error_t DSL_AVX_PowerSavingL3Toggle(
   DSL_Context_t *pContext,
   DSL_uint16_t nTriggerLine,
   DSL_boolean_t bL3Exit)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;
   DSL_boolean_t bSend, bSavingAlreadyOn;
   DSL_uint16_t nLine = 0; /* power saving is a global feature */
   DSL_DEV_LineState_t nLineState;
   DSL_uint32_t nL3AfeBits = 0, nLXAfeBits = 0;
   DSL_uint32_t nL3DfeBits = 0, nLXDfeBits = 0;
   
   bSavingAlreadyOn = (DSL_boolean_t)DSL_UINT8_GET(DSL_DBDS_POWEROPT_ENABLED);

   nLine = 0; /* Power options config is line independent */
   nL3AfeBits = DSL_UINT32_GET(DSL_DBI_POWEROPT_L3_AFE);
   nL3DfeBits = DSL_UINT32_GET(DSL_DBI_POWEROPT_L3_DFE);
   nLXAfeBits = DSL_UINT32_GET(DSL_DBI_POWEROPT_LX_AFE);
   nLXDfeBits = DSL_UINT32_GET(DSL_DBI_POWEROPT_LX_DFE);
   
   /* check for the special values to disable Powersavings */
   if ((nL3AfeBits == (DSL_uint32_t)(-1)) &&
       (nL3DfeBits == (DSL_uint32_t)(-1)) &&
       (nLXAfeBits == (DSL_uint32_t)(-1)) &&
       (nLXDfeBits == (DSL_uint32_t)(-1)))
   {
      return DSL_SUCCESS;
   }

   /* cut afe/def bits by the used masks */
   nL3AfeBits &= 0x00000FFF;
   nL3DfeBits &= 0x000000FF;
   nLXAfeBits &= 0x00000FFF;
   nLXDfeBits &= 0x000000FF;

   if (bL3Exit)
   {
      /* enable the Powersavings if possible */
      if (bSavingAlreadyOn)
      {
         bSend = DSL_FALSE;
      }
      else
      {
         bSend = DSL_TRUE;

         /* check all lines */
         for (nLine=0; nLine<DSL_MAX_LINE_NUMBER; nLine++)
         {
            if (DSL_LineEnabledGet(pContext, nLine) == DSL_FALSE)
               continue;
            
            nLineState = (DSL_DEV_LineState_t)DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE);
            if (((nLineState != DSL_LINESTATUS_IDLE) && (nLineState != DSL_LINESTATUS_SILENT))
#ifdef INCLUDE_DSL_API_AVINAX_MELT
                  || (DSL_MELT_LineIdle(pContext->pMELT_Ctx, nLine) != DSL_SUCCESS)
#endif
               )
            {
               /* at least one line is not down, don't change anything */
               bSend = DSL_FALSE;
               break;
            }
         }
      }
   }
   else
   {
      /* remove evtl running timer to enable power saving */
      DSL_AVX_PowerSavingTimerStart(pContext, nLine, DSL_FALSE);
      /* disable the Powersavings if not done already */
      if (bSavingAlreadyOn)
      {
         bSend = DSL_TRUE;
      }
      else
      {
         bSend = DSL_FALSE;
      }
   }

   if (bSend)
   {
      DSL_PowerOptions_t sPowerConfig;

      if (bL3Exit)
      {
         /* send FW Msg with enable bits of L3|Lx, and disable bits for ~(L3|Lx).
            Disable bits are set in the DSL_AVX_SendMsgPowerSavingControl() */
         sPowerConfig.nAfeOptions = nL3AfeBits;
         sPowerConfig.nDfeOptions = nL3DfeBits;
         sPowerConfig.nAfeOptions |= nLXAfeBits;
         sPowerConfig.nDfeOptions |= nLXDfeBits;
      }
      else
      {
         /* send FW Msg with enable bits for Lx&~L3, and disable ~( Lx&~L3).
            Disable bits are set in the DSL_AVX_SendMsgPowerSavingControl() */
         sPowerConfig.nAfeOptions = ~nL3AfeBits;
         sPowerConfig.nDfeOptions = ~nL3DfeBits;
         sPowerConfig.nAfeOptions &= nLXAfeBits;
         sPowerConfig.nDfeOptions &= nLXDfeBits;
      }
      
      /* assume device 0 will have a SLIC config as soon as there is MELT */
      if (pContext->DeviceContext.lowlevelConfig.cfg[0].slicConfig.bEnableSlicConfig)
      {
         /* DSL_AVX_SendMsgPowerSavingControl now always gets an Enable mask independent
            from the bEnable flag. So DFE4 bit needs always to be disabled.*/
         sPowerConfig.nDfeOptions &= ~DSL_AVX_POWEROPT_DFE4;
      }
      
      for (nLine=0; nLine<DSL_MAX_LINE_NUMBER; nLine++)
      {
         if (DSL_LineEnabledGet(pContext, nLine) == DSL_FALSE)
            continue;
            
         errorCode = DSL_AVX_SendMsgPowerSavingControl(pContext, 
                        nLine, &sPowerConfig);
      }
      if (errorCode >= DSL_SUCCESS)
      {
         nLine = 0;
         DSL_UINT8_SET(DSL_DBDS_POWEROPT_ENABLED, bL3Exit);
      }
   }

   return DSL_SUCCESS;
}

/**
   Start/stop the power saving enable timer.

   \param pContext Pointer to dsl library context structure, [I]
   \param nTriggerLine    Triggering line for this function, [I]
   \param bEnable   Enable/Disable power saving, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_PowerSavingTimerStart(
   DSL_Context_t *pContext,
   DSL_uint16_t nTriggerLine,
   DSL_boolean_t bEnable)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   DSL_uint16_t nLine = 0; /* act always on line 0, timer is global */

   if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBDS_POWERSAVE_ENABLE_TIMEOUT_ID) != DSL_SUCCESS)
   {
      DSL_DEBUG(DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_PowerSavingTimerStart: could not remove timeout!" DSL_CRLF, nTriggerLine));
   }

   if (bEnable)
   {
      DSL_TimerDB_Add(pContext, nLine,
                      DSL_DBDS_POWERSAVE_ENABLE_TIMEOUT_ID,
                      DSL_TIMEOUTEVENT_POWERSAVE_ENABLE,
                      20 * DSL_TIMEOUT_FACTOR);
   }
   return errorCode;
}

/**
   This function handles the Soft Recovery trigger.

   \param pContext     Pointer to dsl library context structure, [I]
   \param nLine        Specifies on which line the message was received, [I]
   \param pFailReason  Pointer to the trigger event message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnSoftRecoveryTrigger(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_FailReason_t const *pFailReason
)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_AVX_SoftRecoveryParams_t softRecoveryData;

   DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_OnSoftRecoveryTrigger" DSL_CRLF, nLine));

   DSL_CHECK_POINTER(pContext, pFailReason);

   softRecoveryData.nStartAddress = DSL_AVX_PARA32_GET(pFailReason->TxSymCount);
   softRecoveryData.nStopAddress = DSL_AVX_PARA32_GET(pFailReason->RxSymCount);
   softRecoveryData.nSegment = pFailReason->RxStateOnFail;

   nRet = DSL_AVX_HandleSoftRecoveryEvent( pContext, nLine, &softRecoveryData, DSL_FALSE);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error on DSL_AVX_HandleSoftRecoveryEvent!" DSL_CRLF, nLine);

   return errorCode;
 }

/**
   This function checks and handles a soft recovery procedure.

   \param pContext   Pointer to dsl library context structure, [I]
   \param nDevice    Specifies for which device the function should be applied, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_SoftRecoveryCheck(
   DSL_Context_t *pContext,
   DSL_uint16_t   nDevice
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;
   DSL_uint16_t nLine = 0, i = 0;
   /* Set the following macro to 1 to process all the blocks in one Control Thread cycle */
   #define DSL_SOFT_RECOVERY_PROCESS_ALL_BLOCKS_AT_ONCE 0

   for (i=0; i<DSL_LINES_PER_DEVICE; i++)
   {
      DSL_DEV_GET_LINE_PARAM(nDevice, i, nLine);
      if (nLine >= DSL_MAX_LINE_NUMBER)
         return DSL_ERR_LINE_RANGE;

      /*
         In case of OCM, further OCM indications by other ports shall be ignored 
         as long as the recovery is ongoing. ICCM indications shall be executed/scheduled per slice.

         nCurrentSegment:
         0 => the event occurred at the on-slice memory (ICCM)
         1 => the corruption occurred in the global memory (OCM)
   
         nCorruptedSegmentIndication:
         A non-zero value at d indicates corruption has happened
      */

      /* Check for a corrupted segment indication and IDLE state. If TRUE => process soft recovery for the line */
      if (((DSL_UINT32_GET(DSL_DBS_ACT_LINESTATE) == DSL_LINESTATUS_IDLE) &&
          (DSL_LineStatusGet(pContext, nLine)     == DSL_DEVSTATE_SOFT_RECOVERY)) ||
          (pContext->DeviceContext.bNonIntrusiveSoftRecovery[nLine] == DSL_TRUE))
      {
         DSL_DEV_LineState_t nLineState;
         DSL_boolean_t bNonIntrusiveSoftRecovery = pContext->DeviceContext.bNonIntrusiveSoftRecovery[nLine];
         
#if defined(DSL_SOFT_RECOVERY_PROCESS_ALL_BLOCKS_AT_ONCE) && (DSL_SOFT_RECOVERY_PROCESS_ALL_BLOCKS_AT_ONCE == 1)
         do {
#endif /* DSL_SOFT_RECOVERY_PROCESS_ALL_BLOCKS_AT_ONCE */
            errorCode = DSL_AVX_DoPartialFWDownload(pContext, nLine);
            if (errorCode < DSL_SUCCESS)
            {
               DSL_DEBUG(DSL_DBG_ERR, (pContext,
                     "DSL[%02d]: DSL_AVX_SoftRecoveryCheck: Failed to download FW block with start address = %X, stop address = %X." 
                     DSL_CRLF, nLine,DSL_UINT32_GET(DSL_DBS_SOFT_RECOVERY_FIRST_ADDRESS),DSL_UINT32_GET(DSL_DBS_SOFT_RECOVERY_STOP_ADDRESS)));
               return DSL_ERROR;
            }
#if defined(DSL_SOFT_RECOVERY_PROCESS_ALL_BLOCKS_AT_ONCE) && (DSL_SOFT_RECOVERY_PROCESS_ALL_BLOCKS_AT_ONCE == 1)
         } while ((DSL_LineStatusGet(pContext, nLine) != DSL_DEVSTATE_NORMAL_OPERATION) || 
                  (pContext->DeviceContext.bNonIntrusiveSoftRecovery[nLine] == DSL_TRUE));
#endif /* DSL_SOFT_RECOVERY_PROCESS_ALL_BLOCKS_AT_ONCE */
         
         if (((bNonIntrusiveSoftRecovery == DSL_FALSE) && (DSL_LineStatusGet(pContext, nLine) ==  DSL_DEVSTATE_NORMAL_OPERATION)) ||
             ((bNonIntrusiveSoftRecovery == DSL_TRUE)  && (pContext->DeviceContext.bNonIntrusiveSoftRecovery[nLine] == DSL_FALSE)))
         {
           /* Enable the memory watchdog and actionpoints for the device */
            errorCode = DSL_AVX_SendMsgDebugWatchdogControl(pContext, nLine, DSL_TRUE);
            if (errorCode < DSL_SUCCESS)
            {
               DSL_DEBUG(DSL_DBG_ERR, (pContext,
                     "DSL_AVX_SoftRecoveryCheck: Failed to disable the memory watchdog."
                     DSL_CRLF));
            
               return DSL_ERROR;
            }
   
            /* Soft recover completion operation */
            DSL_UINT32_INC(DSL_DBS_STATISTICS_RECOVER_SOFT);

            /* Execute linestate recovery only for "intrusive" recovery */
            if (bNonIntrusiveSoftRecovery == DSL_FALSE)
            {
               nLineState = DSL_UINT32_GET(DSL_DBS_RECOVERY_LINESTATE);
               switch (nLineState)
               {
               case DSL_LINESTATUS_NOT_INITIALIZED:
               case DSL_LINESTATUS_IDLE:
               case DSL_LINESTATUS_UNKNOWN:
                  break;
               default:
                  DSL_DEBUG(DSL_DBG_MSG, (pContext,
                        "DSL[%02d]: DSL_AVX_SoftRecoveryCheck: restart line due to linestate 0x%X" DSL_CRLF, 
                        nLine, nLineState));
                  DSL_DEV_LineActivate(pContext, nLine);
                  break;
               }
            }

            DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_SoftRecoveryCheck: "
                                                 "Soft recovery has been completed." DSL_CRLF, nLine));   
         }
         
         return errorCode;
      }
   }

   return errorCode;
}

/**
   Retrieve the current XTSE status from FW.

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Triggering line for this function, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS in case of success
   - DSL_ERROR if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_XtseStatusGet(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet;
   
   /* request Operation State first (DSL-mode, Annex...) */
   nRet = DSL_AVX_SendMsgVtseStatusGet(pContext, nLine);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error during VTSE Status Get!" DSL_CRLF, nLine);

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   if (DSL_AVX_FwStatusCheck(pContext, nLine, DSL_AVX_FW_VDSL2))
   {
      nRet = DSL_AVX_SendMsgSelectedProfileVdsl2Get(pContext, nLine);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "Error during Selected Profile Vdsl2 Get!" DSL_CRLF, nLine);
   }
#endif /*(INCLUDE_DSL_API_VDSL_SUPPORT == 1)*/
   return errorCode;
}

/**
   Handdle deffered action (called on IDLE state)

   \param pContext Pointer to dsl library context structure, [I]
   \param nLine    Triggering line for this function, [I]

   \return
   Return values depend on the action to be handled
*/
DSL_LOCAL DSL_Error_t DSL_AVX_HandleDefferedAction(
   DSL_Context_t *pContext,
   DSL_uint16_t nLine)
{

   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;
   DSL_DeferredAction_t nActionOnIdle = pContext->DeviceContext.LineFlags[nLine].nDeferredActionOnIdle;
   DSL_TestModeConfig_t *pTestModeCfg;

   if (((DSL_boolean_t)DSL_INT8_GET(DSL_DBL_MFS_DEFERRED_ACTIVATION) == DSL_FALSE) ||
         (nActionOnIdle == DSL_AVX_DEFERRED_ACT_NONE))
   {
      return errorCode;
   }

   DSL_DEBUG( DSL_DBG_WRN, (pContext,
         "DSL[%02d]: DSL_AVX_HandleDefferedAction: type: %d" DSL_CRLF , nLine, nActionOnIdle));

   switch (nActionOnIdle)
   {
   case DSL_AVX_DEFERRED_ACT_LWC:
      errorCode = DSL_DEV_LineWriteConfig( pContext, nLine );
      break;
   case DSL_AVX_DEFERRED_ACT_LA:
      errorCode = DSL_AVX_LineActivate( pContext, nLine );
      break;
   case DSL_AVX_DEFERRED_ACT_LR:
      errorCode = DSL_AVX_LineRestart( pContext, nLine );
      break;
   case DSL_AVX_DEFERRED_ACT_LATM:
      pTestModeCfg = (DSL_TestModeConfig_t*)&pContext->DeviceContext.LineFlags[nLine].deferredActionData;
      errorCode = DSL_DEV_LineActivateTestMode( pContext, nLine, pTestModeCfg);
      break;
   case DSL_AVX_DEFERRED_ACT_NONE:
   default:
      break;
   }

   if (pContext->pEventCallback != DSL_NULL)
   {
      DSL_boolean_t bSemMask = DSL_FALSE;
      DSL_CB_DATA_ScheduledActionResult_t actionResult;

      bSemMask = (DSL_boolean_t)(DSL_UINT8_GET(DSL_DBL_SEM_SCHEDULED_ACTION_RETURN_CODE));
      actionResult.actionType = nActionOnIdle;
      actionResult.errorCode = errorCode;

      if (bSemMask == DSL_FALSE)
      {
         (void)(pContext->pEventCallback)( pContext,
                                     nLine,
                                     DSL_CHANNEL_NA,
                                     DSL_ACCESSDIR_NA,
                                     DSL_ATUDIR_NA,
                                     DSL_CBS_SCHEDULED_ACTION_RETURN_CODE,
                                     (DSL_CB_DATA_Union_t *)&actionResult );
      }
   }


   pContext->DeviceContext.LineFlags[nLine].nDeferredActionOnIdle = DSL_AVX_DEFERRED_ACT_NONE;

   return errorCode;

}

/**
   This function handles the Soft Recovery non-intrusive event.

   \param pContext     Pointer to dsl library context structure, [I]
   \param nLine        Specifies on which line the message was received, [I]
   \param pAck         Pointer to the event message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnMemoryWatchdogEvent(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   AVX_EvtMemoryWatchdog_t const *pAck
)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_AVX_SoftRecoveryParams_t softRecoveryData;

   DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_OnMemoryWatchdogEvent" DSL_CRLF, nLine));
   
   DSL_CHECK_POINTER(pContext, pAck);

   softRecoveryData.nStartAddress = DSL_AVX_PARA32_GET(pAck->FirstAddress);
   softRecoveryData.nStopAddress = DSL_AVX_PARA32_GET(pAck->StopAddress);
   softRecoveryData.nSegment = pAck->CurrentSegment;

   nRet = DSL_AVX_HandleSoftRecoveryEvent( pContext, nLine, &softRecoveryData, DSL_TRUE);
   DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
      "Error on DSL_AVX_HandleSoftRecoveryEvent!" DSL_CRLF, nLine);

   return errorCode;
}

/**
   This is a common function that handles Soft Recovery events.

   \param pContext     Pointer to dsl library context structure, [I]
   \param nLine        Specifies on which line the message was received, [I]
   \param pData         Pointer to the configuration data, [I]
   \param bNonIntrusive  Specifies whether soft recovery is non-intrusive or not, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_HandleSoftRecoveryEvent(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AVX_SoftRecoveryParams_t *pData,
   const DSL_boolean_t bNonIntrusive)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;
   DSL_uint16_t nDevice = 0, nDevLine = 0, i = 0;

   DSL_CHECK_POINTER(pContext, pData);

   DSL_GET_DEVICE_NUMBER(nLine, nDevice);

   if (DSL_UINT32_GET(DSL_DBI_AUTORECOVER_TRIGGERMASK) & DSL_AUTORECOVER_TRIGGER_SOFT_RECOVERY)
   {
       if (DSL_INT8_GET(DSL_DBI_MFS_SOFT_AS_FULL_RECOVERY) == 0)
       {
          DSL_DEBUG(DSL_DBG_MSG, (pContext,
             "DSL[%02d]: DSL_AVX_HandleSoftRecoveryEvent: Soft recovery request for address range = [0x%X - 0x%X]" DSL_CRLF,
             nLine, pData->nStartAddress, pData->nStopAddress));

          /*
             Theoretically two watchdogs could happen at the same time indicating different errors on different ICCMs.
             But our concept will handle one first, and after the watchdog gets enabled again, the second will occur
             immediately again and can be handled.
             Also two watchdogs may indicate the same OCM error independently (which is much more likely),
             but in this case we anyhow need to handle it only once.
          */

          /* Ignore all SoftRecovery Requests on a device as soon as SoftRecovery is ongoing already on this device */
          for (i=0; i<DSL_LINES_PER_DEVICE; i++)
          {
             DSL_DEV_GET_LINE_PARAM(nDevice, i, nDevLine);
             if (nDevLine == 0xFFFF) continue;

             if ((pContext->DeviceContext.bNonIntrusiveSoftRecovery[nDevLine] == DSL_TRUE) ||
                  (DSL_LineStatusGet(pContext, nDevLine) == DSL_DEVSTATE_SOFT_RECOVERY))
             {
                DSL_DEBUG(DSL_DBG_MSG, (pContext, "DSL[%02d]: DSL_AVX_HandleSoftRecoveryEvent: "
                   "Skip the trigger as the device is already busy on a recovery process." DSL_CRLF, nLine));

                return DSL_SUCCESS;
             }
          }

          /* Disable the memory watchdog and actionpoints for the device */
          errorCode = DSL_AVX_SendMsgDebugWatchdogControl(pContext, nLine, DSL_FALSE);
          if (errorCode < DSL_SUCCESS)
          {
             DSL_DEBUG(DSL_DBG_ERR, (pContext,
                   "DSL_AVX_HandleSoftRecoveryEvent: Failed to disable the memory watchdog."
                   DSL_CRLF));

             return DSL_ERROR;
          }

          DSL_UINT32_SET(DSL_DBS_SOFT_RECOVERY_FIRST_ADDRESS, pData->nStartAddress);
          DSL_UINT32_SET(DSL_DBS_SOFT_RECOVERY_STOP_ADDRESS,  pData->nStopAddress);
          DSL_UINT16_SET(DSL_DBS_SOFT_RECOVERY_CURRENT_SEGMENT, pData->nSegment  );
          DSL_UINT16_SET(DSL_DBS_SOFT_RECOVERY_MEM_BLOCK_ADDRESS_RANGE_IDX, 0);

          if (bNonIntrusive)
          {
             pContext->DeviceContext.bNonIntrusiveSoftRecovery[nLine] = DSL_TRUE;
          }
          else
          {
             DSL_AVX_RequestIdle(pContext, nLine, DSL_FALSE);
             /* Soft recovery state entry */
             DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_SOFT_RECOVERY);
          }
       }
       else
       {
          /* Request full recovery */
          DSL_LineStatusModify(pContext, nLine, DSL_DEVSTATE_RECOVERY_REQUIRED);
          DSL_DBG_ExceptionHistoryAddTrigger(pContext, nLine, DSL_AUTORECOVER_TRIGGER_SOFT_RECOVERY);
       }
    }

    return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_OnIdle(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
)
{
   static const DSL_uint8_t nChannel = 0;
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_boolean_t bLineRestart = DSL_FALSE;

   DSL_AVX_PowerSavingTimerStart(pContext, nLine, DSL_TRUE);

   DSL_AVX_ResetShowtimeValues(pContext, nLine, nChannel);

#if (INCLUDE_RESET_RETRIES == 1)
   if (DSL_TimerDB_Remove(pContext, nLine, DSL_DBS_RESET_TIMEOUT_ID) != DSL_SUCCESS)
   {
      DSL_DEBUG( DSL_DBG_WRN,
         (pContext, "DSL[%02d]: DSL_AVX_OnModemFsmStateGet - could "
         "not remove timeout for RESET!" DSL_CRLF , nLine ));
   }
#endif /* (INCLUDE_RESET_RETRIES == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   /* Handle APS state machine if enabled */
   if (DSL_AVX_ApsFsmStateGet(pContext, nLine) == DSL_APS_RECONFIG)
   {
      /* the APS State machine did a config change and a reset latest and
         needs now the reconfiguration to be applied and
         a restart of the line */
      nRet = DSL_DEV_LineActivate(pContext, nLine);
      /* a statechange of the APS-FSM is already done by the LineActivate */
   }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (DSL_ENABLE_EAPS == 1)
   switch (_DSLAPI DSL_AVX_EapsFsmStateGet(pContext, nLine))
   {
      case DSL_EAPS_DISABLED   :
      case DSL_EAPS_FINISHED   :
      case DSL_EAPS_ENABLED    :
      case DSL_EAPS_ADSL_TRIAL :
      case DSL_EAPS_ADSL_FIXED :
      case DSL_EAPS_8A_TRIAL   :
      case DSL_EAPS_12A_TRIAL  :
      case DSL_EAPS_8A_FIXED   :
         /* nothing to do */
         break;
      case DSL_EAPS_ADSL_TRIAL_CONFIG :
      case DSL_EAPS_ADSL_FIXED_CONFIG :
      case DSL_EAPS_8A_TRIAL_CONFIG   :
      case DSL_EAPS_12A_TRIAL_CONFIG  :
      case DSL_EAPS_8A_FIXED_CONFIG   :
         /* the EAPS State machine needs now the reconfiguration
            to be applied and the line to be restarted */
         /* due to some FW problem the auto restart needs to be
            enabled here again */
         DSL_UINT8_SET(DSL_DBL_AUTO_RESTART, DSL_TRUE);
         bLineRestart = DSL_TRUE;
         break;
   }
#endif /* #if (DSL_ENABLE_EAPS == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   switch (_DSLAPI DSL_AVX_ApsP1FsmStateGet(pContext, nLine))
   {
      case DSL_APSP1_DISABLED   :
      case DSL_APSP1_ENABLED    :
      case DSL_APSP1_ACTIVE :
         /* nothing to do */
         break;
      case DSL_APSP1_CONFIG:
         /* the APSP1 State machine needs now the reconfiguration
            to be applied and the line to be restarted */
         /* due to some FW problem the auto restart needs to be
            enabled here again */
         DSL_UINT8_SET(DSL_DBL_AUTO_RESTART, DSL_TRUE);
         bLineRestart = DSL_TRUE;
         break;
   }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   if (DSL_AVX_Eaps2FsmStateGet(pContext, nLine) == DSL_EAPS2_RETRAIN)
   {
      DSL_AVX_Eaps2D2CheckSend(pContext, nLine, DSL_FALSE);

      DSL_UINT8_SET(DSL_DBL_AUTO_RESTART, DSL_TRUE);
      bLineRestart = DSL_TRUE;
   }
   if ((DSL_boolean_t)DSL_UINT8_GET(DSL_DBS_MEMSPLIT_RETRAIN_MODE) == DSL_TRUE)
   {
      bLineRestart = DSL_TRUE;
   }
#endif /* (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

#ifdef INCLUDE_DSL_BND
   /* handle the PAF state machine */
   nRet = DSL_AVX_BND_FsmOnReset(pContext, nLine, &bLineRestart);
#endif

   if (bLineRestart)
   {
      nRet = DSL_DEV_LineWriteConfig(pContext, nLine);
      nRet = DSL_AVX_LineRestart(pContext, nLine);
   }

#if defined(INCLUDE_DSL_DSM) && (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   if (DSL_DSM_DeviceMetaStateGet(pContext, nLine) == DSL_DSM_METASTATE_LOS)
   {
      nRet = DSL_AVX_OnDsmLossMonitor(pContext, nLine);
      DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
         "DSL_AVX_OnDsmStatusGet: No IDLE yet, "
         "DSL_DSM_STATE_IDLE_REQUEST deferred!" DSL_CRLF, nLine);

      nRet = DSL_DSM_ProcessState(pContext, nLine, DSL_DSM_STATE_IDLE_REQUEST);
      DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);
   }
#endif /* defined(INCLUDE_DSL_DSM) && (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
   
   return errorCode;
}

#if defined(INCLUDE_DSL_DSM) && (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
DSL_Error_t DSL_AVX_OnDsmLossMonitor
(
   DSL_Context_t *          pContext,
   const DSL_uint16_t       nTargetLine
)
{
   DSL_Error_t errorCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
   DSL_uint16_t nDevice = 0, nLine = nTargetLine, i;

   DSL_GET_DEVICE_NUMBER(nTargetLine, nDevice);

   for (i=0; i<DSL_LINES_PER_DEVICE; i++)
   {
      DSL_DEV_GET_LINE_PARAM(nDevice, i, nLine);
      if (nLine != 0xFFFF)
      {
         /* Deactivate only if line is in "Vectoring(-friendly)" showtime or activated. 
            Check XTSE status in showtime or XTSE config if activation is still running. */
         if (DSL_DSM_IsVectoringActive(pContext, nLine) ||
             DSL_DSM_IsLineActivatedWithVectoring(pContext, nLine))
         {
            /* even a forced idle may take 100sec if the DSM is already broken */
            nRet = DSL_AVX_LineShutdownNoWait(pContext, nLine);
            DSL_CHECK_ERROR_CODE(nRet, DSL_FALSE, errorCode);                      
         }
      }
   }
   
   for (i=0; i<DSL_LINES_PER_DEVICE; i++)
   {
      DSL_DEV_GET_LINE_PARAM(nDevice, i, nLine);
      if (nLine != 0xFFFF)
      {
         /* Now check all for IDLE */
         if (DSL_DSM_IsVectoringActive(pContext, nLine) ||
             DSL_DSM_IsLineActivatedWithVectoring(pContext, nLine))
         {
            nRet = DSL_AVX_PollDevForModemState(pContext, nLine, AVX_IDLE_MASK, 0);
            DSL_CHECK_ERROR_CODE_MSG(nRet, DSL_TRUE, errorCode,
               "DSL_AVX_OnDsmStatusGet: Error waiting for IDLE!" DSL_CRLF, nLine);
         }
      }
   }
   
   return errorCode;
}
#endif /* defined(INCLUDE_DSL_DSM) && (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */
_DSLAPI_END



/**
   This function handles the EVT_RTX_DS_OMSG1RMSG2_Info_Get message.

   \param pContext     Pointer to dsl library context structure, [I]
   \param nLine        Specifies on which line the message was received, [I]
   \param pAck         Pointer to the event message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnRtxOMsg1RMsg2
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtRtxOmsg1Rmsg2InfoGet_t *pEvt
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   static const DSL_uint8_t nChannel = 0;

   DSL_DEBUG(DSL_DBG_MSG, (pContext,
      "DSL[%02d]: DSL_AVX_OnRtxOMsg1RMsg2 ", nLine));

   DSL_UINT16_SET(DSL_DBS_PMS_TC_OMSG1_OCT_2_3, pEvt->PmsTcOmsg1Oct2_3);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_OMSG1_OCT_4_5, pEvt->PmsTcOmsg1Oct4_5);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_OMSG1_OCT_6_7, pEvt->PmsTcOmsg1Oct6_7);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_OMSG1_OCT_8_9, pEvt->PmsTcOmsg1Oct8_9);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_2_3, pEvt->PmsTcRmsg2Oct2_3);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_4_5, pEvt->PmsTcRmsg2Oct4_5);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_6_7, pEvt->PmsTcRmsg2Oct6_7);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_8_9, pEvt->PmsTcRmsg2Oct8_9);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_10_11, pEvt->PmsTcRmsg2Oct10_11);
   DSL_UINT16_SET(DSL_DBS_PMS_TC_RMSG2_OCT_12_13, pEvt->PmsTcRmsg2Oct12_13);
#endif
   return errorCode;

}

/**
   This function handles the EVT_OPMS_Info_Get message.

   \param pContext     Pointer to dsl library context structure, [I]
   \param nLine        Specifies on which line the message was received, [I]
   \param pAck         Pointer to the event message, [I]

   \return
   Return values are defined within the DSL_Error_t definition
   - DSL_SUCCESS (0) in case of success
   - DSL_ERROR (-1) if operation failed
*/
DSL_LOCAL DSL_Error_t DSL_AVX_OnOpmsInfoGet
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const AVX_EvtOpmsInfoGet_t *pEvt
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   static const DSL_uint8_t nChannel = 0;

   DSL_UINT32_SET(DSL_DBS_OPMS_INFO_MAXDELAY_OCT_DS_0, DSL_AVX_PARA32_GET(pEvt->MaxDelayOctetDs0));
   DSL_UINT32_SET(DSL_DBS_OPMS_INFO_MAXDELAY_OCT_DS_1, DSL_AVX_PARA32_GET(pEvt->MaxDelayOctetDs1));
   DSL_UINT32_SET(DSL_DBS_OPMS_INFO_MAXDELAY_OCT_US_0, DSL_AVX_PARA32_GET(pEvt->MaxDelayOctetUs0));
   DSL_UINT32_SET(DSL_DBS_OPMS_INFO_MAXDELAY_OCT_US_1, DSL_AVX_PARA32_GET(pEvt->MaxDelayOctetUs1));
#endif
   return errorCode;
}

DSL_LOCAL DSL_Error_t DSL_AVX_RtxAggAchNdrCalculate
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine,
   const DSL_AccessDir_t nDirection
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
   DSL_dbi_t nDbiAggAchNDR;
   DSL_uint8_t nHrtRx = 0, nHrtTx = 0, nHrtRef = 0;
   DSL_uint8_t nHrtRxS = 0, nHrtTxS = 0; /* half roundtrips expressed in symbols*/
   DSL_uint32_t nMaxDelayOctet = 0, nAggAchNdr = 0, nMaxAggAchNdr = 0;
   DSL_float_t fTdmt = 0.0;
   static const DSL_uint8_t nChannel = 0;

   if (DSL_UINT8_GET(DSL_DBS_RTX_USED_DS) == (DSL_uint8_t)DSL_RTX_USED)
   {
      if (nDirection == DSL_DOWNSTREAM)
      {
         nHrtTx = (DSL_UINT16_GET(DSL_DBS_PMS_TC_RMSG2_OCT_4_5) & AVX_03E3_PMS_TC_RMSG2_OCT4_MASK) >>  AVX_03E3_PMS_TC_RMSG2_OCT4_POS;
         nHrtRx = (DSL_UINT16_GET(DSL_DBS_PMS_TC_RMSG2_OCT_4_5) & AVX_03E3_PMS_TC_RMSG2_OCT5_MASK) >>  AVX_03E3_PMS_TC_RMSG2_OCT5_POS;

         nMaxDelayOctet |= (( (DSL_UINT16_GET(DSL_DBS_PMS_TC_RMSG2_OCT_10_11))
               & AVX_03E3_PMS_TC_RMSG2_OCT11_MASK) >> 8) << 16; /* MAXDELAYOCTET_ext_R: Bits 23-16 out of 23:0*/
         nMaxDelayOctet |= ((DSL_UINT16_GET(DSL_DBS_PMS_TC_RMSG2_OCT_12_13))
               & AVX_03E3_PMS_TC_RMSG2_OCT12_MASK) << 8;/* Bits 15-8 out of 23:0*/
         nMaxDelayOctet |= ((DSL_UINT16_GET(DSL_DBS_PMS_TC_RMSG2_OCT_12_13))
               & AVX_03E3_PMS_TC_RMSG2_OCT13_MASK) >> 8;  /* Bits 7-0 out of 23:0*/

         nDbiAggAchNDR = DSL_DBS_RTX_AGG_ACHIEVABLE_NDR_FE;

      }
      else
      {
         nHrtTx = (DSL_UINT16_GET(DSL_DBS_PMS_TC_OMSG1_OCT_4_5)  & AVX_03E3_PMS_TC_OMSG1_OCT4_MASK) >>  AVX_03E3_PMS_TC_OMSG1_OCT4_POS;
         nHrtRx = (DSL_UINT16_GET(DSL_DBS_PMS_TC_OMSG1_OCT_4_5) & AVX_03E3_PMS_TC_OMSG1_OCT5_MASK) >>  AVX_03E3_PMS_TC_OMSG1_OCT5_POS;

         nMaxDelayOctet = 60548 * 2;
         nDbiAggAchNDR = DSL_DBS_RTX_AGG_ACHIEVABLE_NDR_NE;
      }


      /* acc. to \ref AVX_03E3_PMS_TC_OMSG1_OCT2_MASK the octet
         is coded as [00ddssss], where:
         - ssss is a four-bit number indicating in multiple of DMT symbols
         - dd is a two-bit number indicating the part of the delay in number of DTUs*/
      if (!(nHrtRx & 0x30) && !(nHrtTx & 0x30))
      {
         /*if actual half roundtrips computed in DTU equal to 0*/
         if (DSL_VdslConfiguredProfileEquals(pContext, nLine, DSL_PROFILE_30A))
         {
            fTdmt = 8.0 * 256.0/257.0;
            nHrtRef = 12;
            nMaxAggAchNdr = 250000; /* 250 Mbit/s */
         }
         else
         {
            fTdmt = 4.0 * 256.0/257.0;
            nHrtRef =  8;
            nMaxAggAchNdr = 150000; /* 150 Mbit/s */
         }
         nHrtRxS = nHrtRx & 0x0F; /* the part of the delay in multiple of DMT symbols*/
         nHrtTxS = nHrtTx & 0x0F;
         nAggAchNdr = (8 *  nMaxDelayOctet * 0.5) / ( (DSL_MAX(nHrtRxS, nHrtTxS) + nHrtRef + 1) / fTdmt);
         nAggAchNdr = DSL_MIN(nAggAchNdr, nMaxAggAchNdr) * 1000;

         DSL_UINT32_SET(nDbiAggAchNDR, nAggAchNdr);
      }
      else
      {
         DSL_UINT32_SET(nDbiAggAchNDR, 0);
      }
   }
#endif
   return errorCode;


}

#if (INCLUDE_DSL_API_VDSL_SUPPORT == 1)
/* Backup all VDSL related XTSE bits (legacy and vectoring). */
DSL_LOCAL DSL_Error_t DSL_AVX_VdslBackup
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;

   DSL_UINT8_SET(DSL_DBS_EAPS2_VTSE_BACKUP,DSL_UINT8_GET(DSL_DBL_ATSE_8));
   DSL_UINT8_SET(DSL_DBS_EAPS2_VTSE2_BACKUP,DSL_UINT8_GET(DSL_DBL_ATSE_9));
   return errorCode;
}

/* Disable all VDSL related XTSE bits (legacy and vectoring)
   in order to force ADSL mode. */
DSL_LOCAL DSL_Error_t DSL_AVX_VdslDisable
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;

   DSL_UINT8_SET(DSL_DBL_ATSE_8, 0);
   DSL_UINT8_SET(DSL_DBL_ATSE_9, 0);
   return errorCode;
}

/* Restore all VDSL related XTSE bits (legacy and vectoring). */
DSL_LOCAL DSL_Error_t DSL_AVX_VdslRestore
(
   DSL_Context_t *pContext,
   const DSL_uint16_t nLine
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   static const DSL_uint8_t nChannel = 0;

   DSL_UINT8_SET(DSL_DBL_ATSE_8, DSL_UINT8_GET(DSL_DBS_EAPS2_VTSE_BACKUP));
   DSL_UINT8_SET(DSL_DBL_ATSE_9, DSL_UINT8_GET(DSL_DBS_EAPS2_VTSE2_BACKUP));
   return errorCode;
}
#endif /* #if (INCLUDE_DSL_API_VDSL_SUPPORT == 1) */

//Ani
DSL_LOCAL DSL_Error_t DSL_AVX_HandleChangeEthPptpUni
(
   const DSL_uint16_t nLine, 
   const DSL_PPTP_ETH_UNI_State_t nState
)
{
   DSL_Error_t errorCode = DSL_SUCCESS;
   switch(nState)
   {
      case DSL_PPTP_ETH_UNI_UP:
        //Clear the PPTP Eth UNI Alarm 
        system(/opt/lantiq/bin/omci_pipe.sh managed_entity_alarm_set 11 257 0 0);
        //Mark the Operational state of the ME as Enabled
        //system(/opt/lantiq/bin/omci_pipe.sh managed_entity_attr_data_set 11 257 6 0);
        break;

      case DSL_PPTP_ETH_UNI_DOWN:
        //Raise the PPTP Eth UNI Alarm 
        system(/opt/lantiq/bin/omci_pipe.sh managed_entity_alarm_set 11 257 0 1);
        //Mark the Operational state of the ME as Disabled
        break;

      default:
        break;
   }   

}
//Ani
#endif /* defined(INCLUDE_DSL_API_GEMINAX_R3) || defined(INCLUDE_DSL_API_VINAX_R3) */


